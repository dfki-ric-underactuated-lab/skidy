<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>skidy.matrices API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>skidy.matrices</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from sympy import Matrix, Identity, symbols, sin, cos, zeros, MutableDenseMatrix, Expr
from typing import Union, List, Tuple
import numpy as np

def generalized_vectors(
    DOF: int, startindex: int=0, derivatives: bool= False
    ) -&gt; Tuple[MutableDenseMatrix, MutableDenseMatrix, MutableDenseMatrix]:
    &#34;&#34;&#34;Generate symbolic generalized vectors q, qd and q2d and optional
    q3d and q4d.
    
    The symbols are named as follows:
        
        q0, q1, ....., qi for joint positions.
        dq0, dq1, ....., dqi for joint velocities.
        ddq0, ddq1, ....., ddqi for joint accelerations.
        dddq0, dddq1, ....., dddqi for joint jerks.
        ddddq0, ddddq1, ....., ddddqi for joint jounces.
        

    Args:
        DOF (int): Degrees of freedom.
        startindex (int, optional): Index of first joint. Defaults to 0.
        derivatives (bool, optional): return jerks and jounces too. 
            Defaults to False. 

    Returns:
        tuple(sympy.Matrix): 
            Generalized vectors: (q,dq,d2q) if derivative == False
            else: (q,dq,d2q,q3d,q4d) 
    &#34;&#34;&#34;
    if DOF &gt; 1:
        q = Matrix(symbols(&#34; &#34;.join(f&#34;q{i}&#34; for i in range(startindex,startindex+DOF))))
        qd = Matrix(symbols(&#34; &#34;.join(f&#34;dq{i}&#34; for i in range(startindex,startindex+DOF))))
        q2d = Matrix(symbols(&#34; &#34;.join(f&#34;ddq{i}&#34; for i in range(startindex,startindex+DOF))))
        q3d = Matrix(symbols(&#34; &#34;.join(f&#34;dddq{i}&#34; for i in range(startindex,startindex+DOF))))
        q4d = Matrix(symbols(&#34; &#34;.join(f&#34;ddddq{i}&#34; for i in range(startindex,startindex+DOF))))
    else:
        q = Matrix([symbols(&#34; &#34;.join(f&#34;q{i}&#34; for i in range(startindex,startindex+DOF)))])
        qd = Matrix([symbols(&#34; &#34;.join(f&#34;dq{i}&#34; for i in range(startindex,startindex+DOF)))])
        q2d = Matrix([symbols(&#34; &#34;.join(f&#34;ddq{i}&#34; for i in range(startindex,startindex+DOF)))])
        q3d = Matrix([symbols(&#34; &#34;.join(f&#34;dddq{i}&#34; for i in range(startindex,startindex+DOF)))])
        q4d = Matrix([symbols(&#34; &#34;.join(f&#34;ddddq{i}&#34; for i in range(startindex,startindex+DOF)))])
    if derivatives:
        return q, qd, q2d, q3d, q4d
    else: 
        return q, qd, q2d

def joint_screw(axis: list, vec: list=[0,0,0], revolute: bool=True) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Get joint screw coordinates from joint axis and vector to joint.

    Args:
        axis (list): 
            Joint axis w.r.t. inertial frame.
        vec (list, optional): 
            Vector to joint axis from inertial frame for revolute joint. 
            Defaults to [0,0,0].
        revolute (bool, optional): 
            Revolute (True) or prismatic (False) joint. 
            Defaults to True.

    Returns:
        sympy.Matrix: joint screw coordinates.
    &#34;&#34;&#34;
    e = Matrix(axis)
        
    if revolute:
        y = Matrix(vec)
        return Matrix([e, y.cross(e)])
    else:
        return Matrix([0,0,0,e])
        

def symbolic_inertia_matrix(
    index: Union[int, str]=&#34;&#34;, pointmass: bool=False) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Create 3 x 3 symbolic inertia matrix with auto generated variable names.

    Args:
        index (int or str): 
            postfix for variable name. Defaults to &#34;&#34;.
        pointmass (bool): 
            Inertial matrix = I * Identity. Default to False.
    
    Returns:
        sympy.Matrix: Inertia matrix (3,3)
    &#34;&#34;&#34;
    if pointmass:
        I = symbols(f&#34;I{index}&#34;, real=1, constant=1)
        return I*Identity(3)
    Ixx, Iyy, Izz, Ixy, Ixz, Iyz = symbols(
        f&#34;Ixx{index} Iyy{index} Izz{index} Ixy{index} Ixz{index} Iyz{index}&#34;)
    
    I = Matrix([[Ixx, Ixy, Ixz],
                [Ixy, Iyy, Iyz],
                [Ixz, Iyz, Izz]])
    return I

def SE3AdjInvMatrix(C: MutableDenseMatrix) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Compute Inverse of (6x6) Adjoint matrix for SE(3)

    Args:
        C (sympy.Matrix): SE(3) Pose.

    Returns:
        sympy.Matrix: Inverse of (6x6) Adjoint matrix
    &#34;&#34;&#34;
    AdInv = Matrix([[C[0, 0], C[1, 0], C[2, 0], 0, 0, 0],
                    [C[0, 1], C[1, 1], C[2, 1], 0, 0, 0],
                    [C[0, 2], C[1, 2], C[2, 2], 0, 0, 0],
                    [-C[2, 3]*C[1, 0]+C[1, 3]*C[2, 0], 
                        C[2, 3]*C[0, 0]-C[0, 3]*C[2, 0],
                        (-C[1, 3])*C[0, 0]+C[0, 3]*C[1, 0], 
                        C[0, 0], C[1, 0], C[2, 0]],
                    [-C[2, 3]*C[1, 1]+C[1, 3]*C[2, 1], 
                        C[2, 3]*C[0, 1]-C[0, 3]*C[2, 1],
                        (-C[1, 3])*C[0, 1]+C[0, 3]*C[1, 1], 
                        C[0, 1], C[1, 1], C[2, 1]],
                    [-C[2, 3]*C[1, 2]+C[1, 3]*C[2, 2], 
                        C[2, 3]*C[0, 2]-C[0, 3]*C[2, 2],
                        (-C[1, 3])*C[0, 2]+C[0, 3]*C[1, 2], 
                        C[0, 2], C[1, 2], C[2, 2]]])
    return AdInv

def SE3AdjMatrix(C: MutableDenseMatrix) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Compute (6x6) Adjoint matrix for SE(3)

    Args:
        C ([type]): SE(3) Pose.

    Returns:
    sympy.Matrix: (6x6) Adjoint matrix
    &#34;&#34;&#34;
    Ad = Matrix([[C[0, 0], C[0, 1], C[0, 2], 0, 0, 0],
                    [C[1, 0], C[1, 1], C[1, 2], 0, 0, 0],
                    [C[2, 0], C[2, 1], C[2, 2], 0, 0, 0],
                    [-C[2, 3]*C[1, 0]+C[1, 3]*C[2, 0], 
                    -C[2, 3]*C[1, 1]+C[1, 3]*C[2, 1],
                    -C[2, 3]*C[1, 2]+C[1, 3]*C[2, 2], 
                    C[0, 0], C[0, 1], C[0, 2]],
                    [C[2, 3]*C[0, 0]-C[0, 3]*C[2, 0],  
                    C[2, 3]*C[0, 1]-C[0, 3]*C[2, 1],
                    C[2, 3]*C[0, 2]-C[0, 3]*C[2, 2], 
                    C[1, 0], C[1, 1], C[1, 2]],
                    [-C[1, 3]*C[0, 0]+C[0, 3]*C[1, 0], 
                    -C[1, 3]*C[0, 1]+C[0, 3]*C[1, 1],
                    -C[1, 3]*C[0, 2]+C[0, 3]*C[1, 2], 
                    C[2, 0], C[2, 1], C[2, 2]]])
    return Ad

def SE3adMatrix(X: MutableDenseMatrix) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Compute (6x6) adjoint matrix for SE(3) 
        - also known as spatial cross product in the literature.

    Args:
        X (sympy.Matrix): (6x1) spatial vector.

    Returns:
        sympy.Matrix: (6x6) adjoint matrix
    &#34;&#34;&#34;
    ad = Matrix([[0, -X[2, 0], X[1, 0], 0, 0, 0],
                 [X[2, 0], 0, -X[0, 0], 0, 0, 0],
                 [-X[1, 0], X[0, 0], 0, 0, 0, 0],
                 [0, -X[5, 0], X[4, 0], 0, -X[2, 0], X[1, 0]],
                 [X[5, 0], 0, -X[3, 0], X[2, 0], 0, -X[0, 0]],
                 [-X[4, 0], X[3, 0], 0, -X[1, 0], X[0, 0], 0]])
    return ad

def SE3Exp(XX: MutableDenseMatrix, t: Union[float, Expr]) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;compute exponential mapping for SE(3).

    Args:
        XX ([type]): (6,1) spatial vector.
        t (sympy.Expr): rotation angle.

    Returns:
        sympy.Matrix: (4,4) SE(3) Pose.
    &#34;&#34;&#34;
    X = XX.T
    xi = Matrix(X[0:3])
    eta = Matrix(X[3:6])
    xihat = Matrix([[0, -X[2], X[1]],
                    [X[2], 0, -X[0]],
                    [-X[1], X[0], 0]])
    R = Matrix(Identity(3)) + sin(t)*xihat + (1-cos(t))*(xihat*xihat)
    if xi == zeros(3, 1):
        p = eta * t
    else:
        p = (Matrix(Identity(3))-R)*(xihat*eta) + xi*(xi.T*eta)*t
    C = R.row_join(p).col_join(Matrix([0, 0, 0, 1]).T)
    return C

def SE3Inv(C: MutableDenseMatrix) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Compute analytical inverse of exponential mapping for SE(3).

    Args:
        C (sympy.Matrix): (4,4) SE(3) Pose.

    Returns:
        sympy.Matrix: (4,4) Inverse of SE(3) Pose.
    &#34;&#34;&#34;
    CInv = Matrix([[C[0, 0], C[1, 0], C[2, 0], 
                    -C[0, 0]*C[0, 3]-C[1, 0]*C[1, 3]-C[2, 0]*C[2, 3]],
                    [C[0, 1], C[1, 1], C[2, 1], 
                    -C[0, 1]*C[0, 3]-C[1, 1]*C[1, 3]-C[2, 1]*C[2, 3]],
                    [C[0, 2], C[1, 2], C[2, 2], -C[0, 2] *
                        C[0, 3]-C[1, 2]*C[1, 3]-C[2, 2]*C[2, 3]],
                    [0, 0, 0, 1]])
    return CInv

def SO3Exp(axis: MutableDenseMatrix, angle: Union[float, Expr]) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Compute exponential mapping for SO(3).

    Args:
        axis (sympy.Matrix): Rotation axis
        angle (double): Rotation angle

    Returns:
        sympy.Matrix: Rotation matrix
    &#34;&#34;&#34;
    axis = Matrix(axis)
    xhat = Matrix([[0, -axis[2, 0], axis[1, 0]],
                    [axis[2, 0], 0, -axis[0, 0]],
                    [-axis[1, 0], axis[0, 0], 0]])
    R = Matrix(Identity(3)) + sin(angle) * xhat + (1-cos(angle))*(xhat*xhat)
    return R

def inertia_matrix(Ixx: Union[float, Expr]=0, Ixy: Union[float, Expr]=0, 
                   Ixz: Union[float, Expr]=0, Iyy: Union[float, Expr]=0, 
                   Iyz: Union[float, Expr]=0, Izz: Union[float, Expr]=0) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Create 3 x 3 inertia matrix from independent inertia values.

    Args:
        Ixx (float or sympy.Expr): Inertia value I11. Defaults to 0.
        Ixy (float or sympy.Expr): Inertia value I12. Defaults to 0.
        Ixz (float or sympy.Expr): Inertia value I13. Defaults to 0.
        Iyy (float or sympy.Expr): Inertia value I22. Defaults to 0.
        Iyz (float or sympy.Expr): Inertia value I23. Defaults to 0.
        Izz (float or sympy.Expr): Inertia value I33. Defaults to 0.

    Returns:
        sympy.Matrix: Inertia matrix (3,3)
    &#34;&#34;&#34;
    I = Matrix([[Ixx, Ixy, Ixz],
                [Ixy, Iyy, Iyz],
                [Ixz, Iyz, Izz]])
    return I

def transformation_matrix(r: MutableDenseMatrix=Matrix(Identity(3)), 
                         t: MutableDenseMatrix=zeros(3, 1)) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Build transformation matrix from rotation and translation.

    Args:
        r (sympy.Matrix): 
            SO(3) Rotation matrix (3,3). 
            Defaults to sympy.Matrix(Identity(3))
        t (sympy.Matrix): 
            Translation vector (3,1). Defaults to sympy.zeros(3,1)

    Returns:
        sympy.Matrix: Transformation matrix (4,4)
    &#34;&#34;&#34;
    if type(t) is list:
        t = Matrix(t)
    T = r.row_join(t).col_join(Matrix([[0, 0, 0, 1]]))
    return T

def mass_matrix_mixed_data(m: Union[float, Expr], Theta: MutableDenseMatrix, 
                        COM: MutableDenseMatrix) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Build mass-inertia matrix in SE(3) from mass, inertia and 
    center of mass information.

    Args:
        m (float): Mass.
        Theta (array_like): Inertia (3,3).
        COM (array_like): Center of mass (3,1).

    Returns:
        sympy.Matrix: Mass-inertia matrix (6,6).
    &#34;&#34;&#34;
    M = Matrix([[Theta[0, 0], Theta[0, 1], Theta[0, 2], 0, 
                    (-COM[2])*m, COM[1]*m],
                [Theta[0, 1], Theta[1, 1], Theta[1, 2],
                    COM[2]*m, 0, (-COM[0]*m)],
                [Theta[0, 2], Theta[1, 2], Theta[2, 2],
                    (-COM[1])*m, COM[0]*m, 0],
                [0, COM[2]*m, (-COM[1]*m), m, 0, 0],
                [(-COM[2])*m, 0, COM[0]*m, 0, m, 0],
                [COM[1]*m, (-COM[0])*m, 0, 0, 0, m]])
    return M

def rpy_to_matrix(coords: Union[list,MutableDenseMatrix]) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Convert roll-pitch-yaw coordinates to a 3x3 homogenous rotation matrix.

    Adapted from urdfpy 

    The roll-pitch-yaw axes in a typical URDF are defined as a
    rotation of ``r`` radians around the x-axis followed by a rotation of
    ``p`` radians around the y-axis followed by a rotation of ``y`` radians
    around the z-axis. These are the Z1-Y2-X3 Tait-Bryan angles. See
    Wikipedia_ for more information.

    .. _Wikipedia: https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix

    Parameters
    ----------
    coords : (3,) float
        The roll-pitch-yaw coordinates in order (x-rot, y-rot, z-rot).

    Returns
    -------
    R : (3,3) float
        The corresponding homogenous 3x3 rotation matrix.
    &#34;&#34;&#34;
    c3 = cos(coords[0])
    c2 = cos(coords[1])
    c1 = cos(coords[2])
    s3 = sin(coords[0])
    s2 = sin(coords[1])
    s1 = sin(coords[2])
    return Matrix([
        [c1 * c2, (c1 * s2 * s3) - (c3 * s1), (s1 * s3) + (c1 * c3 * s2)],
        [c2 * s1, (c1 * c3) + (s1 * s2 * s3), (c3 * s1 * s2) - (c1 * s3)],
        [-s2, c2 * s3, c2 * c3]
    ])

def xyz_rpy_to_matrix(xyz_rpy: Union[list,MutableDenseMatrix]) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Convert xyz_rpy coordinates to a 4x4 homogenous matrix.

    Adapted from urdfpy

    Parameters
    ----------
    xyz_rpy : (6,) float
        The xyz_rpy vector.

    Returns
    -------
    matrix : (4,4) float
        The homogenous transform matrix.
    &#34;&#34;&#34;
    matrix = Matrix(Identity(4))
    matrix[:3, 3] = xyz_rpy[:3]
    matrix[:3, :3] = rpy_to_matrix(xyz_rpy[3:])
    return matrix

def matrix_to_rpy(R, solution=1):
    &#34;&#34;&#34;Convert a 3x3 transform matrix to roll-pitch-yaw coordinates.

    The roll-pitchRyaw axes in a typical URDF are defined as a
    rotation of ``r`` radians around the x-axis followed by a rotation of
    ``p`` radians around the y-axis followed by a rotation of ``y`` radians
    around the z-axis. These are the Z1-Y2-X3 Tait-Bryan angles. See
    Wikipedia_ for more information.

    .. _Wikipedia: https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix

    There are typically two possible roll-pitch-yaw coordinates that could have
    created a given rotation matrix. Specify ``solution=1`` for the first one
    and ``solution=2`` for the second one.

    Parameters
    ----------
    R : (3,3) float
        A 3x3 homogenous rotation matrix.
    solution : int
        Either 1 or 2, indicating which solution to return.

    Returns
    -------
    coords : (3,) float
        The roll-pitch-yaw coordinates in order (x-rot, y-rot, z-rot).
    &#34;&#34;&#34;
    R = np.asanyarray(R, dtype=np.float64)
    r = 0.0
    p = 0.0
    y = 0.0

    if np.abs(R[2,0]) &gt;= 1.0 - 1e-12:
        y = 0.0
        if R[2,0] &lt; 0:
            p = np.pi / 2
            r = np.arctan2(R[0,1], R[0,2])
        else:
            p = -np.pi / 2
            r = np.arctan2(-R[0,1], -R[0,2])
    else:
        if solution == 1:
            p = -np.arcsin(R[2,0])
        else:
            p = np.pi + np.arcsin(R[2,0])
        r = np.arctan2(R[2,1] / np.cos(p), R[2,2] / np.cos(p))
        y = np.arctan2(R[1,0] / np.cos(p), R[0,0] / np.cos(p))

    return np.array([r, p, y], dtype=np.float64)


def matrix_to_xyz_rpy(matrix):
    &#34;&#34;&#34;Convert a 4x4 homogenous matrix to xyzrpy coordinates.

    Parameters
    ----------
    matrix : (4,4) float
        The homogenous transform matrix.

    Returns
    -------
    xyz_rpy : (6,) float
        The xyz_rpy vector.
    &#34;&#34;&#34;
    xyz = matrix[:3,3]
    rpy = matrix_to_rpy(matrix[:3,:3])
    return np.hstack((xyz, rpy))

def quaternion_to_matrix(Q: Union[list,MutableDenseMatrix]) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Convert a quaternion into SO(3) rotation matrix.

    Args:
        Q (list | sympy.MutableDenseMatrix): Quaternion in order [w,x,y,z].
        
    Returns:
        sympy.Matrix: (3,3) Rotation matrix.
    &#34;&#34;&#34;
    # ensure symbolic values
    Q = Matrix(Q)  
    
    # Extract the values from Q
    q0 = Q[0]
    q1 = Q[1]
    q2 = Q[2]
    q3 = Q[3]

    # First row of the rotation matrix
    r00 = 2 * (q0 * q0 + q1 * q1) - 1
    r01 = 2 * (q1 * q2 - q0 * q3)
    r02 = 2 * (q1 * q3 + q0 * q2)

    # Second row of the rotation matrix
    r10 = 2 * (q1 * q2 + q0 * q3)
    r11 = 2 * (q0 * q0 + q2 * q2) - 1
    r12 = 2 * (q2 * q3 - q0 * q1)

    # Third row of the rotation matrix
    r20 = 2 * (q1 * q3 - q0 * q2)
    r21 = 2 * (q2 * q3 + q0 * q1)
    r22 = 2 * (q0 * q0 + q3 * q3) - 1

    # 3x3 rotation matrix
    rot_matrix = Matrix([[r00, r01, r02],
                         [r10, r11, r12],
                         [r20, r21, r22]])

    return rot_matrix</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="skidy.matrices.SE3AdjInvMatrix"><code class="name flex">
<span>def <span class="ident">SE3AdjInvMatrix</span></span>(<span>C: sympy.matrices.dense.MutableDenseMatrix) ‑> sympy.matrices.dense.MutableDenseMatrix</span>
</code></dt>
<dd>
<div class="desc"><p>Compute Inverse of (6x6) Adjoint matrix for SE(3)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>C</code></strong> :&ensp;<code>sympy.Matrix</code></dt>
<dd>SE(3) Pose.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy.Matrix</code></dt>
<dd>Inverse of (6x6) Adjoint matrix</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SE3AdjInvMatrix(C: MutableDenseMatrix) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Compute Inverse of (6x6) Adjoint matrix for SE(3)

    Args:
        C (sympy.Matrix): SE(3) Pose.

    Returns:
        sympy.Matrix: Inverse of (6x6) Adjoint matrix
    &#34;&#34;&#34;
    AdInv = Matrix([[C[0, 0], C[1, 0], C[2, 0], 0, 0, 0],
                    [C[0, 1], C[1, 1], C[2, 1], 0, 0, 0],
                    [C[0, 2], C[1, 2], C[2, 2], 0, 0, 0],
                    [-C[2, 3]*C[1, 0]+C[1, 3]*C[2, 0], 
                        C[2, 3]*C[0, 0]-C[0, 3]*C[2, 0],
                        (-C[1, 3])*C[0, 0]+C[0, 3]*C[1, 0], 
                        C[0, 0], C[1, 0], C[2, 0]],
                    [-C[2, 3]*C[1, 1]+C[1, 3]*C[2, 1], 
                        C[2, 3]*C[0, 1]-C[0, 3]*C[2, 1],
                        (-C[1, 3])*C[0, 1]+C[0, 3]*C[1, 1], 
                        C[0, 1], C[1, 1], C[2, 1]],
                    [-C[2, 3]*C[1, 2]+C[1, 3]*C[2, 2], 
                        C[2, 3]*C[0, 2]-C[0, 3]*C[2, 2],
                        (-C[1, 3])*C[0, 2]+C[0, 3]*C[1, 2], 
                        C[0, 2], C[1, 2], C[2, 2]]])
    return AdInv</code></pre>
</details>
</dd>
<dt id="skidy.matrices.SE3AdjMatrix"><code class="name flex">
<span>def <span class="ident">SE3AdjMatrix</span></span>(<span>C: sympy.matrices.dense.MutableDenseMatrix) ‑> sympy.matrices.dense.MutableDenseMatrix</span>
</code></dt>
<dd>
<div class="desc"><p>Compute (6x6) Adjoint matrix for SE(3)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>C</code></strong> :&ensp;<code>[type]</code></dt>
<dd>SE(3) Pose.</dd>
</dl>
<p>Returns:
sympy.Matrix: (6x6) Adjoint matrix</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SE3AdjMatrix(C: MutableDenseMatrix) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Compute (6x6) Adjoint matrix for SE(3)

    Args:
        C ([type]): SE(3) Pose.

    Returns:
    sympy.Matrix: (6x6) Adjoint matrix
    &#34;&#34;&#34;
    Ad = Matrix([[C[0, 0], C[0, 1], C[0, 2], 0, 0, 0],
                    [C[1, 0], C[1, 1], C[1, 2], 0, 0, 0],
                    [C[2, 0], C[2, 1], C[2, 2], 0, 0, 0],
                    [-C[2, 3]*C[1, 0]+C[1, 3]*C[2, 0], 
                    -C[2, 3]*C[1, 1]+C[1, 3]*C[2, 1],
                    -C[2, 3]*C[1, 2]+C[1, 3]*C[2, 2], 
                    C[0, 0], C[0, 1], C[0, 2]],
                    [C[2, 3]*C[0, 0]-C[0, 3]*C[2, 0],  
                    C[2, 3]*C[0, 1]-C[0, 3]*C[2, 1],
                    C[2, 3]*C[0, 2]-C[0, 3]*C[2, 2], 
                    C[1, 0], C[1, 1], C[1, 2]],
                    [-C[1, 3]*C[0, 0]+C[0, 3]*C[1, 0], 
                    -C[1, 3]*C[0, 1]+C[0, 3]*C[1, 1],
                    -C[1, 3]*C[0, 2]+C[0, 3]*C[1, 2], 
                    C[2, 0], C[2, 1], C[2, 2]]])
    return Ad</code></pre>
</details>
</dd>
<dt id="skidy.matrices.SE3Exp"><code class="name flex">
<span>def <span class="ident">SE3Exp</span></span>(<span>XX: sympy.matrices.dense.MutableDenseMatrix, t: Union[float, sympy.core.expr.Expr]) ‑> sympy.matrices.dense.MutableDenseMatrix</span>
</code></dt>
<dd>
<div class="desc"><p>compute exponential mapping for SE(3).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>XX</code></strong> :&ensp;<code>[type]</code></dt>
<dd>(6,1) spatial vector.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>sympy.Expr</code></dt>
<dd>rotation angle.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy.Matrix</code></dt>
<dd>(4,4) SE(3) Pose.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SE3Exp(XX: MutableDenseMatrix, t: Union[float, Expr]) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;compute exponential mapping for SE(3).

    Args:
        XX ([type]): (6,1) spatial vector.
        t (sympy.Expr): rotation angle.

    Returns:
        sympy.Matrix: (4,4) SE(3) Pose.
    &#34;&#34;&#34;
    X = XX.T
    xi = Matrix(X[0:3])
    eta = Matrix(X[3:6])
    xihat = Matrix([[0, -X[2], X[1]],
                    [X[2], 0, -X[0]],
                    [-X[1], X[0], 0]])
    R = Matrix(Identity(3)) + sin(t)*xihat + (1-cos(t))*(xihat*xihat)
    if xi == zeros(3, 1):
        p = eta * t
    else:
        p = (Matrix(Identity(3))-R)*(xihat*eta) + xi*(xi.T*eta)*t
    C = R.row_join(p).col_join(Matrix([0, 0, 0, 1]).T)
    return C</code></pre>
</details>
</dd>
<dt id="skidy.matrices.SE3Inv"><code class="name flex">
<span>def <span class="ident">SE3Inv</span></span>(<span>C: sympy.matrices.dense.MutableDenseMatrix) ‑> sympy.matrices.dense.MutableDenseMatrix</span>
</code></dt>
<dd>
<div class="desc"><p>Compute analytical inverse of exponential mapping for SE(3).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>C</code></strong> :&ensp;<code>sympy.Matrix</code></dt>
<dd>(4,4) SE(3) Pose.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy.Matrix</code></dt>
<dd>(4,4) Inverse of SE(3) Pose.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SE3Inv(C: MutableDenseMatrix) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Compute analytical inverse of exponential mapping for SE(3).

    Args:
        C (sympy.Matrix): (4,4) SE(3) Pose.

    Returns:
        sympy.Matrix: (4,4) Inverse of SE(3) Pose.
    &#34;&#34;&#34;
    CInv = Matrix([[C[0, 0], C[1, 0], C[2, 0], 
                    -C[0, 0]*C[0, 3]-C[1, 0]*C[1, 3]-C[2, 0]*C[2, 3]],
                    [C[0, 1], C[1, 1], C[2, 1], 
                    -C[0, 1]*C[0, 3]-C[1, 1]*C[1, 3]-C[2, 1]*C[2, 3]],
                    [C[0, 2], C[1, 2], C[2, 2], -C[0, 2] *
                        C[0, 3]-C[1, 2]*C[1, 3]-C[2, 2]*C[2, 3]],
                    [0, 0, 0, 1]])
    return CInv</code></pre>
</details>
</dd>
<dt id="skidy.matrices.SE3adMatrix"><code class="name flex">
<span>def <span class="ident">SE3adMatrix</span></span>(<span>X: sympy.matrices.dense.MutableDenseMatrix) ‑> sympy.matrices.dense.MutableDenseMatrix</span>
</code></dt>
<dd>
<div class="desc"><p>Compute (6x6) adjoint matrix for SE(3)
- also known as spatial cross product in the literature.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>sympy.Matrix</code></dt>
<dd>(6x1) spatial vector.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy.Matrix</code></dt>
<dd>(6x6) adjoint matrix</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SE3adMatrix(X: MutableDenseMatrix) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Compute (6x6) adjoint matrix for SE(3) 
        - also known as spatial cross product in the literature.

    Args:
        X (sympy.Matrix): (6x1) spatial vector.

    Returns:
        sympy.Matrix: (6x6) adjoint matrix
    &#34;&#34;&#34;
    ad = Matrix([[0, -X[2, 0], X[1, 0], 0, 0, 0],
                 [X[2, 0], 0, -X[0, 0], 0, 0, 0],
                 [-X[1, 0], X[0, 0], 0, 0, 0, 0],
                 [0, -X[5, 0], X[4, 0], 0, -X[2, 0], X[1, 0]],
                 [X[5, 0], 0, -X[3, 0], X[2, 0], 0, -X[0, 0]],
                 [-X[4, 0], X[3, 0], 0, -X[1, 0], X[0, 0], 0]])
    return ad</code></pre>
</details>
</dd>
<dt id="skidy.matrices.SO3Exp"><code class="name flex">
<span>def <span class="ident">SO3Exp</span></span>(<span>axis: sympy.matrices.dense.MutableDenseMatrix, angle: Union[float, sympy.core.expr.Expr]) ‑> sympy.matrices.dense.MutableDenseMatrix</span>
</code></dt>
<dd>
<div class="desc"><p>Compute exponential mapping for SO(3).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>axis</code></strong> :&ensp;<code>sympy.Matrix</code></dt>
<dd>Rotation axis</dd>
<dt><strong><code>angle</code></strong> :&ensp;<code>double</code></dt>
<dd>Rotation angle</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy.Matrix</code></dt>
<dd>Rotation matrix</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SO3Exp(axis: MutableDenseMatrix, angle: Union[float, Expr]) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Compute exponential mapping for SO(3).

    Args:
        axis (sympy.Matrix): Rotation axis
        angle (double): Rotation angle

    Returns:
        sympy.Matrix: Rotation matrix
    &#34;&#34;&#34;
    axis = Matrix(axis)
    xhat = Matrix([[0, -axis[2, 0], axis[1, 0]],
                    [axis[2, 0], 0, -axis[0, 0]],
                    [-axis[1, 0], axis[0, 0], 0]])
    R = Matrix(Identity(3)) + sin(angle) * xhat + (1-cos(angle))*(xhat*xhat)
    return R</code></pre>
</details>
</dd>
<dt id="skidy.matrices.generalized_vectors"><code class="name flex">
<span>def <span class="ident">generalized_vectors</span></span>(<span>DOF: int, startindex: int = 0, derivatives: bool = False) ‑> Tuple[sympy.matrices.dense.MutableDenseMatrix, sympy.matrices.dense.MutableDenseMatrix, sympy.matrices.dense.MutableDenseMatrix]</span>
</code></dt>
<dd>
<div class="desc"><p>Generate symbolic generalized vectors q, qd and q2d and optional
q3d and q4d.</p>
<p>The symbols are named as follows:</p>
<pre><code>q0, q1, ....., qi for joint positions.
dq0, dq1, ....., dqi for joint velocities.
ddq0, ddq1, ....., ddqi for joint accelerations.
dddq0, dddq1, ....., dddqi for joint jerks.
ddddq0, ddddq1, ....., ddddqi for joint jounces.
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>DOF</code></strong> :&ensp;<code>int</code></dt>
<dd>Degrees of freedom.</dd>
<dt><strong><code>startindex</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Index of first joint. Defaults to 0.</dd>
<dt><strong><code>derivatives</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>return jerks and jounces too.
Defaults to False. </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt>tuple(sympy.Matrix):</dt>
<dt><code>
Generalized vectors</code></dt>
<dd>(q,dq,d2q) if derivative == False
else: (q,dq,d2q,q3d,q4d)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generalized_vectors(
    DOF: int, startindex: int=0, derivatives: bool= False
    ) -&gt; Tuple[MutableDenseMatrix, MutableDenseMatrix, MutableDenseMatrix]:
    &#34;&#34;&#34;Generate symbolic generalized vectors q, qd and q2d and optional
    q3d and q4d.
    
    The symbols are named as follows:
        
        q0, q1, ....., qi for joint positions.
        dq0, dq1, ....., dqi for joint velocities.
        ddq0, ddq1, ....., ddqi for joint accelerations.
        dddq0, dddq1, ....., dddqi for joint jerks.
        ddddq0, ddddq1, ....., ddddqi for joint jounces.
        

    Args:
        DOF (int): Degrees of freedom.
        startindex (int, optional): Index of first joint. Defaults to 0.
        derivatives (bool, optional): return jerks and jounces too. 
            Defaults to False. 

    Returns:
        tuple(sympy.Matrix): 
            Generalized vectors: (q,dq,d2q) if derivative == False
            else: (q,dq,d2q,q3d,q4d) 
    &#34;&#34;&#34;
    if DOF &gt; 1:
        q = Matrix(symbols(&#34; &#34;.join(f&#34;q{i}&#34; for i in range(startindex,startindex+DOF))))
        qd = Matrix(symbols(&#34; &#34;.join(f&#34;dq{i}&#34; for i in range(startindex,startindex+DOF))))
        q2d = Matrix(symbols(&#34; &#34;.join(f&#34;ddq{i}&#34; for i in range(startindex,startindex+DOF))))
        q3d = Matrix(symbols(&#34; &#34;.join(f&#34;dddq{i}&#34; for i in range(startindex,startindex+DOF))))
        q4d = Matrix(symbols(&#34; &#34;.join(f&#34;ddddq{i}&#34; for i in range(startindex,startindex+DOF))))
    else:
        q = Matrix([symbols(&#34; &#34;.join(f&#34;q{i}&#34; for i in range(startindex,startindex+DOF)))])
        qd = Matrix([symbols(&#34; &#34;.join(f&#34;dq{i}&#34; for i in range(startindex,startindex+DOF)))])
        q2d = Matrix([symbols(&#34; &#34;.join(f&#34;ddq{i}&#34; for i in range(startindex,startindex+DOF)))])
        q3d = Matrix([symbols(&#34; &#34;.join(f&#34;dddq{i}&#34; for i in range(startindex,startindex+DOF)))])
        q4d = Matrix([symbols(&#34; &#34;.join(f&#34;ddddq{i}&#34; for i in range(startindex,startindex+DOF)))])
    if derivatives:
        return q, qd, q2d, q3d, q4d
    else: 
        return q, qd, q2d</code></pre>
</details>
</dd>
<dt id="skidy.matrices.inertia_matrix"><code class="name flex">
<span>def <span class="ident">inertia_matrix</span></span>(<span>Ixx: Union[float, sympy.core.expr.Expr] = 0, Ixy: Union[float, sympy.core.expr.Expr] = 0, Ixz: Union[float, sympy.core.expr.Expr] = 0, Iyy: Union[float, sympy.core.expr.Expr] = 0, Iyz: Union[float, sympy.core.expr.Expr] = 0, Izz: Union[float, sympy.core.expr.Expr] = 0) ‑> sympy.matrices.dense.MutableDenseMatrix</span>
</code></dt>
<dd>
<div class="desc"><p>Create 3 x 3 inertia matrix from independent inertia values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>Ixx</code></strong> :&ensp;<code>float</code> or <code>sympy.Expr</code></dt>
<dd>Inertia value I11. Defaults to 0.</dd>
<dt><strong><code>Ixy</code></strong> :&ensp;<code>float</code> or <code>sympy.Expr</code></dt>
<dd>Inertia value I12. Defaults to 0.</dd>
<dt><strong><code>Ixz</code></strong> :&ensp;<code>float</code> or <code>sympy.Expr</code></dt>
<dd>Inertia value I13. Defaults to 0.</dd>
<dt><strong><code>Iyy</code></strong> :&ensp;<code>float</code> or <code>sympy.Expr</code></dt>
<dd>Inertia value I22. Defaults to 0.</dd>
<dt><strong><code>Iyz</code></strong> :&ensp;<code>float</code> or <code>sympy.Expr</code></dt>
<dd>Inertia value I23. Defaults to 0.</dd>
<dt><strong><code>Izz</code></strong> :&ensp;<code>float</code> or <code>sympy.Expr</code></dt>
<dd>Inertia value I33. Defaults to 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy.Matrix</code></dt>
<dd>Inertia matrix (3,3)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inertia_matrix(Ixx: Union[float, Expr]=0, Ixy: Union[float, Expr]=0, 
                   Ixz: Union[float, Expr]=0, Iyy: Union[float, Expr]=0, 
                   Iyz: Union[float, Expr]=0, Izz: Union[float, Expr]=0) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Create 3 x 3 inertia matrix from independent inertia values.

    Args:
        Ixx (float or sympy.Expr): Inertia value I11. Defaults to 0.
        Ixy (float or sympy.Expr): Inertia value I12. Defaults to 0.
        Ixz (float or sympy.Expr): Inertia value I13. Defaults to 0.
        Iyy (float or sympy.Expr): Inertia value I22. Defaults to 0.
        Iyz (float or sympy.Expr): Inertia value I23. Defaults to 0.
        Izz (float or sympy.Expr): Inertia value I33. Defaults to 0.

    Returns:
        sympy.Matrix: Inertia matrix (3,3)
    &#34;&#34;&#34;
    I = Matrix([[Ixx, Ixy, Ixz],
                [Ixy, Iyy, Iyz],
                [Ixz, Iyz, Izz]])
    return I</code></pre>
</details>
</dd>
<dt id="skidy.matrices.joint_screw"><code class="name flex">
<span>def <span class="ident">joint_screw</span></span>(<span>axis: list, vec: list = [0, 0, 0], revolute: bool = True) ‑> sympy.matrices.dense.MutableDenseMatrix</span>
</code></dt>
<dd>
<div class="desc"><p>Get joint screw coordinates from joint axis and vector to joint.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>axis</code></strong> :&ensp;<code>list</code></dt>
<dd>Joint axis w.r.t. inertial frame.</dd>
<dt><strong><code>vec</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Vector to joint axis from inertial frame for revolute joint.
Defaults to [0,0,0].</dd>
<dt><strong><code>revolute</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Revolute (True) or prismatic (False) joint.
Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy.Matrix</code></dt>
<dd>joint screw coordinates.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def joint_screw(axis: list, vec: list=[0,0,0], revolute: bool=True) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Get joint screw coordinates from joint axis and vector to joint.

    Args:
        axis (list): 
            Joint axis w.r.t. inertial frame.
        vec (list, optional): 
            Vector to joint axis from inertial frame for revolute joint. 
            Defaults to [0,0,0].
        revolute (bool, optional): 
            Revolute (True) or prismatic (False) joint. 
            Defaults to True.

    Returns:
        sympy.Matrix: joint screw coordinates.
    &#34;&#34;&#34;
    e = Matrix(axis)
        
    if revolute:
        y = Matrix(vec)
        return Matrix([e, y.cross(e)])
    else:
        return Matrix([0,0,0,e])</code></pre>
</details>
</dd>
<dt id="skidy.matrices.mass_matrix_mixed_data"><code class="name flex">
<span>def <span class="ident">mass_matrix_mixed_data</span></span>(<span>m: Union[float, sympy.core.expr.Expr], Theta: sympy.matrices.dense.MutableDenseMatrix, COM: sympy.matrices.dense.MutableDenseMatrix) ‑> sympy.matrices.dense.MutableDenseMatrix</span>
</code></dt>
<dd>
<div class="desc"><p>Build mass-inertia matrix in SE(3) from mass, inertia and
center of mass information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>m</code></strong> :&ensp;<code>float</code></dt>
<dd>Mass.</dd>
<dt><strong><code>Theta</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Inertia (3,3).</dd>
<dt><strong><code>COM</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Center of mass (3,1).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy.Matrix</code></dt>
<dd>Mass-inertia matrix (6,6).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mass_matrix_mixed_data(m: Union[float, Expr], Theta: MutableDenseMatrix, 
                        COM: MutableDenseMatrix) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Build mass-inertia matrix in SE(3) from mass, inertia and 
    center of mass information.

    Args:
        m (float): Mass.
        Theta (array_like): Inertia (3,3).
        COM (array_like): Center of mass (3,1).

    Returns:
        sympy.Matrix: Mass-inertia matrix (6,6).
    &#34;&#34;&#34;
    M = Matrix([[Theta[0, 0], Theta[0, 1], Theta[0, 2], 0, 
                    (-COM[2])*m, COM[1]*m],
                [Theta[0, 1], Theta[1, 1], Theta[1, 2],
                    COM[2]*m, 0, (-COM[0]*m)],
                [Theta[0, 2], Theta[1, 2], Theta[2, 2],
                    (-COM[1])*m, COM[0]*m, 0],
                [0, COM[2]*m, (-COM[1]*m), m, 0, 0],
                [(-COM[2])*m, 0, COM[0]*m, 0, m, 0],
                [COM[1]*m, (-COM[0])*m, 0, 0, 0, m]])
    return M</code></pre>
</details>
</dd>
<dt id="skidy.matrices.matrix_to_rpy"><code class="name flex">
<span>def <span class="ident">matrix_to_rpy</span></span>(<span>R, solution=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a 3x3 transform matrix to roll-pitch-yaw coordinates.</p>
<p>The roll-pitchRyaw axes in a typical URDF are defined as a
rotation of <code>r</code> radians around the x-axis followed by a rotation of
<code>p</code> radians around the y-axis followed by a rotation of <code>y</code> radians
around the z-axis. These are the Z1-Y2-X3 Tait-Bryan angles. See
Wikipedia_ for more information.</p>
<p>.. _Wikipedia: <a href="https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix">https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix</a></p>
<p>There are typically two possible roll-pitch-yaw coordinates that could have
created a given rotation matrix. Specify <code>solution=1</code> for the first one
and <code>solution=2</code> for the second one.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>R</code></strong> :&ensp;<code>(3,3) float</code></dt>
<dd>A 3x3 homogenous rotation matrix.</dd>
<dt><strong><code>solution</code></strong> :&ensp;<code>int</code></dt>
<dd>Either 1 or 2, indicating which solution to return.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>coords</code></strong> :&ensp;<code>(3,) float</code></dt>
<dd>The roll-pitch-yaw coordinates in order (x-rot, y-rot, z-rot).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matrix_to_rpy(R, solution=1):
    &#34;&#34;&#34;Convert a 3x3 transform matrix to roll-pitch-yaw coordinates.

    The roll-pitchRyaw axes in a typical URDF are defined as a
    rotation of ``r`` radians around the x-axis followed by a rotation of
    ``p`` radians around the y-axis followed by a rotation of ``y`` radians
    around the z-axis. These are the Z1-Y2-X3 Tait-Bryan angles. See
    Wikipedia_ for more information.

    .. _Wikipedia: https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix

    There are typically two possible roll-pitch-yaw coordinates that could have
    created a given rotation matrix. Specify ``solution=1`` for the first one
    and ``solution=2`` for the second one.

    Parameters
    ----------
    R : (3,3) float
        A 3x3 homogenous rotation matrix.
    solution : int
        Either 1 or 2, indicating which solution to return.

    Returns
    -------
    coords : (3,) float
        The roll-pitch-yaw coordinates in order (x-rot, y-rot, z-rot).
    &#34;&#34;&#34;
    R = np.asanyarray(R, dtype=np.float64)
    r = 0.0
    p = 0.0
    y = 0.0

    if np.abs(R[2,0]) &gt;= 1.0 - 1e-12:
        y = 0.0
        if R[2,0] &lt; 0:
            p = np.pi / 2
            r = np.arctan2(R[0,1], R[0,2])
        else:
            p = -np.pi / 2
            r = np.arctan2(-R[0,1], -R[0,2])
    else:
        if solution == 1:
            p = -np.arcsin(R[2,0])
        else:
            p = np.pi + np.arcsin(R[2,0])
        r = np.arctan2(R[2,1] / np.cos(p), R[2,2] / np.cos(p))
        y = np.arctan2(R[1,0] / np.cos(p), R[0,0] / np.cos(p))

    return np.array([r, p, y], dtype=np.float64)</code></pre>
</details>
</dd>
<dt id="skidy.matrices.matrix_to_xyz_rpy"><code class="name flex">
<span>def <span class="ident">matrix_to_xyz_rpy</span></span>(<span>matrix)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a 4x4 homogenous matrix to xyzrpy coordinates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>matrix</code></strong> :&ensp;<code>(4,4) float</code></dt>
<dd>The homogenous transform matrix.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>xyz_rpy</code></strong> :&ensp;<code>(6,) float</code></dt>
<dd>The xyz_rpy vector.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matrix_to_xyz_rpy(matrix):
    &#34;&#34;&#34;Convert a 4x4 homogenous matrix to xyzrpy coordinates.

    Parameters
    ----------
    matrix : (4,4) float
        The homogenous transform matrix.

    Returns
    -------
    xyz_rpy : (6,) float
        The xyz_rpy vector.
    &#34;&#34;&#34;
    xyz = matrix[:3,3]
    rpy = matrix_to_rpy(matrix[:3,:3])
    return np.hstack((xyz, rpy))</code></pre>
</details>
</dd>
<dt id="skidy.matrices.quaternion_to_matrix"><code class="name flex">
<span>def <span class="ident">quaternion_to_matrix</span></span>(<span>Q: Union[list, sympy.matrices.dense.MutableDenseMatrix]) ‑> sympy.matrices.dense.MutableDenseMatrix</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a quaternion into SO(3) rotation matrix.</p>
<h2 id="args">Args</h2>
<p>Q (list | sympy.MutableDenseMatrix): Quaternion in order [w,x,y,z].</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy.Matrix</code></dt>
<dd>(3,3) Rotation matrix.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quaternion_to_matrix(Q: Union[list,MutableDenseMatrix]) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Convert a quaternion into SO(3) rotation matrix.

    Args:
        Q (list | sympy.MutableDenseMatrix): Quaternion in order [w,x,y,z].
        
    Returns:
        sympy.Matrix: (3,3) Rotation matrix.
    &#34;&#34;&#34;
    # ensure symbolic values
    Q = Matrix(Q)  
    
    # Extract the values from Q
    q0 = Q[0]
    q1 = Q[1]
    q2 = Q[2]
    q3 = Q[3]

    # First row of the rotation matrix
    r00 = 2 * (q0 * q0 + q1 * q1) - 1
    r01 = 2 * (q1 * q2 - q0 * q3)
    r02 = 2 * (q1 * q3 + q0 * q2)

    # Second row of the rotation matrix
    r10 = 2 * (q1 * q2 + q0 * q3)
    r11 = 2 * (q0 * q0 + q2 * q2) - 1
    r12 = 2 * (q2 * q3 - q0 * q1)

    # Third row of the rotation matrix
    r20 = 2 * (q1 * q3 - q0 * q2)
    r21 = 2 * (q2 * q3 + q0 * q1)
    r22 = 2 * (q0 * q0 + q3 * q3) - 1

    # 3x3 rotation matrix
    rot_matrix = Matrix([[r00, r01, r02],
                         [r10, r11, r12],
                         [r20, r21, r22]])

    return rot_matrix</code></pre>
</details>
</dd>
<dt id="skidy.matrices.rpy_to_matrix"><code class="name flex">
<span>def <span class="ident">rpy_to_matrix</span></span>(<span>coords: Union[list, sympy.matrices.dense.MutableDenseMatrix]) ‑> sympy.matrices.dense.MutableDenseMatrix</span>
</code></dt>
<dd>
<div class="desc"><p>Convert roll-pitch-yaw coordinates to a 3x3 homogenous rotation matrix.</p>
<p>Adapted from urdfpy </p>
<p>The roll-pitch-yaw axes in a typical URDF are defined as a
rotation of <code>r</code> radians around the x-axis followed by a rotation of
<code>p</code> radians around the y-axis followed by a rotation of <code>y</code> radians
around the z-axis. These are the Z1-Y2-X3 Tait-Bryan angles. See
Wikipedia_ for more information.</p>
<p>.. _Wikipedia: <a href="https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix">https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coords</code></strong> :&ensp;<code>(3,) float</code></dt>
<dd>The roll-pitch-yaw coordinates in order (x-rot, y-rot, z-rot).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>R</code></strong> :&ensp;<code>(3,3) float</code></dt>
<dd>The corresponding homogenous 3x3 rotation matrix.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rpy_to_matrix(coords: Union[list,MutableDenseMatrix]) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Convert roll-pitch-yaw coordinates to a 3x3 homogenous rotation matrix.

    Adapted from urdfpy 

    The roll-pitch-yaw axes in a typical URDF are defined as a
    rotation of ``r`` radians around the x-axis followed by a rotation of
    ``p`` radians around the y-axis followed by a rotation of ``y`` radians
    around the z-axis. These are the Z1-Y2-X3 Tait-Bryan angles. See
    Wikipedia_ for more information.

    .. _Wikipedia: https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix

    Parameters
    ----------
    coords : (3,) float
        The roll-pitch-yaw coordinates in order (x-rot, y-rot, z-rot).

    Returns
    -------
    R : (3,3) float
        The corresponding homogenous 3x3 rotation matrix.
    &#34;&#34;&#34;
    c3 = cos(coords[0])
    c2 = cos(coords[1])
    c1 = cos(coords[2])
    s3 = sin(coords[0])
    s2 = sin(coords[1])
    s1 = sin(coords[2])
    return Matrix([
        [c1 * c2, (c1 * s2 * s3) - (c3 * s1), (s1 * s3) + (c1 * c3 * s2)],
        [c2 * s1, (c1 * c3) + (s1 * s2 * s3), (c3 * s1 * s2) - (c1 * s3)],
        [-s2, c2 * s3, c2 * c3]
    ])</code></pre>
</details>
</dd>
<dt id="skidy.matrices.symbolic_inertia_matrix"><code class="name flex">
<span>def <span class="ident">symbolic_inertia_matrix</span></span>(<span>index: Union[int, str] = '', pointmass: bool = False) ‑> sympy.matrices.dense.MutableDenseMatrix</span>
</code></dt>
<dd>
<div class="desc"><p>Create 3 x 3 symbolic inertia matrix with auto generated variable names.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>postfix for variable name. Defaults to "".</dd>
<dt><strong><code>pointmass</code></strong> :&ensp;<code>bool</code></dt>
<dd>Inertial matrix = I * Identity. Default to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy.Matrix</code></dt>
<dd>Inertia matrix (3,3)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def symbolic_inertia_matrix(
    index: Union[int, str]=&#34;&#34;, pointmass: bool=False) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Create 3 x 3 symbolic inertia matrix with auto generated variable names.

    Args:
        index (int or str): 
            postfix for variable name. Defaults to &#34;&#34;.
        pointmass (bool): 
            Inertial matrix = I * Identity. Default to False.
    
    Returns:
        sympy.Matrix: Inertia matrix (3,3)
    &#34;&#34;&#34;
    if pointmass:
        I = symbols(f&#34;I{index}&#34;, real=1, constant=1)
        return I*Identity(3)
    Ixx, Iyy, Izz, Ixy, Ixz, Iyz = symbols(
        f&#34;Ixx{index} Iyy{index} Izz{index} Ixy{index} Ixz{index} Iyz{index}&#34;)
    
    I = Matrix([[Ixx, Ixy, Ixz],
                [Ixy, Iyy, Iyz],
                [Ixz, Iyz, Izz]])
    return I</code></pre>
</details>
</dd>
<dt id="skidy.matrices.transformation_matrix"><code class="name flex">
<span>def <span class="ident">transformation_matrix</span></span>(<span>r: sympy.matrices.dense.MutableDenseMatrix = Matrix([
[1, 0, 0],
[0, 1, 0],
[0, 0, 1]]), t: sympy.matrices.dense.MutableDenseMatrix = Matrix([
[0],
[0],
[0]])) ‑> sympy.matrices.dense.MutableDenseMatrix</span>
</code></dt>
<dd>
<div class="desc"><p>Build transformation matrix from rotation and translation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>r</code></strong> :&ensp;<code>sympy.Matrix</code></dt>
<dd>SO(3) Rotation matrix (3,3).
Defaults to sympy.Matrix(Identity(3))</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>sympy.Matrix</code></dt>
<dd>Translation vector (3,1). Defaults to sympy.zeros(3,1)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy.Matrix</code></dt>
<dd>Transformation matrix (4,4)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transformation_matrix(r: MutableDenseMatrix=Matrix(Identity(3)), 
                         t: MutableDenseMatrix=zeros(3, 1)) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Build transformation matrix from rotation and translation.

    Args:
        r (sympy.Matrix): 
            SO(3) Rotation matrix (3,3). 
            Defaults to sympy.Matrix(Identity(3))
        t (sympy.Matrix): 
            Translation vector (3,1). Defaults to sympy.zeros(3,1)

    Returns:
        sympy.Matrix: Transformation matrix (4,4)
    &#34;&#34;&#34;
    if type(t) is list:
        t = Matrix(t)
    T = r.row_join(t).col_join(Matrix([[0, 0, 0, 1]]))
    return T</code></pre>
</details>
</dd>
<dt id="skidy.matrices.xyz_rpy_to_matrix"><code class="name flex">
<span>def <span class="ident">xyz_rpy_to_matrix</span></span>(<span>xyz_rpy: Union[list, sympy.matrices.dense.MutableDenseMatrix]) ‑> sympy.matrices.dense.MutableDenseMatrix</span>
</code></dt>
<dd>
<div class="desc"><p>Convert xyz_rpy coordinates to a 4x4 homogenous matrix.</p>
<p>Adapted from urdfpy</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xyz_rpy</code></strong> :&ensp;<code>(6,) float</code></dt>
<dd>The xyz_rpy vector.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>matrix</code></strong> :&ensp;<code>(4,4) float</code></dt>
<dd>The homogenous transform matrix.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xyz_rpy_to_matrix(xyz_rpy: Union[list,MutableDenseMatrix]) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Convert xyz_rpy coordinates to a 4x4 homogenous matrix.

    Adapted from urdfpy

    Parameters
    ----------
    xyz_rpy : (6,) float
        The xyz_rpy vector.

    Returns
    -------
    matrix : (4,4) float
        The homogenous transform matrix.
    &#34;&#34;&#34;
    matrix = Matrix(Identity(4))
    matrix[:3, 3] = xyz_rpy[:3]
    matrix[:3, :3] = rpy_to_matrix(xyz_rpy[3:])
    return matrix</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="skidy" href="index.html">skidy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="skidy.matrices.SE3AdjInvMatrix" href="#skidy.matrices.SE3AdjInvMatrix">SE3AdjInvMatrix</a></code></li>
<li><code><a title="skidy.matrices.SE3AdjMatrix" href="#skidy.matrices.SE3AdjMatrix">SE3AdjMatrix</a></code></li>
<li><code><a title="skidy.matrices.SE3Exp" href="#skidy.matrices.SE3Exp">SE3Exp</a></code></li>
<li><code><a title="skidy.matrices.SE3Inv" href="#skidy.matrices.SE3Inv">SE3Inv</a></code></li>
<li><code><a title="skidy.matrices.SE3adMatrix" href="#skidy.matrices.SE3adMatrix">SE3adMatrix</a></code></li>
<li><code><a title="skidy.matrices.SO3Exp" href="#skidy.matrices.SO3Exp">SO3Exp</a></code></li>
<li><code><a title="skidy.matrices.generalized_vectors" href="#skidy.matrices.generalized_vectors">generalized_vectors</a></code></li>
<li><code><a title="skidy.matrices.inertia_matrix" href="#skidy.matrices.inertia_matrix">inertia_matrix</a></code></li>
<li><code><a title="skidy.matrices.joint_screw" href="#skidy.matrices.joint_screw">joint_screw</a></code></li>
<li><code><a title="skidy.matrices.mass_matrix_mixed_data" href="#skidy.matrices.mass_matrix_mixed_data">mass_matrix_mixed_data</a></code></li>
<li><code><a title="skidy.matrices.matrix_to_rpy" href="#skidy.matrices.matrix_to_rpy">matrix_to_rpy</a></code></li>
<li><code><a title="skidy.matrices.matrix_to_xyz_rpy" href="#skidy.matrices.matrix_to_xyz_rpy">matrix_to_xyz_rpy</a></code></li>
<li><code><a title="skidy.matrices.quaternion_to_matrix" href="#skidy.matrices.quaternion_to_matrix">quaternion_to_matrix</a></code></li>
<li><code><a title="skidy.matrices.rpy_to_matrix" href="#skidy.matrices.rpy_to_matrix">rpy_to_matrix</a></code></li>
<li><code><a title="skidy.matrices.symbolic_inertia_matrix" href="#skidy.matrices.symbolic_inertia_matrix">symbolic_inertia_matrix</a></code></li>
<li><code><a title="skidy.matrices.transformation_matrix" href="#skidy.matrices.transformation_matrix">transformation_matrix</a></code></li>
<li><code><a title="skidy.matrices.xyz_rpy_to_matrix" href="#skidy.matrices.xyz_rpy_to_matrix">xyz_rpy_to_matrix</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>