<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>skidy API documentation</title>
<meta name="description" content="skidy - symbolic kinematics and dynamics generator â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>skidy</code></h1>
</header>
<section id="section-intro">
<h1 id="skidy-symbolic-kinematics-and-dynamics-generator">skidy - symbolic kinematics and dynamics generator</h1>
<ul>
<li><a href="#1-installation">1. Installation</a></li>
<li><a href="#install-package-from-source">Install package from source</a></li>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#2-usage">2. Usage</a></li>
<li><a href="#21-yaml-and-json">2.1. YAML and JSON</a><ul>
<li><a href="#211-create-robot-model-as-yaml-file">2.1.1. Create robot model as YAML file</a></li>
<li><a href="#212-code-generation-using-yaml">2.1.2. Code generation using YAML</a></li>
</ul>
</li>
<li><a href="#22-python">2.2. Python</a></li>
<li><a href="#23-urdf">2.3. URDF</a></li>
<li><a href="#3-unit-testing">3. Unit testing</a></li>
<li><a href="#4-benchmarking">4. Benchmarking</a></li>
<li><a href="#5-license">5. License</a></li>
</ul>
<p>Symbolic kinematics and dynamics model generation using Equations of Motion in closed form.</p>
<h2 id="1-installation">1. Installation</h2>
<!-- To install this package use:
<pre><code class="bash">python3 -m pip install skidy
``` --&gt;

### Install package from source

To install the package from source go to the root folder of the package:

```bash
cd /path/to/project
</code></pre>
then use:
<pre><code class="bash">python3 -m pip install -e .
</code></pre>
to install the package in editable mode or:
<pre><code class="bash">python3 -m pip install .
</code></pre>
to install the package uneditable.
**Note:** The <code>.</code> is part of the command.
### Dependencies
The project has the following dependencies:
- sympy (Version >= 1.8)
```bash
python3 -m pip install --upgrade sympy
```
- numpy
```bash
python3 -m pip install numpy
```
- urdf_parser_py
```bash
python3 -m pip install urdf_parser_py
```
- regex
```bash
python3 -m pip install regex
```
- PyYAML
```bash
python3 -m pip install PyYAML
```
- pylatex
```bash
python3 -m pip install pylatex
```
For unit testing the following packages are additionally recommended:
- oct2py
```bash
python3 -m pip install oct2py
```
This requires a working octave installation on your system:
Install on Ubuntu with:
```bash
sudo apt install octave
```
- cython
```bash
python3 -m pip install cython
```
## 2. Usage
There are four ways to load your robot into the library:
1. using a *YAML* file
2. using a *JSON* file
3. directly in *python*
4. using *URDF*
For defining a robot with one of the first three options (YAML, JSON, python) the following parameters are required:
- 6D joint screw coordinates for any joint
- 4x4 body reference coordinates for any link
- 4x4 end-effector configuration w.r.t. last link body fixed frame in the chain
For generating the inverse dynamics the following two parameters are required:
- 3D gravity vector
- 6x6 Mass-inertia matrix for any link
Tree-like robot structures require the following graph description parameters additionally:
- parent link for any joint
- support graph for any joint
- (child links for any joint) -> currently not used
Using URDF the following three parameters are required:
- path to URDF file
- 4x4 end-effector configuration w.r.t. last link body fixed frame in the chain
- 3D gravity vector
### 2.1. YAML and JSON
**NOTE:** As *JSON* and *YAML* files represent the same data structure this documentation covers only *YAML* files. Use *JSON* accordingly and just replace <code>yaml</code> with <code>json</code> in all commands.
#### 2.1.1. Create robot model as YAML file
There is a function to generate a **template YAML file** in which it is easy to modify the parameters for your robot.
To generate your robot template use
<pre><code class="bash">python3 -m skidy --template [options] new_filename.yaml
</code></pre>
or the python function <code>skidy.generate\_template\_yaml(path, structure)</code>.
For [options] the option `--structure` is highly recommended. There you can define which joint types to use in the template. E.g. use `--structure 'rrp'` for a robot which has two revolute joints followed by one prismatic joint.
The command `python3 -m skidy --template --structure 'rp' my_robot_template.yaml` creates the following output file:
<pre><code class="yaml">---
parent:
  - 0
  - 1

child:
  - [1]
  - []

support:
  - [1]
  - [1,2]

gravity: [0,0,g]

representation: spatial

joint_screw_coord:
  - type: revolute
    axis: [0,0,1]
    vec: [0,0,0]

  - type: prismatic
    axis: [0,0,1]

body_ref_config:
  - rotation:
      axis: [0,0,1]
      angle: 0
    translation: [0,0,0]

  - rotation:
      axis: [0,0,1]
      angle: 0
    translation: [0,0,0]

ee:
  rotation:
    axis: [0,0,1]
    angle: 0
  translation: [0,0,0]

mass_inertia:
  - mass: m1
    inertia:
      Ixx: Ixx1
      Ixy: Ixy1
      Ixz: Ixz1
      Iyy: Iyy1
      Iyz: Iyz1
      Izz: Izz1
    com: [0,0,0]

  - mass: m2
    inertia:
      Ixx: Ixx2
      Ixy: Ixy2
      Ixz: Ixz2
      Iyy: Iyy2
      Iyz: Iyz2
      Izz: Izz2
    com: [0,0,0]

q: [q1,q2]
qd: [dq1,dq2]
q2d: [ddq1,ddq2]
WEE: [0,0,0,0,0,0]

</code></pre>
The code explained:
<pre><code class="yaml">parent:
  - 0
  - 1

child:
  - [1]
  - []

support:
  - [1]
  - [1,2]
</code></pre>
The parameters are generated to represent a serial robot by default. Modify parameters for tree-like structures. For serial robots these parameters are optional.
- **parent**: list of parent links for any joint. Use 0 for World.
- **child**: list of lists with child links for any link. Use empty list if no child is present.
- **support**: list of lists with all support links beginning with first link including current link for any link.
---
<pre><code class="yaml">gravity: [0,0,g]
</code></pre>
Gravity vector.
**Note:** you can always use symbolic variables instead of numeric values.
---
<pre><code class="yaml">representation: spatial
</code></pre>
Define whether the representation of the joint screw coordinates and the body reference configuration is w.r.t. world frame (`representation: spatial`) or in body fixed coordinates (`representation: body_fixed`)
---
<pre><code class="yaml">joint_screw_coord:
  - type: revolute
    axis: [0,0,1]
    vec: [0,0,0]

  - type: prismatic
    axis: [0,0,1]
</code></pre>
The joint screw coordinates can be defined either using the syntax which is used above, where <code>type</code> is the joint type (<code>revolute</code> or <code>prismatic</code>), <code>axis</code> is the joint axis and <code>vec</code> is a vector from the origin to the joint axis.
Alternatively, you can directly use the 6D joint screw vectors instead:
<pre><code class="yaml">joint_screw_coord:
  - [0,0,1,0,0,0]
  - [0,0,0,0,0,1]
</code></pre>
---
<pre><code class="yaml">body_ref_config:
  - rotation:
      axis: [0,0,1]
      angle: 0
    translation: [0,0,0]

  - rotation:
      axis: [0,0,1]
      angle: 0
    translation: [0,0,0]
</code></pre>
The body reference configuration is a list of SE(3) transformation matrices. To define them you have several options:
1. Write down the whole matrix e.g.:
```yaml
body_ref_config:
- [[cos(pi),-sin(pi),0, 0],
[sin(pi), cos(pi),0, 0],
[
0,
0,1,L1],
[
0,
0,0, 1]]
```
2. Write rotation and translation separately:
```yaml
body_ref_config:
- rotation:
[[1,0,0],
[0,1,0],
[0,0,1]]
translation: [0,0,L1]
```
3. Use axis angle representation for rotation:
-> See code above.
4. For zero rotations or translations it is possible to omit the option:
```yaml
body_ref_config:
- translation: [0,0,L1]
```
5. Use xyz_rpy coordinates to define Pose:
```yaml
body_ref_config:
- xyzrpy: [0, 0, L1, 0, pi/2, 0]
```
6. Use roll pitch yaw (rpy) euler angles to define rotation:
```yaml
body_ref_config:
- rotation:
rpy: [0, pi/2, 0]
translation: [0,0,L1]
```
7. Use quaternion [w,x,y,z] to define rotation:
```yaml
body_ref_config:
- rotation:
Q: [1, 0, 0, 0]
translation: [0,0,L1]
```
---
<pre><code class="yaml">ee:
  rotation:
    axis: [0,0,1]
    angle: 0
  translation: [0,0,0]
</code></pre>
End-effector representation w.r.t. last link body frame in the chain as SE(3) transformation matrix. Here you have the same syntax options as for the body reference configuration. **Note** there is no trailing `-` as there is only one pose to be defined.
---
<pre><code class="yaml">mass_inertia:
  - mass: m1
    inertia:
      Ixx: Ixx1
      Ixy: Ixy1
      Ixz: Ixz1
      Iyy: Iyy1
      Iyz: Iyz1
      Izz: Izz1
    com: [0,0,0]

  - mass: m2
    inertia:
      Ixx: Ixx2
      Ixy: Ixy2
      Ixz: Ixz2
      Iyy: Iyy2
      Iyz: Iyz2
      Izz: Izz2
    com: [0,0,0]
</code></pre>
Mass-inertia matrices of all links. For the definition you have the following syntax options:
1. Write down whole matrix:
```yaml
mass_inertia:
- [[
Ixx1,
Ixy1,
Ixz1,
0, -cz1*m1,
cy1*m1],
[
Ixy1,
Iyy1,
Iyz1,
cz1*m1,
0, -cx1*m1],
[
Ixz1,
Iyz1,
Izz1, -cy1*m1,
cx1*m1,
0],
[
0,
cz1*m1, -cy1*m1,
m1,
0,
0],
[-cz1*m1,
0,
cx1*m1,
0,
m1,
0],
[ cy1*m1, -cx1*m1,
0,
0,
0,
m1]]
```
2. Define mass, inertia and center of mass (com) separately:
```yaml
mass_inertia:
- mass: m1
inertia:
[[Ixx1,Ixy1,Ixz1],
[Ixy1,Iyy1,Iyz1],
[Ixz1,Iyz1,Izz1]]
com: [cx1,cy1,cz1]
```
3. Only define the 6 independent inertia parameters:
```yaml
mass_inertia:
- mass: m1
inertia: [Ixx1,Ixy1,Ixz1,Iyy1,Iyz1,Izz1]
com: [cx1,cy1,cz1]
```
4. Define only necessary inertia parameters:
```yaml
mass_inertia:
- mass: m1
inertia:
Ixx: Ixx1
Iyy: Iyy1
Izz: Izz1
com: [cx1,cy1,cz1]
```
Supports the parameters <code>Ixx</code>, <code>Ixy</code>, <code>Ixz</code>, <code>Iyy</code>, <code>Iyz</code> and <code>Izz</code>. All parameters default to 0.
5. Define only one value which is internally multiplied by an identity matrix:
```yaml
mass_inertia:
- mass: m1
inertia: m1*L1**2
com: [cx1,cy1,cz1]
```
6. Automatically generate symbols in inertia matrix:
```yaml
mass_inertia:
- mass: m1
inertia:
index: 1
pointmass: False
com: [0,0,0]
```
Here the parameter index is appended to the names <code>Ixx</code> etc. and generates an inertia matrix following the naming scheme used in the examples above.
With the parameter `pointmass: True` the resulting inertia matrix looks like this:
```yaml
[[I1, 0, 0],
[ 0,I1, 0],
[ 0, 0,I1]]
```
---
<pre><code class="yaml">q: [q1,q2]
qd: [dq1,dq2]
q2d: [ddq1,ddq2]
WEE: [0,0,0,0,0,0]
</code></pre>
Define symbolic generalized vectors (q, qd, q2d) and the time varying wrench on the end-effector link (WEE). Where the generalized vectors are list of length n and the wrench is a list of length 6 with symbolic values e.g.: <code>\[Mx,My,Mz,Fx,Fy,Fz]</code>.
Add jerk and jounce here, to activate the calculation of the 1st and 2nd order derivatives of the Equation of Motion. Optionally, you can define the time derivatives of the external wrench <code>WDEE</code> and <code>W2DEE</code> here too. E.g.:
<pre><code class="yaml">q: [q1,q2]
qd: [dq1,dq2]
q2d: [ddq1,ddq2]
q3d: [dddq1,dddq2]
q4d: [ddddq1,ddddq2]
WEE: [Mx,My,Mz,Fx,Fy,Fz]
WDEE: [dMx,dMy,dMz,dFx,dFy,dFz]
W2DEE: [ddMx,ddMy,ddMz,ddFx,ddFy,ddFz]
</code></pre>
#### 2.1.2. Code generation using YAML
To start the code generation process use:
<pre><code class="bash">python3 -m skidy [options] path/to/robot.yaml
</code></pre>
In the options you have to specify what kind of code (python `-p`, Matlab `-m`, C `-C`, latex `-l`) you'd like to generate and whether the equations should be simplified `-s`.
Use
<pre><code class="bash">python3 -m skidy -h
</code></pre>
to get a description of all available options.
### 2.2. Python
As for YAML and JSON there is a function to auto-generate a **python template file** which makes it easier to define your own robot.
To generate your robot template use
<pre><code class="bash">python3 -m skidy --template [options] new_filename.py
</code></pre>
or the python function <code>skidy.generate\_template\_python(path, structure)</code>.
For [options] the option `--structure` is highly recommended. There you can define which joint types to use in the template. E.g. use `--structure 'rrp'` for a robot which has two revolute joints followed by one prismatic joint.
The command `python3 -m skidy --template --structure 'rp' my_robot_template.py` creates the following output file:
<pre><code class="python">from skidy import (SymbolicKinDyn,
                   transformation_matrix,
                   mass_matrix_mixed_data,
                   joint_screw,
                   SO3Exp,
                   inertia_matrix,
                   generalized_vectors)
from skidy.symbols import g, pi
import sympy

# Define symbols:
m1, m2 = sympy.symbols('m1 m2', real=True, const=True)
Ixx1, Ixx2 = sympy.symbols('Ixx1 Ixx2', real=True, const=True)
Ixy1, Ixy2 = sympy.symbols('Ixy1 Ixy2', real=True, const=True)
Ixz1, Ixz2 = sympy.symbols('Ixz1 Ixz2', real=True, const=True)
Iyy1, Iyy2 = sympy.symbols('Iyy1 Iyy2', real=True, const=True)
Iyz1, Iyz2 = sympy.symbols('Iyz1 Iyz2', real=True, const=True)
Izz1, Izz2 = sympy.symbols('Izz1 Izz2', real=True, const=True)

# Define connectivity graph
parent = [0,
          1]

child = [[1],
         []]

support = [[1],
           [1,2]]

# gravity vector
gravity = sympy.Matrix([0,0,g])

# representation of joint screw coordinates and body reference configurations
representation = 'spatial' # alternative: 'body_fixed'

# joint screw coordinates (6x1 sympy.Matrix per joint)
joint_screw_coord = []
joint_screw_coord.append(joint_screw(axis=[0,0,1], vec=[0,0,0], revolute=True))
joint_screw_coord.append(joint_screw(axis=[0,0,1], revolute=False))

# body reference configurations (4x4 SE3 Pose (sympy.Matrix) per link)
body_ref_config = []
body_ref_config.append(transformation_matrix(r=SO3Exp(axis=[0,0,1],angle=0),t=[0,0,0]))
body_ref_config.append(transformation_matrix(r=SO3Exp(axis=[0,0,1],angle=0),t=[0,0,0]))

# end-effector configuration w.r.t. last link body fixed frame in the chain (4x4 SE3 Pose (sympy.Matrix))
ee = transformation_matrix(r=SO3Exp(axis=[0,0,1],angle=0),t=[0,0,0])

# mass_inertia parameters (6x6 sympy.Matrix per link)
Mb = []
Mb.append(mass_matrix_mixed_data(m1, inertia_matrix(Ixx1,Ixy1,Ixz1,Iyy1,Iyz1,Izz1), sympy.Matrix([0,0,0])))
Mb.append(mass_matrix_mixed_data(m2, inertia_matrix(Ixx2,Ixy2,Ixz2,Iyy2,Iyz2,Izz2), sympy.Matrix([0,0,0])))

q, qd, q2d = generalized_vectors(len(body_ref_config), startindex=1)
WEE = sympy.zeros(6,1)

skd = SymbolicKinDyn(gravity_vector=gravity,
                     ee=ee,
                     body_ref_config=body_ref_config,
                     joint_screw_coord=joint_screw_coord,
                     config_representation=representation,
                     Mb=Mb,
                     parent=parent,
                     child=child,
                     support=support,
                     )

# run Calculations
skd.closed_form_kinematics_body_fixed(q, qd, q2d, simplify=True)
skd.closed_form_inv_dyn_body_fixed(q, qd, q2d, WEE=WEE, simplify=True)

# Generate Code
skd.generate_code(python=True, C=False, Matlab=False, latex=False,
                 folder=&quot;./generated_code&quot;, use_global_vars=True,
                 name=&quot;plant&quot;, project=&quot;Project&quot;)
</code></pre>
The code explained:
<pre><code class="python">from skidy import (SymbolicKinDyn,
                   transformation_matrix,
                   mass_matrix_mixed_data,
                   joint_screw,
                   SO3Exp,
                   inertia_matrix,
                   generalized_vectors)
</code></pre>
The class <code>SymbolicKinDyn</code> is the main object for calculating the kinematic and dynamic equations of your robot and generate the code.
Additionally, we import several helper functions for defining the matrices which are useful for the robot definition:
- <code>transformation\_matrix</code>: Create SE(3) transformation matrix from SO(3) rotation and translation vector.
- <code>mass\_matrix\_mixed\_data</code>: Create 6x6 mass-inertia matrix from mass, 3x3 inertia matrix and 3x1 center of mass vector.
- <code>joint\_screw</code>: create 6x1 joint screw vector from joint axis and vector from origin to joint axis.
- <code>SO3Exp</code>: Exponential mapping of SO(3) to generate rotation matrix from rotation angle and rotation axis.
- <code>inertia\_matrix</code>: generate 3x3 inertia matrix from 6 independent parameters (Ixx, Ixy, ...).
- <code>generalized\_vectors</code>: generate symbolic generalized vectors q, qd and q2d of predefined length n.
<pre><code class="python">from skidy.symbols import g, pi
</code></pre>
The package <code><a title="skidy.symbols" href="symbols.html">skidy.symbols</a></code> includes the most common used symbolic variables, which can be used for defining your robot.
<pre><code class="python">import sympy
</code></pre>
The whole library used sympy objects for all symbolic equations etc. Hence, we need <code>sympy</code> to create additional symbolic variables and matrices later.
---
<pre><code class="python"># Define symbols:
m1, m2 = sympy.symbols('m1 m2', real=True, const=True)
Ixx1, Ixx2 = sympy.symbols('Ixx1 Ixx2', real=True, const=True)
Ixy1, Ixy2 = sympy.symbols('Ixy1 Ixy2', real=True, const=True)
Ixz1, Ixz2 = sympy.symbols('Ixz1 Ixz2', real=True, const=True)
Iyy1, Iyy2 = sympy.symbols('Iyy1 Iyy2', real=True, const=True)
Iyz1, Iyz2 = sympy.symbols('Iyz1 Iyz2', real=True, const=True)
Izz1, Izz2 = sympy.symbols('Izz1 Izz2', real=True, const=True)
</code></pre>
Create symbolic variables which can be used in the equations for the robot definition later. The most common symbols are also already present in the <code><a title="skidy.symbols" href="symbols.html">skidy.symbols</a></code> package and may be imported from there instead.
---
<pre><code class="python"># Define connectivity graph
parent = [0,
          1]

child = [[1],
         []]

support = [[1],
           [1,2]]
</code></pre>
Connectivity graph of the robot. The parameters are generated to represent a serial robot by default. Modify parameters for tree-like structures. For serial robots these parameters are optional.
- **parent**: list of parent links for any joint. Use 0 for World.
- **child**: list of lists with child links for any link. Use empty list if no child is present.
- **support**: list of lists with all support links beginning with first link including current link for any link.
---
<pre><code class="python"># gravity vector
gravity = sympy.Matrix([0,0,g])
</code></pre>
Gravity vector as <code>sympy.Matrix</code>. Note that we can use symbolic variables here.
---
<pre><code class="python"># representation of joint screw coordinates and body reference configurations
representation = 'spatial' # alternative: 'body_fixed'
</code></pre>
Define whether the representation of the joint screw coordinates and the body reference configuration is w.r.t. world frame (`representation = 'spatial'`) or in body fixed coordinates (`representation =
'body_fixed'`).
---
<pre><code class="python"># joint screw coordinates (6x1 sympy.Matrix per joint)
joint_screw_coord = []
joint_screw_coord.append(joint_screw(axis=[0,0,1], vec=[0,0,0], revolute=True))
joint_screw_coord.append(joint_screw(axis=[0,0,1], revolute=False))
</code></pre>
The joint screw coordinates can be defined either using the syntax which is used above, where <code>axis</code> is the joint axis, <code>vec</code> is a vector from the origin to the joint axis and <code>revolute</code> has to be <code>True</code> for revolute joints and <code>False</code> for prismatic joints. Note that prismatic joints don't need the parameter <code>vec</code>.
Alternatively, you can directly use the 6D joint screw vectors instead:
<pre><code class="python">joint_screw_coord = []
joint_screw_coord.append(sympy.Matrix([0,0,1,0,0,0]))
joint_screw_coord.append(sympy.Matrix([0,0,0,0,0,1]))
</code></pre>
---
<pre><code class="python"># body reference configurations (4x4 SE3 Pose (sympy.Matrix) per link)
body_ref_config = []
body_ref_config.append(transformation_matrix(r=SO3Exp(axis=[0,0,1],angle=0),t=[0,0,0]))
body_ref_config.append(transformation_matrix(r=SO3Exp(axis=[0,0,1],angle=0),t=[0,0,0]))
</code></pre>
The body reference configuration is a list of SE(3) transformation matrices. To define them you have several options:
1. Write down the whole matrix e.g.:
```python
body_ref_config.append(
sympy.Matrix([[sympy.cos(pi/2),-sympy.sin(pi/2),0, 0],
[sympy.sin(pi/2), sympy.cos(pi/2),0, 0],
[
0,
0,1,L1],
[
0,
0,0, 1]])
)
```
Note: this example assumes you have defined the symbolic variable <code>L1</code> before.
2. Write rotation and translation separately:
```python
body_ref_config.append(
transformation_matrix(
r=sympy.Matrix([[1,0,0],
[0,1,0],
[0,0,1]]),
t=sympy.Matrix([0,0,L1])
)
)
```
3. Use axis angle representation for rotation:
-> See code above.
4. For zero rotations or translations it is possible to omit the option:
```python
body_ref_config.append(transformation_matrix(t=[0,0,0]))
```
5. Use xyz_rpy coordinates to define Pose:
```python
body_ref_config.append(xyz_rpy_to_matrix([0, 0, L1, 0, pi/2, 0]))
```
Note that you have to import the function using <code>from <a title="skidy" href="#skidy">skidy</a> import xyz\_rpy\_to\_matrix</code>.
6. Use roll pitch yaw (rpy) euler angles to define rotation:
```python
body_ref_config.append(
transformation_matrix(
r=rpy_to_matrix([0, pi/2, 0]),
t=sympy.Matrix([0,0,L1])
)
)
```
Note that you have to import the function using <code>from <a title="skidy" href="#skidy">skidy</a> import rpy\_to\_matrix</code>.
7. Use quaternion [w,x,y,z] to define rotation:
```python
body_ref_config.append(
transformation_matrix(
r=quaternion_to_matrix([1,0,0,0]),
t=sympy.Matrix([0,0,L1])
)
)
```
Note that you have to import the function using <code>from <a title="skidy" href="#skidy">skidy</a> import quaternion\_to\_matrix</code>.
---
<pre><code class="python"># end-effector configuration w.r.t. last link body fixed frame in the chain (4x4 SE3 Pose (sympy.Matrix))
ee = transformation_matrix(r=SO3Exp(axis=[0,0,1],angle=0),t=[0,0,0])
</code></pre>
End-effector representation w.r.t. last link body frame in the chain as SE(3) transformation matrix. Here you have the same syntax options as for the body reference configuration.
---
<pre><code class="python"># mass_inertia parameters (6x6 sympy.Matrix per link)
Mb = []
Mb.append(mass_matrix_mixed_data(m1, inertia_matrix(Ixx1,Ixy1,Ixz1,Iyy1,Iyz1,Izz1), sympy.Matrix([0,0,0])))
Mb.append(mass_matrix_mixed_data(m2, inertia_matrix(Ixx2,Ixy2,Ixz2,Iyy2,Iyz2,Izz2), sympy.Matrix([0,0,0])))
</code></pre>
Mass-inertia matrices of all links. For the definition you have the following syntax options:
1. Write down whole matrix:
```python
Mb.append(
sympy.Matrix([[
Ixx1,
Ixy1,
Ixz1,
0, -cz1*m1,
cy1*m1],
[
Ixy1,
Iyy1,
Iyz1,
cz1*m1,
0, -cx1*m1],
[
Ixz1,
Iyz1,
Izz1, -cy1*m1,
cx1*m1,
0],
[
0,
cz1*m1, -cy1*m1,
m1,
0,
0],
[-cz1*m1,
0,
cx1*m1,
0,
m1,
0],
[ cy1*m1, -cx1*m1,
0,
0,
0,
m1]])
)
```
2. Define mass, inertia matrix and center of mass separately:
```python
Mb.append(
mass_matrix_mixed_data(
m1,
sympy.Matrix([[Ixx1,Ixy1,Ixz1],
[Ixy1,Iyy1,Iyz1],
[Ixz1,Iyz1,Izz1]]),
sympy.Matrix([cx1,cy1,cz1])
)
)
```
3. Only define the 6 independent inertia parameters:
```python
Mb.append(
mass_matrix_mixed_data(
m1,
inertia_matrix(Ixx1,Ixy1,Ixz1,Iyy1,Iyz1,Izz1),
sympy.Matrix([cx1,cy1,cz1])
)
)
```
4. Automatically generate symbols in inertia matrix:
```python
Mb.append(
mass_matrix_mixed_data(
m1,
symbolic_inertia_matrix(index=1, pointmass=False),
sympy.Matrix([cx1,cy1,cz1])
)
)
```
where `symbolic_inertia_matrix(index=1, pointmass=False)` auto generates the variables <code>Ixx1</code>, <code>Ixy1</code>, etc. and creates a <code>sympy.Matrix</code> from it.
With the parameter `pointmass=True` the resulting inertia matrix looks like this instead:
```python
sympy.Matrix([[I1, 0, 0],
[ 0,I1, 0],
[ 0, 0,I1]])
```
Note that you have to import the function using <code>from <a title="skidy" href="#skidy">skidy</a> import symbolic\_inertia\_matrix</code>.
---
<pre><code class="python">q, qd, q2d = generalized_vectors(len(body_ref_config), startindex=1)
</code></pre>
Generate the generalized vectors (joint positions <code>q</code>, joint velocities <code>qd</code> and joint accelerations <code>q2d</code>). The symbols are auto generated starting at index <code>startindex</code>. The degrees of freedom in this case are taken from the length of <code>body\_ref\_config</code>.
The equivalent code would be:
<pre><code class="python">q1, q2 = sympy.symbols(&quot;q1 d2&quot;, real=True, constant=False)
dq1, dq2 = sympy.symbols(&quot;dq1 dd2&quot;, real=True, constant=False)
ddq1, ddq2 = sympy.symbols(&quot;ddq1 ddq2&quot;, real=True, constant=False)
q = sympy.Matrix([q1,q2])
qd = sympy.Matrix([dq1,dq2])
q2d = sympy.Matrix([ddq1,ddq2])
</code></pre>
To generate jerk and jounce as well, use:
<pre><code class="python">q, qd, q2d, q3d, q4d = generalized_vectors(len(body_ref_config), startindex=1, derivatives=True)
</code></pre>
---
<pre><code class="python">WEE = sympy.zeros(6,1)
</code></pre>
Define the time varying wrench on the end-effector link. Should be a (6,1) sympy.Matrix with symbolic variables, e.g.: <code>sympy.Matrix(\[Mx,My,Mz,Fx,Fy,Fz])</code>.
Optionally, you can define the time derivatives <code>WDEE</code> and <code>W2DEE</code> here too. E.g.:
<pre><code class="python">WEE = sympy.Matrix([Mx,My,Mz,Fx,Fy,Fz])
WDEE = sympy.Matrix([dMx,dMy,dMz,dFx,dFy,dFz])
W2DEE = sympy.Matrix([ddMx,ddMy,ddMz,ddFx,ddFy,ddFz])
</code></pre>
---
<pre><code class="python">skd = SymbolicKinDyn(gravity_vector=gravity,
                     ee=ee,
                     body_ref_config=body_ref_config,
                     joint_screw_coord=joint_screw_coord,
                     config_representation=representation,
                     Mb=Mb,
                     parent=parent,
                     child=child,
                     support=support,
                     )
</code></pre>
Initialize class with all defined parameters.
---
<pre><code class="python"># run Calculations
skd.closed_form_kinematics_body_fixed(q, qd, q2d, simplify=True)
skd.closed_form_inv_dyn_body_fixed(q, qd, q2d, WEE=WEE, simplify=True)
</code></pre>
Generate forward kinematics and inverse dynamics equations. Both functions share the following arguments:
- simplify: generated expressions are simplified. Note that the simplification takes a lot of time for robots with more than 2 revolute joints in a chain.
- cse: Use common subexpression elimination to shorten equations. Note that the equations are not human-readable afterwards.
- parallel: use parallel computation.
<code>skd.closed\_form\_kinematics\_body\_fixed</code> generates the following equations and saves them as class parameters:
- body_acceleration
- body_acceleration_ee
- body_jacobian_matrix
- body_jacobian_matrix_dot
- body_jacobian_matrix_ee
- body_jacobian_matrix_ee_dot
- body_twist_ee
- forward_kinematics
- hybrid_acceleration
- hybrid_acceleration_ee
- hybrid_jacobian_matrix
- hybrid_jacobian_matrix_dot
- hybrid_jacobian_matrix_ee
- hybrid_jacobian_matrix_ee_dot
- hybrid_twist_ee
and <code>skd.closed\_form\_inv\_dyn\_body\_fixed</code> generates the following equations and saves them as class parameters:
- coriolis_centrifugal_matrix
- generalized_mass_inertia_matrix
- gravity_vector
- inverse_dynamics
with provided generalized jerk and jounce vectors, <code>skd.closed\_form\_inv\_dyn\_body\_fixed</code> additionally generates the following derivatives of the equation of motion:
- coriolis_centrifugal_matrix_dot
- generalized_mass_inertia_matrix_dot
- gravity_vector_dot
- inverse_dynamics_dot
- coriolis_centrifugal_matrix_ddot
- generalized_mass_inertia_matrix_ddot
- gravity_vector_ddot
- inverse_dynamics_ddot
<code>skd.closed\_form\_inv\_dyn\_body\_fixed</code> takes the wrench <code>WEE</code> (6x1 sympy.Matrix) (tau,F) on the end-effector link and its time derivatives <code>WDEE</code> and <code>W2DEE</code> as optional additional arguments.
To calculate the 1st and 2nd order time derivative of the EOM use e.g.:
<pre><code class="python">skd.closed_form_inv_dyn_body_fixed(q, qd, q2d, q3d, q4d, WEE, WDEE, W2DEE, simplify=True)
</code></pre>
---
<pre><code class="python"># Generate Code
skd.generate_code(python=True, C=False, Matlab=False, latex=False,
                 folder=&quot;./generated_code&quot;, use_global_vars=True,
                 name=&quot;plant&quot;, project=&quot;Project&quot;)
</code></pre>
Generate Python, Matlab, C (C99) and/or LaTeX code from the generated equations.
Note that this can take time, especially for non-simplified equations and complex robots.
### 2.3. URDF
URDF files are currently only supported in combination with a python script. But there is a function to generate a template python file, which loads your URDF. In the python file it is necessary to define:
1. the URDF path
2. the gravity vector
3. end-effector configuration w.r.t. last link body fixed frame in the chain
To generate the python template file use:
<pre><code class="bash">python -m skidy --template --urdf my_urdf_template.py
</code></pre>
or the python function `skidy.generate_template_python(path, urdf=True)`.
This generates the following output:
<pre><code class="python">from skidy import (SymbolicKinDyn,
                   transformation_matrix,
                   SO3Exp,
                   generalized_vectors)
from skidy.symbols import g, pi
import sympy

# Define symbols:
lee = sympy.symbols('lee', real=True, const=True)

urdfpath = '/path/to/robot.urdf' # TODO: change me!

# gravity vector
gravity = sympy.Matrix([0,0,g])

# end-effector configuration w.r.t. last link body fixed frame in the chain
ee = transformation_matrix(r=SO3Exp(axis=[0,0,1],angle=0),t=[0,0,0])

skd = SymbolicKinDyn(gravity_vector=gravity,
                     ee=ee,
                     )

skd.load_from_urdf(path = urdfpath,
                   symbolic=True, 
                   cse=False, 
                   simplify_numbers=True,  
                   tolerance=0.0001, 
                   max_denominator=8, 
                   )

q, qd, q2d = generalized_vectors(len(skd.body_ref_config), startindex=1)
WEE = sympy.zeros(6,1)

# run Calculations
skd.closed_form_kinematics_body_fixed(q, qd, q2d, simplify=True)
skd.closed_form_inv_dyn_body_fixed(q, qd, q2d, WEE=WEE, simplify=True)

# Generate Code
skd.generate_code(python=True, C=False, Matlab=False, latex=False,
                 folder=&quot;./generated_code&quot;, use_global_vars=True,
                 name=&quot;plant&quot;, project=&quot;Project&quot;)
</code></pre>
The code explained:
<pre><code class="python">from skidy import (SymbolicKinDyn,
                   transformation_matrix,
                   SO3Exp,
                   generalized_vectors)
</code></pre>
The class <code>SymbolicKinDyn</code> is the main object for calculating the kinematic and dynamic equations of your robot and generate the code.
Additionally, we import several helper functions for defining the matrices which are useful for the robot definition:
- <code>transformation\_matrix</code>: Create SE(3) transformation matrix from SO(3) rotation and translation vector.
- <code>SO3Exp</code>: Exponential mapping of SO(3) to generate rotation matrix from rotation angle and rotation axis.
- <code>generalized\_vectors</code>: generate symbolic generalized vectors q, qd and q2d of predefined length n.
<pre><code class="python">from skidy.symbols import g, pi
</code></pre>
The package <code><a title="skidy.symbols" href="symbols.html">skidy.symbols</a></code> includes the most common used symbolic variables, which can be used for defining your robot.
<pre><code class="python">import sympy
</code></pre>
The whole library used sympy objects for all symbolic equations etc. Hence, we need <code>sympy</code> to create additional symbolic variables and matrices later.
---
<pre><code class="python"># Define symbols:
lee = sympy.symbols('lee', real=True, const=True)
</code></pre>
Create symbolic variables which can be used in the equations for the robot definition later. The most common symbols are also already present in the <code><a title="skidy.symbols" href="symbols.html">skidy.symbols</a></code> package and may be imported from there instead.
---
<pre><code class="python">urdfpath = '/path/to/robot.urdf' # TODO: change me!
</code></pre>
Enter the path to your URDF file here.
---
<pre><code class="python"># gravity vector
gravity = sympy.Matrix([0,0,g])
</code></pre>
Gravity vector as <code>sympy.Matrix</code>. Note that we can use symbolic variables here.
---
<pre><code class="python"># end-effector configuration w.r.t. last link body fixed frame in the chain
ee = transformation_matrix(r=SO3Exp(axis=[0,0,1],angle=0),t=[0,0,0])
</code></pre>
End-effector representation w.r.t. last link body frame in the chain as SE(3) transformation matrix. Look up the chapter [Python](#22-python) for all available syntax options.
---
<pre><code class="python">skd = SymbolicKinDyn(gravity_vector=gravity,
                     ee=ee,
                     )
</code></pre>
Initialize class with the two defined parameters.
---
<pre><code class="python">skd.load_from_urdf(path = urdfpath,
                   symbolic=True, 
                   cse=False, 
                   simplify_numbers=True,  
                   tolerance=0.0001, 
                   max_denominator=8, 
                   )
</code></pre>
Load the URDF file. Here you can specify the following options:
1. <code>symbolic</code>: symbolify values in urdf file (bool).
2. <code>cse</code>: use common subexpression elimination to shorten equations (bool).
3. <code>simplify\_numbers</code>: round numbers if close to common fractions like 1/2 etc and replace eg 3.1416 by pi (bool).
4. <code>tolerance</code>: tolerance for simplify numbers.
5. <code>max\_denominator</code>: define max denominator for simplify numbers to avoid simplification to something like 13/153. Use 0 to deactivate.
---
<pre><code class="python">q, qd, q2d = generalized_vectors(len(skd.body_ref_config), startindex=1)
</code></pre>
Generate the generalized vectors (joint positions <code>q</code>, joint velocities <code>qd</code> and joint accelerations <code>q2d</code>). The symbols are auto generated starting at index <code>startindex</code>. The degrees of freedom in this case are taken from the length of the parameter <code>skd.body\_ref\_config</code>, which was generated by the function <code>load\_from\_urdf</code>.
---
<pre><code class="python">WEE = sympy.zeros(6,1)
</code></pre>
Define the time varying wrench on the end-effector link. Should be a (6,1) sympy.Matrix with symbolic variables.
---
<pre><code class="python"># run Calculations
skd.closed_form_kinematics_body_fixed(q, qd, q2d, simplify=True)
skd.closed_form_inv_dyn_body_fixed(q, qd, q2d, WEE=WEE, simplify=True)
</code></pre>
Generate forward kinematics and inverse dynamics equations. See chapter [Python](#22-python) for more information.
---
<pre><code class="python"># Generate Code
skd.generate_code(python=True, C=False, Matlab=False, latex=False,
                 folder=&quot;./generated_code&quot;, use_global_vars=True,
                 name=&quot;plant&quot;, project=&quot;Project&quot;)
</code></pre>
Generate Python, Matlab, C (C99) and/or LaTeX code from the generated equations.
Note that this can take time, especially for non-simplified equations and complex robots.
## 3. Unit testing
To run the unit tests use:
<pre><code class="bash">python3 ./unit_testing/unit_testing.py
</code></pre>
## 4. Benchmarking
For benchmarking the project the script `benchmarking/benchmarking.py` was used. This script loads 4 robots with increasing complexity (1 to 4 revolute joint in a chain with planar task space) and takes the execution time of the functions <code>closed\_form\_kinematics\_body\_fixed()</code>, <code>closed\_form\_inv\_dyn\_body\_fixed()</code> and <code>generate\_code()</code>. Additionally, the arguments <code>parallel</code>, <code>simplify</code> and <code>cse</code> have been altered.
The results are shown in the following table:
arguments | parallel | serial
:---------|:----------:|:-----------:
simplify|![1 dof: 0.65 s; 2 dof: 2.14 s; 3 dof: 8.77 s; 4 dof: 44.04 s](/benchmarking/parallel_with_simplification_without_cse.png) | ![1 dof: 0.16 s; 2 dof: 2.38 s; 3 dof: 13.06 s; 4 dof: 60.68 s](/benchmarking/serial_with_simplification_without_cse.png)
simplify + cse|![1 dof: 0.56 s; 2 dof: 2.22 s; 3 dof: 12.86 s; 4 dof: 84.28 s](/benchmarking/parallel_with_simplification_with_cse.png) |![1 dof: 0.22 s; 2 dof: 2.78 s; 3 dof: 18.49 s; 4 dof: 113.30 s](/benchmarking/serial_with_simplification_with_cse.png)
no simplify|![1 dof: 0.74 s; 2 dof: 2.65 s; 3 dof: 11.29 s; 4 dof: 47.14 s](/benchmarking/parallel_without_simplification_without_cse.png) | ![1 dof: 0.08 s; 2 dof: 1.57 s; 3 dof: 9.51 s; 4 dof: 44.57 s](/benchmarking/serial_without_simplification_without_cse.png)
no simplify + cse|![1 dof: 0.80 s; 2 dof: 4.50 s; 3 dof: 29.13 s; 4 dof: 161.01 s](/benchmarking/parallel_without_simplification_with_cse.png) |![1 dof: 0.08 s; 2 dof: 4.49 s; 3 dof: 37.74 s; 4 dof: 201.11 s](/benchmarking/serial_without_simplification_with_cse.png)
## 5. License
This work has been released under the BSD 3-Clause License. Details and terms of use are specified in the LICENSE file within this repository. Note that we do not publish third-party software, hence software packages from other developers are released under their very own terms and conditions. If you install third-party software packages along with this repo ensure that you follow each individual license agreement.
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
.. include:: ../../README.md
&#34;&#34;&#34;
from skidy.kinematics_generator import SymbolicKinDyn
from skidy.matrices import (
    SE3AdjInvMatrix, SE3AdjMatrix, SE3adMatrix, SE3Exp, 
    SE3Inv, SO3Exp, inertia_matrix, transformation_matrix, 
    mass_matrix_mixed_data, rpy_to_matrix, xyz_rpy_to_matrix,
    generalized_vectors, symbolic_inertia_matrix, joint_screw, 
    quaternion_to_matrix)
from skidy.parser import (
    robot_from_yaml, robot_from_json, robot_from_urdf,
    generate_template_yaml, generate_template_json, generate_template_python)
__version__ = &#34;0.0.1&#34;</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="skidy.kinematics_generator" href="kinematics_generator.html">skidy.kinematics_generator</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="skidy.matrices" href="matrices.html">skidy.matrices</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="skidy.parser" href="parser.html">skidy.parser</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="skidy.symbols" href="symbols.html">skidy.symbols</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#skidy-symbolic-kinematics-and-dynamics-generator">skidy - symbolic kinematics and dynamics generator</a><ul>
<li><a href="#1-installation">1. Installation</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="skidy.kinematics_generator" href="kinematics_generator.html">skidy.kinematics_generator</a></code></li>
<li><code><a title="skidy.matrices" href="matrices.html">skidy.matrices</a></code></li>
<li><code><a title="skidy.parser" href="parser.html">skidy.parser</a></code></li>
<li><code><a title="skidy.symbols" href="symbols.html">skidy.symbols</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>