<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>skidy.kinematics_generator API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>skidy.kinematics_generator</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import multiprocessing
import os
import queue
import random
from collections import defaultdict
from itertools import combinations
from multiprocessing import Process, Queue
from typing import Any, Callable, Dict, Generator, List, Tuple, Union

import numpy
import regex
import sympy
from pylatex import Command, Document, NoEscape, Section
from sympy import (Identity, Matrix, MutableDenseMatrix, cancel, ccode, 
                   factor, lambdify, nsimplify, octave_code, pi, powsimp,
                   symbols, zeros, julia_code)
from sympy.printing.latex import LatexPrinter
from sympy.printing.numpy import NumPyPrinter
from sympy.simplify.cse_main import numbered_symbols
from sympy.simplify.fu import fu
from sympy.utilities.codegen import codegen, JuliaCodeGen
import sympy.physics.mechanics

from urdf_parser_py.urdf import URDF

from skidy.matrices import (SE3AdjInvMatrix, SE3AdjMatrix,
                                           SE3adMatrix, SE3Exp, SE3Inv, SO3Exp,
                                           generalized_vectors, inertia_matrix,
                                           mass_matrix_mixed_data,
                                           xyz_rpy_to_matrix, matrix_to_xyz_rpy)


class _AbstractCodeGeneration():
    def __init__(self) -&gt; None:
        # variables for Code Generation:
        self.fkin = None  # forward_kinematics
        self.J = None  # system_jacobian_matrix
        self.Jb = None  # body_jacobian_matrix
        self.Jh = None  # hybrid_jacobian_matrix
        self.Jdot = None  # system_jacobian_dot
        self.Vb_ee = None  # body_twist_ee
        self.Vh_ee = None  # hybrid_twist_ee
        self.Jb_ee = None  # body_jacobian_matrix_ee
        self.Jh_ee = None  # hybrid_jacobian_matrix_ee
        self.M = None  # generalized_mass_inertia_matrix
        self.C = None  # coriolis_centrifugal_matrix
        self.Qgrav = None  # gravity_vector
        self.Q = None  # inverse_dynamics
        self.Md = None # generalized_mass_inertia_matrix_dot 
        self.Cd = None # coriolis_centrifugal_matrix_dot
        self.Qdgrav = None # gravity_vector_dot
        self.Qd = None # inverse_dynamics_dot
        self.M2d = None # generalized_mass_inertia_matrix_ddot
        self.C2d = None # coriolis_centrifugal_matrix_ddot
        self.Q2dgrav = None # gravity_vector_ddot
        self.Q2d = None # inverse_dynamics_ddot
        self.Vh_BFn = None # hybrid_twist
        self.Vb_BFn = None # body_twist
        self.Vhd_BFn = None  # hybrid_acceleration
        self.Vbd_BFn = None  # body_acceleration
        self.Vhd_ee = None  # hybrid_acceleration_ee
        self.Vbd_ee = None  # body_acceleration_ee
        self.Jh_dot = None  # hybrid_jacobian_matrix_dot
        self.Jb_dot = None  # body_jacobian_matrix_dot
        self.Jh_ee_dot = None  # hybrid_jacobian_matrix_ee_dot
        self.Jb_ee_dot = None  # body_jacobian_matrix_ee_dot

        # set of variable symbols to use in generated functions as arguments
        self.var_syms = set()
        self.optional_var_syms = set() # for wrenches
        
        # Value assignment
        # dict with assigned variables for code generation
        self.assignment_dict = {}  
        # dict for subexpressions fro common subexpression elimination
        self.subex_dict = {}  

        self.all_symbols = set()  # set with all used symbols


    def get_expressions_dict(self, filterNone: bool=True) -&gt; Dict[str,Union[sympy.Expr, None]]:
        &#34;&#34;&#34;Get dictionary with expression names (key) and generated 
        expressions (value).

        Args:
            filterNone (bool, optional): 
                Exclude expressions which haven&#39;t been generate yet. 
                Defaults to True.

        Returns:
            dict: dictionary with expression names (key) and generated 
                expressions (value).
        &#34;&#34;&#34;
        # all expressions in this dictionary can be code generated 
        # using the generate_code function.
        expressions = {&#34;forward_kinematics&#34;: self.fkin,
                       &#34;system_jacobian_matrix&#34;: self.J,
                       &#34;body_jacobian_matrix&#34;: self.Jb,
                       &#34;hybrid_jacobian_matrix&#34;: self.Jh,
                       &#34;system_jacobian_dot&#34;: self.Jdot,
                       &#34;body_twist_ee&#34;: self.Vb_ee,
                       &#34;hybrid_twist_ee&#34;: self.Vh_ee,
                       &#34;body_twist&#34;: self.Vb_BFn,
                       &#34;hybrid_twist&#34;: self.Vh_BFn,
                       &#34;body_jacobian_matrix_ee&#34;: self.Jb_ee,
                       &#34;hybrid_jacobian_matrix_ee&#34;: self.Jh_ee,
                       &#34;generalized_mass_inertia_matrix&#34;: self.M,
                       &#34;coriolis_centrifugal_matrix&#34;: self.C,
                       &#34;gravity_vector&#34;: self.Qgrav,
                       &#34;inverse_dynamics&#34;: self.Q,
                       &#34;hybrid_acceleration&#34;: self.Vhd_BFn,
                       &#34;body_acceleration&#34;: self.Vbd_BFn,
                       &#34;hybrid_acceleration_ee&#34;: self.Vhd_ee,
                       &#34;body_acceleration_ee&#34;: self.Vbd_ee,
                       &#34;hybrid_jacobian_matrix_dot&#34;: self.Jh_dot,
                       &#34;body_jacobian_matrix_dot&#34;: self.Jb_dot,
                       &#34;hybrid_jacobian_matrix_ee_dot&#34;: self.Jh_ee_dot,
                       &#34;body_jacobian_matrix_ee_dot&#34;: self.Jb_ee_dot,
                       &#34;generalized_mass_inertia_matrix_dot&#34;: self.Md, 
                       &#34;coriolis_centrifugal_matrix_dot&#34;: self.Cd,
                       &#34;gravity_vector_dot&#34;: self.Qdgrav,
                       &#34;inverse_dynamics_dot&#34;: self.Qd,
                       &#34;generalized_mass_inertia_matrix_ddot&#34;: self.M2d,
                       &#34;coriolis_centrifugal_matrix_ddot&#34;: self.C2d,
                       &#34;gravity_vector_ddot&#34;: self.Q2dgrav,
                       &#34;inverse_dynamics_ddot&#34;: self.Q2d,
                       }  
        
        # deal with multiple ee
        all_expressions = {}
        for k, v in expressions.items():
            if type(v) is list:
                if len(v) &gt; 1:
                    for i in range(len(v)):
                        all_expressions[f&#34;{k}_{i+1}&#34;] = v[i]
                else:
                    all_expressions[k] = v[0]
            else:
                all_expressions[k] = v
        
        # exclude expressions which are None
        if filterNone:
            filtered = {k: v for k, v in all_expressions.items()
                        if v is not None}
            return filtered
        return all_expressions

    def generate_code(self, python: bool=False, C: bool=False, Matlab: bool=False, 
                      cython: bool=False, julia: bool=False, latex: bool=False, 
                      cache: bool=False, landscape: bool=False,
                      folder: str=&#34;./generated_code&#34;, use_global_vars: bool=True, 
                      name: str=&#34;plant&#34;, project: str=&#34;Project&#34;) -&gt; None:
        &#34;&#34;&#34;Generate code from generated expressions. 
        Generates Python, C (C99), Matlab/Octave, Cython and/or LaTeX code.  
        Needs &#39;closed_form_inv_dyn_body_fixed&#39; and/or 
        &#39;closed_form_kinematics_body_fixed&#39; to run first.


        Args:
            python (bool, optional): 
                Generate Python code. Defaults to False.
            C (bool, optional): 
                Generate C99 code. Defaults to False.
            Matlab (bool, optional): 
                Generate Matlab/Octave code. Defaults to False.
            cython (bool, optional):
                Generate cython code. Defaults to False.
            julia (bool, optional):
                Generate julia code. Defaults to False.
            latex (bool, optional):
                Generate latex code with all equations and generate pdf from it. 
                Defaults to False.
            cache (bool, optional):
                Cache results sin and cos function in generated python 
                and cython code. Defaults to False.
            landscape (bool, optional):
                Generate LaTeX document in landscape mode to fit longer equations.
                Defaults to False.
            folder (str, optional): 
                Folder where to save code. 
                Defaults to &#34;./generated_code&#34;.
            use_global_vars (bool, optional): 
                Constant vars like mass etc are no arguments of the 
                generated expressions. Defaults to True.
            name (str, optional): 
                Name of class and file. 
                Defaults to &#34;plant&#34;.
            project (str, optional): 
                Project name in C header. Defaults to &#34;Project&#34;.

        &#34;&#34;&#34;
        # create Folder
        if not os.path.exists(folder):
            os.mkdir(folder)

        # dict of expression names and expressions
        all_expressions = self.get_expressions_dict()

        # get individual tuples for expression names and expressions
        (names, expressions) = zip(*all_expressions.items())

        # generate set with all used symbols
        all_syms = set()
        for e in expressions:
            all_syms.update(e.free_symbols)

        if use_global_vars:
            # generate list of constant symbols
            constant_syms = self._sort_variables(
                all_syms
                .difference(self.var_syms)
                .difference(self.optional_var_syms)
                .union(self.subex_dict))
            # generate list with preassigned symbols like subexpressions
            # from common subexpression elimination
            not_assigned_syms = self._sort_variables(
                all_syms
                .difference(self.var_syms)
                .difference(self.optional_var_syms)
                .difference(self.assignment_dict)
                .difference(self.subex_dict)
                )
        else:
            constant_syms = []
            not_assigned_syms = []

        if python:
            print(&#34;Generate Python code&#34;)
            # create folder
            if not os.path.exists(os.path.join(folder, &#34;python&#34;)):
                os.mkdir(os.path.join(folder, &#34;python&#34;))

            p = NumPyPrinter()

            # start python file with import
            s = [&#34;import numpy&#34;]
            if cache:
                s.append(&#34;from functools import lru_cache&#34;)
            s.append(&#34;\n&#34;)
            # class name
            s.append(&#34;class &#34;+regex.sub(&#34;^\w&#34;,lambda x: x.group().upper(),name)+&#34;():&#34;)
            # define __init__ function
            s.append(&#34;    def __init__(self, %s) -&gt; None:&#34; % (
                &#34;, &#34;.join(
                    [str(not_assigned_syms[i])+&#34;: float&#34; 
                     for i in range(len(not_assigned_syms))] 
                    + [str(i)+&#34;: float=&#34; + str(self.assignment_dict[i]) 
                       for i in self.assignment_dict])))
            if len(not_assigned_syms) &gt; 0:
                s.append(&#34;        &#34;
                         + &#34;, &#34;.join([&#34;self.&#34;+str(not_assigned_syms[i]) 
                                      for i in range(len(not_assigned_syms))])
                         + &#34; = &#34; 
                         + &#34;, &#34;.join([str(not_assigned_syms[i]) 
                                      for i in range(len(not_assigned_syms))])
                         )

            # append preassigned values to __init__ function
            if len(self.assignment_dict) &gt; 0:
                s.append(&#34;        &#34;
                         + &#34;, &#34;.join(sorted([&#34;self.&#34;+str(i) 
                                             for i in self.assignment_dict]))
                         + &#34; = &#34; 
                         + &#34;, &#34;.join(sorted([str(i) 
                                             for i in self.assignment_dict]))
                         )

            # append cse expressions to __init__ function
            if len(self.subex_dict) &gt; 0:
                for i in sorted([str(j) for j in self.subex_dict], key=lambda x: int(regex.findall(&#34;(?&lt;=sub)\d*&#34;,x)[0])):
                    modstring = p.doprint(self.subex_dict[symbols(i)])
                    for j in sorted([str(h) 
                                     for h in self.subex_dict[symbols(i)].free_symbols],
                                    reverse=1):
                        modstring = regex.sub(
                            str(j), &#34;self.&#34;+str(j), modstring)
                        # remove double self
                        modstring = regex.sub(&#34;self.self.&#34;, &#34;self.&#34;, modstring)
                    s.append(&#34;        self.&#34;+str(i)+&#34; = &#34; + modstring)

            # define functions
            for i in range(len(expressions)):
                var_syms = self._sort_variables(self.var_syms.intersection(
                    expressions[i].free_symbols))
                optional_var_syms = self._sort_variables(self.optional_var_syms.intersection(
                    expressions[i].free_symbols))
                const_syms = self._sort_variables(
                    set(constant_syms).intersection(
                        expressions[i].free_symbols))
                if len(var_syms) &gt; 0 or len(optional_var_syms) &gt; 0:
                    s.append(&#34;\n    def &#34;+names[i]+&#34;(self, %s) -&gt; numpy.ndarray:&#34; % (
                        &#34;, &#34;.join([str(var_syms[i])+&#34;: float&#34; 
                                   for i in range(len(var_syms))]
                                  + [str(optional_var_syms[i])+&#34;: float=0&#34; 
                                   for i in range(len(optional_var_syms))])))

                else:
                    s.append(&#34;\n    def &#34;+names[i]+&#34;(self) -&gt; numpy.ndarray:&#34;)
                
                if const_syms: # insert self. in front of const_syms
                    s.append(&#34;        &#34;
                            + names[i] 
                            + &#34; = &#34; 
                            + regex.sub(f&#34;(?&lt;=\W|^)(?={&#39;|&#39;.join([str(i) for i in const_syms])}(\W|\Z))&#34;,
                                        &#34;self.&#34;,
                                        p.doprint(expressions[i])))
                else: 
                    s.append(&#34;        &#34;
                            + names[i] 
                            + &#34; = &#34; 
                            + p.doprint(expressions[i]))
                s.append(&#34;        return &#34; + names[i])

            if cache:
                s = list(map(lambda x: x.replace(&#34;numpy.sin&#34;, &#34;cached_sin&#34;), s))
                s = list(map(lambda x: x.replace(&#34;numpy.cos&#34;, &#34;cached_cos&#34;), s))
                
                s.append(&#34;&#34;)
                s.append(&#34;@lru_cache(maxsize=128)&#34;)
                s.append(&#34;def cached_sin(x: float) -&gt; float:&#34;)
                s.append(&#34;    return numpy.sin(x)&#34;)
                s.append(&#34;&#34;)
                s.append(&#34;@lru_cache(maxsize=128)&#34;)
                s.append(&#34;def cached_cos(x: float) -&gt; float:&#34;)
                s.append(&#34;    return numpy.cos(x)&#34;)
                
            # replace numpy with np for better readability
            s = list(map(lambda x: x.replace(&#34;numpy.&#34;, &#34;np.&#34;), s))
            s[0] = &#34;import numpy as np\n\n&#34;

            # join list to string
            s = &#34;\n&#34;.join(s)

            # write python file
            with open(os.path.join(folder, &#34;python&#34;, name + &#34;.py&#34;), &#34;w+&#34;) as f:
                f.write(s)
            print(&#34;Done&#34;)

        if cython:
            print(&#34;Generate Cython code&#34;)
            # create folder
            if not os.path.exists(os.path.join(folder, &#34;cython&#34;)):
                os.mkdir(os.path.join(folder, &#34;cython&#34;))

            p = NumPyPrinter()

            # start python file with import
            s = [&#34;import numpy&#34;]
            s.append(&#34;cimport numpy\n&#34;)
            s.append(&#34;cimport cython\n&#34;)
            if cache:
                s.append(&#34;from functools import lru_cache\n&#34;)
            s.append(&#34;&#34;)
            s.append(&#34;numpy.import_array()&#34;)
            # s.append(&#34;DTYPE = numpy.float64&#34;)
            # s.append(&#34;ctypedef numpy.float64_t DTYPE_t&#34;)
            
            s.append(&#34;\n&#34;)
            # class name
            s.append(&#34;@cython.boundscheck(False)&#34;)
            s.append(&#34;@cython.wraparound(False)&#34;)
            s.append(&#34;cdef class &#34;+regex.sub(&#34;^\w&#34;,lambda x: x.group().upper(),name)+&#34;():&#34;)
            s.append(&#34;    cdef public double %s\n&#34;%(
                &#34;, &#34;.join(
                    [str(not_assigned_syms[i]) 
                        for i in range(len(not_assigned_syms))] 
                    + [str(i) 
                      for i in self.assignment_dict])))
            if self.subex_dict:
                s.append(&#34;    cdef double %s\n&#34;%(
                    &#34;, &#34;.join(
                        [str(i) 
                        for i in self.subex_dict])))
                    
            
            # define __cinit__ function
            s.append(&#34;    def __cinit__(self, %s):&#34; % (
                &#34;, &#34;.join(
                    [&#34;double &#34;+str(not_assigned_syms[i]) 
                     for i in range(len(not_assigned_syms))] 
                    + [&#34;double &#34;+str(i)+&#34; = &#34; + str(self.assignment_dict[i]) 
                       for i in self.assignment_dict])))
            if len(not_assigned_syms) &gt; 0:
                s.append(&#34;        &#34;
                         + &#34;, &#34;.join([&#34;self.&#34;+str(not_assigned_syms[i]) 
                                      for i in range(len(not_assigned_syms))])
                         + &#34; = &#34; 
                         + &#34;, &#34;.join([str(not_assigned_syms[i]) 
                                      for i in range(len(not_assigned_syms))])
                         )

            # append preassigned values to __cinit__ function
            if len(self.assignment_dict) &gt; 0:
                s.append(&#34;        &#34;
                         + &#34;, &#34;.join(sorted([&#34;self.&#34;+str(i) 
                                             for i in self.assignment_dict]))
                         + &#34; = &#34; 
                         + &#34;, &#34;.join(sorted([str(i) 
                                             for i in self.assignment_dict]))
                         )

            # append cse expressions to __cinit__ function
            if len(self.subex_dict) &gt; 0:
                for i in sorted([str(j) for j in self.subex_dict], key=lambda x: int(regex.findall(&#34;(?&lt;=sub)\d*&#34;,x)[0])):
                    modstring = p.doprint(self.subex_dict[symbols(i)])
                    for j in sorted([str(h) 
                                     for h in self.subex_dict[symbols(i)].free_symbols],
                                    reverse=1):
                        modstring = regex.sub(
                            str(j), &#34;self.&#34;+str(j), modstring)
                        modstring = regex.sub(&#34;(?&lt;=(\W|^)(?&lt;!\.)\d+)(?!\.)(?=\W|\Z)&#34;,&#34;.0&#34;, modstring) # replace integer with floats
                        # remove double self
                        modstring = regex.sub(&#34;self.self.&#34;, &#34;self.&#34;, modstring)
                    s.append(&#34;        self.&#34;+str(i)+&#34; = &#34; + modstring)

            # define functions
            for i in range(len(expressions)):
                var_syms = self._sort_variables(self.var_syms.intersection(
                    expressions[i].free_symbols))
                optional_var_syms = self._sort_variables(self.optional_var_syms.intersection(
                    expressions[i].free_symbols))
                const_syms = self._sort_variables(
                    set(constant_syms).intersection(
                        expressions[i].free_symbols))
                s.append(&#34;&#34;) # empty line
                s.append(&#34;    @cython.boundscheck(False)&#34;)
                s.append(&#34;    @cython.wraparound(False)&#34;)
                if len(var_syms) &gt; 0 or len(optional_var_syms) &gt; 0:
                    # s.append(f&#34;    cpdef double[:,::1] &#34;+names[i]+&#34;(self, %s):&#34; % (
                    s.append(f&#34;    cpdef numpy.ndarray[double, ndim={len(expressions[i].shape)}] &#34;+names[i]+&#34;(self, %s):&#34; % (
                    # s.append(f&#34;\n    cpdef np.ndarray[DTYPE_t,ndim={len(expressions[i].shape)}] &#34;+names[i]+&#34;(self, %s):&#34; % (
                        &#34;, &#34;.join([&#34;double &#34;+str(var_syms[i]) 
                                   for i in range(len(var_syms))]
                                  + [&#34;double &#34;+str(optional_var_syms[i])+&#34;=0.0&#34; 
                                     for i in range(len(optional_var_syms))])))

                else:
                    s.append(f&#34;    cpdef numpy.ndarray[double, ndim={len(expressions[i].shape)}] &#34;+names[i]+&#34;(self):&#34;)
                
                # s.append(f&#34;        cdef double[:,::1] {names[i]} = numpy.empty({expressions[i].shape}, dtype=double)&#34;)
                s.append(f&#34;        cdef numpy.ndarray[double, ndim={len(expressions[i].shape)}] {names[i]} = numpy.empty({expressions[i].shape}, dtype=np.double)&#34;)
                for j in range(expressions[i].shape[0]):
                    for k in range(expressions[i].shape[1]):
                        if const_syms:
                            # add self before const_syms
                            ex_string = regex.sub(f&#34;(?&lt;=\W|^)(?={&#39;|&#39;.join([str(i) for i in const_syms])}(\W|\Z))&#34;,&#34;self.&#34;,p.doprint(expressions[i][j,k]))
                            # replace integer with floats
                            ex_string = regex.sub(&#34;(?&lt;=(\W|^)(?&lt;!\.)\d+)(?!\.)(?=\W|\Z)&#34;,&#34;.0&#34;, ex_string) 
                            s.append(&#34;        &#34;
                                    + names[i]
                                    + f&#34;[{j}, {k}]&#34; 
                                    + &#34; = &#34; 
                                    + ex_string)
                                    #  + regex.sub(&#34;(?&lt;=((?&lt;=[^\.])\W)\d+)(?=\W)(?!\.)&#34;,&#34;.0&#34;,regex.sub(f&#34;(?&lt;=\W|^)(?={&#39;|&#39;.join([str(i) for i in const_syms])}(\W|\Z))&#34;,&#34;self.&#34;,p.doprint(expressions[i]))))
                        else:
                            ex_string = p.doprint(expressions[i])
                            # replace integer with floats
                            ex_string = regex.sub(&#34;(?&lt;=(\W|^)(?&lt;!\.)\d+)(?!\.)(?=\W|\Z)&#34;,&#34;.0&#34;, ex_string) 
                            s.append(&#34;        &#34;
                                    + names[i] 
                                    + f&#34;[{j}, {k}]&#34; 
                                    + &#34; = &#34; 
                                    + ex_string)
                            
                s.append(&#34;        return &#34; + names[i])

            if cache:
                s = list(map(lambda x: x.replace(&#34;numpy.sin&#34;, &#34;cached_sin&#34;), s))
                s = list(map(lambda x: x.replace(&#34;numpy.cos&#34;, &#34;cached_cos&#34;), s))
                
                s.append(&#34;&#34;)
                s.append(&#34;@lru_cache(maxsize=128)&#34;)
                s.append(&#34;def cached_sin(double x):&#34;)
                s.append(&#34;    return numpy.sin(x)&#34;)
                s.append(&#34;&#34;)
                s.append(&#34;@lru_cache(maxsize=128)&#34;)
                s.append(&#34;def cached_cos(double x):&#34;)
                s.append(&#34;    return numpy.cos(x)&#34;)
            
            # replace numpy with np for better readability
            s = list(map(lambda x: x.replace(&#34;numpy.&#34;, &#34;np.&#34;), s))
            s[0] = &#34;import numpy as np&#34;
            s[1] = &#34;cimport numpy as np\n&#34;

            # join list to string
            s = &#34;\n&#34;.join(s)

            # create setup file to compile cython code
            su = (&#34;import os.path\n&#34;
                  + &#34;from setuptools import setup\n&#34;
                  + &#34;from Cython.Build import cythonize\n&#34;
                  + &#34;\n&#34;
                  + &#34;setup(\n&#34;
                  + f&#34;    name=&#39;{name}&#39;,\n&#34;
                  + f&#34;    ext_modules=cythonize(os.path.join(os.path.dirname(__file__), &#39;{name + &#39;.pyx&#39;}&#39;), \n&#34;
                  +  &#34;                          compiler_directives={&#39;language_level&#39; : &#39;3&#39;}),\n&#34;
                  + &#34;    zip_safe=False,\n&#34;
                  + &#34;)\n&#34;
            )


            # write cython file
            with open(os.path.join(folder, &#34;cython&#34;, name + &#34;.pyx&#34;), &#34;w+&#34;) as f:
                f.write(s)
            
            # write setup file
            with open(os.path.join(folder, &#34;cython&#34;, &#34;setup_&#34; + name + &#34;.py&#34;), &#34;w+&#34;) as f:
                f.write(su)
            
            print(&#34;Done&#34;)

        if C:
            print(&#34;Generate C code&#34;)
            if not os.path.exists(os.path.join(folder, &#34;C&#34;)):
                os.mkdir(os.path.join(folder, &#34;C&#34;))

            # generate c files
            if use_global_vars:
                [(c_name, c_code), (h_name, c_header)] = codegen(
                    [tuple((names[i], expressions[i])) 
                     for i in range(len(expressions))],
                    &#34;C99&#34;, name, project, header=False, 
                    empty=True, global_vars=constant_syms)
            else:
                [(c_name, c_code), (h_name, c_header)] = codegen(
                    [tuple((names[i], expressions[i])) 
                     for i in range(len(expressions))],
                    &#34;C99&#34;, name, project, header=False, empty=True)
            # change strange variable names
            c_code = regex.sub(r&#34;out_\d{10}[\d]+&#34;, &#34;out&#34;, c_code)
            c_header = regex.sub(r&#34;out_\d{10}[\d]+&#34;, &#34;out&#34;, c_header)

            c_lines = c_code.splitlines(True)
            i = 0
            # correct dimension of output array pointers
            while i &lt; len(c_lines):
                # find function definition
                if any(n+&#34;(&#34; in c_lines[i] for n in names):
                    # which expression is defined
                    [fname] = [n for n in names if n+&#34;(&#34; in c_lines[i]]
                    # find shape of expression
                    cols = all_expressions[fname].shape[1]
                    i += 1
                    # replace all 1D arrays with 2D arrays for matrices
                    while &#34;}&#34; not in c_lines[i]:
                        out = regex.findall(&#34;out\[[\d]+\]&#34;, c_lines[i])
                        if out and cols &gt; 1:
                            [num] = regex.findall(&#34;[\d]+&#34;, out[0])
                            num = int(num)
                            c_lines[i] = c_lines[i].replace(
                                out[0], f&#34;out[{num//cols}][{num%cols}]&#34;)
                        i += 1
                i += 1
            c_code = &#34;&#34;.join(c_lines)
            
            # save assinged parameters to another c file
            c_def_name = f&#34;{c_name[:-2]}_parameters.c&#34;
            header_insert = []
            c_definitions = [f&#39;#include &#34;{h_name}&#34;\n&#39;]
            c_definitions.append(&#34;#include &lt;math.h&gt;\n&#34;)
            c_definitions.append(&#34;\n&#34;)
            
            if not_assigned_syms:
                header_insert.append(f&#34;/* Please uncomment and assign values in &#39;{c_def_name}&#39;\n&#34;)
                c_definitions.append(f&#34;/* Please assign values and uncomment in &#39;{h_name}&#39;\n&#34;)
                for var in sorted([str(i) for i in not_assigned_syms]):
                    header_insert.append(f&#34;extern const float {var};\n&#34;)
                    if var == &#34;g&#34;:
                        c_definitions.append(f&#34;const float {var} = 9.81;\n&#34;)
                    else:
                        c_definitions.append(f&#34;const float {var} = 0;\n&#34;)
                header_insert.append(&#34;*/ \n&#34;)
                c_definitions.append(&#34;*/ \n&#34;)
            
            for var in sorted([str(i) for i in self.assignment_dict]):
                val = ccode(self.assignment_dict[symbols(var)])
                header_insert.append(f&#34;extern const float {var};\n&#34;)
                c_definitions.append(f&#34;const float {var} = {val};\n&#34;)


            # append cse expressions
            for var in sorted([str(j) for j in self.subex_dict], key=lambda x: int(regex.findall(&#34;(?&lt;=sub)\d*&#34;,x)[0])):
                val = ccode(self.subex_dict[symbols(var)])
                header_insert.append(f&#34;extern const float {var};\n&#34;)
                c_definitions.append(f&#34;const float {var} = {val};\n&#34;)

            
            
            if header_insert:
                header_insert.append(&#34;\n&#34;)
                h_lines = c_header.splitlines(True)
                for i in range(len(h_lines)):
                    if &#34;#endif&#34; in h_lines[i]:
                        h_lines[i:i] = header_insert 
                        break
                c_header = &#34;&#34;.join(h_lines)

            # write code files
            with open(os.path.join(folder, &#34;C&#34;, c_name), &#34;w+&#34;) as f:
                f.write(c_code)
            with open(os.path.join(folder, &#34;C&#34;, h_name), &#34;w+&#34;) as f:
                f.write(c_header)
            if header_insert:
                with open(os.path.join(folder, &#34;C&#34;, c_def_name), &#34;w+&#34;) as f:
                    f.writelines(c_definitions)
                
            print(&#34;Done&#34;)

        if julia:
            print(&#34;Generate julia code&#34;)
            if not os.path.exists(os.path.join(folder, &#34;julia&#34;)):
                os.mkdir(os.path.join(folder, &#34;julia&#34;))

            jcg = JuliaCodeGen(project=project)
            if use_global_vars:
                routines = [jcg.routine(names[i],
                                        expressions[i],
                                        self._sort_variables(
                                            (self.var_syms 
                                             | self.optional_var_syms)
                                            &amp; expressions[i].free_symbols),
                                        global_vars=constant_syms) 
                            for i in range(len(expressions))]
                
                # save assigned parameters to beginning of julia file
                j_definitions = []
                
                if not_assigned_syms:
                    j_definitions.append(&#34;# Please assign values\n&#34;)
                    for var in sorted([str(i) for i in not_assigned_syms]):
                        if var == &#34;g&#34;:
                            j_definitions.append(f&#34;{var} = 9.81\n&#34;)
                        else:
                            j_definitions.append(f&#34;{var} = 0\n&#34;)
                    j_definitions.append(&#34;\n&#34;)

                if self.assignment_dict:                
                    for var in sorted([str(i) for i in self.assignment_dict]):
                        val = julia_code(self.assignment_dict[symbols(var)])
                        j_definitions.append(f&#34;{var} = {val}\n&#34;)
                    j_definitions.append(&#34;\n&#34;)

                # append cse expressions
                if self.subex_dict:
                    j_definitions.append(&#34;# subexpressions due to cse\n&#34;)
                    for var in sorted([str(j) for j in self.subex_dict], key=lambda x: int(regex.findall(&#34;(?&lt;=sub)\d*&#34;,x)[0])):
                        val = julia_code(self.subex_dict[symbols(var)])
                        j_definitions.append(f&#34;{var} = {val}\n&#34;)
                    j_definitions.append(&#34;\n&#34;)

                j_constants = &#34;&#34;.join(j_definitions)
            else:
                routines = [jcg.routine(names[i],
                                        expressions[i],
                                        self._sort_variables(
                                            expressions[i].free_symbols),
                                        global_vars=None) 
                            for i in range(len(expressions))]
                j_constants = &#34;&#34;
                
            j_name, j_code = jcg.write(routines,name, header=False)[0]
            j_code = j_constants + j_code
            
            # ensure operator ^ instead of **
            j_code = j_code.replace(&#34;**&#34;,&#34;^&#34;)
            
            # write code files
            with open(os.path.join(folder, &#34;julia&#34;, j_name), &#34;w+&#34;) as f:
                f.write(j_code)
            
            print(&#34;Done&#34;)



        if Matlab:
            # create folder
            if not os.path.exists(os.path.join(folder, &#34;matlab&#34;)):
                os.mkdir(os.path.join(folder, &#34;matlab&#34;))
            m_class = []
            m_class.append(f&#34;classdef {name}\n&#34;)
            m_properties = not_assigned_syms[:]
            m_properties.extend([i for i in self.assignment_dict])
            # properties
            m_class.append(f&#34;\tproperties\n&#34;)
            for var in m_properties:
                m_class.append(f&#34;\t\t{str(var)}\n&#34;)
            # add cse subexpressions as private properties
            if self.subex_dict:
                m_class.append(&#34;\tend\n\n&#34;)
                m_class.append(f&#34;\tproperties (Access = private)\n&#34;)
                for var in [i for i in sorted([str(j) for j in self.subex_dict], key=lambda x: int(regex.findall(&#34;(?&lt;=sub)\d*&#34;,x)[0]))]:
                    m_class.append(f&#34;\t\t{str(var)}\n&#34;)
                # add subex to m_properties list
                m_properties.extend([i for i in sorted([str(j) for j in self.subex_dict], key=lambda x: int(regex.findall(&#34;(?&lt;=sub)\d*&#34;,x)[0]))])
            m_class.append(&#34;\tend\n\n&#34;)
            
            # methods
            m_class.append(f&#34;\tmethods\n&#34;)
            
            # init function
            # function arguments
            var_substr = &#34;, &#34;.join(
                    [str(not_assigned_syms[i]) 
                     for i in range(len(not_assigned_syms))] 
                    + [str(j) for j in self.assignment_dict])
            m_class.append(f&#34;\t\tfunction obj = {name}({var_substr})\n&#34;)
            
            # default values for not assigned variables
            if not_assigned_syms:
                m_class.append(f&#34;\t\t\t% TODO: Assign missing variables here:\n&#34;)
                for var in not_assigned_syms:
                    if str(var) == &#34;g&#34;:
                        m_class.append(f&#34;\t\t\t% if ~exist(&#39;{str(var)}&#39;,&#39;var&#39;); {str(var)} = 9.81; end\n&#34;)
                    else:
                        m_class.append(f&#34;\t\t\t% if ~exist(&#39;{str(var)}&#39;,&#39;var&#39;); {str(var)} = 0; end\n&#34;)
            # default values for assigned variables
            for var in self.assignment_dict:
                val = octave_code(self.assignment_dict[var])
                m_class.append(f&#34;\t\t\tif ~exist(&#39;{str(var)}&#39;,&#39;var&#39;); {str(var)} = {val}; end\n&#34;)
            m_class.append(&#34;&#34;)
            # save variables to parameters
            for var in not_assigned_syms:
                m_class.append(f&#34;\t\t\tobj.{str(var)} = {str(var)};\n&#34;)
            for var in self.assignment_dict:
                m_class.append(f&#34;\t\t\tobj.{str(var)} = {str(var)};\n&#34;)
            # calculate subexpressions
            for var in sorted([str(j) for j in self.subex_dict], key=lambda x: int(regex.findall(&#34;(?&lt;=sub)\d*&#34;,x)[0])):
                val = regex.sub(&#34;(?&lt;=\W|^)sub&#34;,&#34;obj.sub&#34;,octave_code(self.subex_dict[symbols(var)]))
                m_class.append(f&#34;\t\t\tobj.{str(var)} = {val};\n&#34;)       
            m_class.append(&#34;\t\tend\n\n&#34;)
            
            # Add generated functions
            for i in range(len(expressions)):
                # generate function
                [(m_name, m_code)] = codegen(
                    (names[i], expressions[i]), &#34;Octave&#34;, project=project, 
                    header=False, empty=True, 
                    argument_sequence=self._sort_variables(self.all_symbols)
                    )
                # remove already set variables
                m_func = m_code.splitlines(True)
                m_func = [f&#34;\t\t{line}&#34; for line in m_func]
                m_func[0] = m_func[0].replace(&#34;(&#34;,&#34;(obj, &#34;)
                m_func[0] = regex.sub(
                    &#34;(&#34; + &#39;|&#39;.join([f&#39;, {str(v)}(?=\W)&#39; for v in m_properties])+&#34;)&#34;,
                    &#34;&#34;, m_func[0])
                # remove unused variable symbols
                m_func[0] = regex.sub(
                    &#34;(&#34; + &#39;|&#39;.join([f&#39;, {str(v)}(?=\W)&#39; for v in self.var_syms.union(self.optional_var_syms).difference(expressions[i].free_symbols)])+&#34;)&#34;,
                    &#34;&#34;, m_func[0])
                # use obj.variables defined in class parameters
                for i in range(1, len(m_func)):
                    m_func[i] = regex.sub(f&#34;(?&lt;=\W|^)(?=({&#39;|&#39;.join([str(s) for s in m_properties])})\W)&#34;,&#34;obj.&#34;,m_func[i])        
                m_func.append(&#34;\n&#34;)
                m_class.extend(m_func)
            
            m_class.append(&#34;\tend\n&#34;)
            m_class.append(&#34;end\n&#34;)
            with open(os.path.join(folder, &#34;matlab&#34;, f&#34;{name}.m&#34;), &#34;w+&#34;) as f:
                f.writelines(m_class)
        
        if latex:
            # create folder
            if not os.path.exists(os.path.join(folder, &#34;latex&#34;)):
                os.mkdir(os.path.join(folder, &#34;latex&#34;))

            # Document with `\maketitle` command activated
            doc = Document(documentclass=&#34;article&#34;, inputenc=&#34;utf8&#34;)
            if landscape:
                doc.packages.append(NoEscape(r&#34;\usepackage[landscape,a4paper,top=2cm,bottom=2cm,left=2.5cm,right=2.5cm,marginparwidth=1.75cm]{geometry}&#34;))
            else: 
                doc.packages.append(NoEscape(r&#34;\usepackage[a4paper,top=2cm,bottom=2cm,left=2.5cm,right=2.5cm,marginparwidth=1.75cm]{geometry}&#34;))
            doc.packages.append(NoEscape(r&#34;\usepackage{amsmath}&#34;))
            doc.packages.append(NoEscape(r&#34;\usepackage{graphicx}&#34;))
            doc.packages.append(NoEscape(r&#34;\usepackage{breqn}[breakdepth={100}]&#34;))
            
            doc.preamble.append(Command(&#34;title&#34;, &#34;Equations of Motion&#34;))
            doc.preamble.append(Command(&#34;author&#34;, &#34;Author: SymbolicKinDyn&#34;))
            doc.preamble.append(Command(&#34;date&#34;, NoEscape(r&#34;\today&#34;)))
            doc.append(NoEscape(r&#34;\maketitle&#34;))
            doc.append(NoEscape(r&#34;\tableofcontents&#34;))
            doc.append(NoEscape(r&#34;\newpage&#34;))
            
            # create symbols and indices for equations
            for i in range(len(expressions)):
                letter = &#34;&#34;
                if &#34;jacobian&#34; in names[i]: letter = &#34;J&#34;
                elif &#34;twist&#34; in names[i]: letter = r&#34;V&#34;
                elif &#34;kinematics&#34; in names[i]: letter = r&#34;^0T_E&#34;
                elif &#34;inertia&#34; in names[i]: letter = &#34;M&#34;
                elif &#34;coriolis&#34; in names[i]: letter = &#34;C&#34;
                elif &#34;gravity&#34; in names[i]: letter = &#34;g&#34;
                elif &#34;dynamics&#34; in names[i]: letter = r&#34;\tau&#34;
                elif &#34;acceleration&#34; in names[i]: letter = r&#34;\dot V&#34;
                if &#34;ddot&#34; in names[i]: letter = r&#34;\ddot &#34;+letter
                elif &#34;dot&#34; in names[i]: letter = r&#34;\dot &#34;+letter
                if &#34;_ee&#34; in names[i]: letter = r&#34;^E&#34; + letter
                elif (&#34;twist&#34; in names[i] 
                      or &#34;jacobian&#34; in names[i] 
                      or &#34;acceleration&#34; in names[i]): letter = r&#34;^0&#34; + letter
                if &#34;hybrid&#34; in names[i]: letter += r&#34;_h&#34;
                elif &#34;body&#34; in names[i]: letter += r&#34;_b&#34;
                
                replacements = [(&#34;ddddq&#34;, r&#34;\\ddddot q&#34;),
                                (&#34;ddddtheta&#34;, r&#34;\\ddddot \\theta&#34;),
                                (&#34;dddq&#34;, r&#34;\\dddot q&#34;),
                                (&#34;dddtheta&#34;, r&#34;\\dddot \\theta&#34;),
                                (&#34;ddq&#34;, r&#34;\\ddot q&#34;), 
                                (&#34;ddtheta&#34;, r&#34;\\ddot \\theta&#34;), 
                                (&#34;dq&#34;, r&#34;\\dot q&#34;),
                                (&#34;dtheta&#34;, r&#34;\\dot \\theta&#34;)
                                ]
                with doc.create(Section(regex.sub(&#34;_&#34;,&#34; &#34;,names[i]))):
                    maxlen = 0
                    for row in range(expressions[i].shape[0]):
                        length = 0
                        for column in range(expressions[i].shape[1]):
                             length += len(regex.sub(r&#34;(\\left|\\right|\{|\}|\\|_|\^|dot|ddot| |begin|matrix)&#34;,&#34;&#34;,str(expressions[i][row,column])))
                        maxlen = max(maxlen, length)
                    if maxlen &lt; 120+int(landscape)*100:
                        eq = LatexPrinter().doprint(expressions[i])
                        for pat, repl in replacements:
                            eq = regex.sub(pat, repl, eq)
                        # doc.append(NoEscape(r&#34;\begin{footnotesize}&#34;))
                        doc.append(NoEscape(r&#34;\[ \resizebox{\ifdim\width&gt;\columnwidth\columnwidth\else\width\fi}{!}{$%&#34;))
                        doc.append(NoEscape(r&#34;\boldsymbol{&#34;f&#34;{letter}&#34;&#34;} = &#34;f&#34;{eq}&#34;))
                        doc.append(NoEscape(r&#34;$} \]&#34;))
                    else:
                        doc.append(NoEscape(r&#34;\begin{dgroup*}&#34;))
                        for row in range(expressions[i].shape[0]):
                            for column in range(expressions[i].shape[1]):
                                eq = LatexPrinter().doprint(expressions[i][row,column])
                                for pat, repl in replacements:
                                    eq = regex.sub(pat, repl, eq)
                                doc.append(NoEscape(r&#34;\begin{dmath*}&#34;))
                                doc.append(NoEscape(f&#34;{letter}_&#34;+&#34;{&#34;+f&#34;{row+1}{&#39;,&#39;+str(column+1) if expressions[i].shape[1]&gt;1 else &#39;&#39;}&#34; + &#34;}&#34; + &#34; = &#34; + f&#34;{eq}&#34;))
                                doc.append(NoEscape(r&#34;\end{dmath*}&#34;))
                        doc.append(NoEscape(r&#34;\end{dgroup*}&#34;))
                        
                    # doc.append(NoEscape(r&#34;\end{footnotesize}&#34;))
                    # doc.append(&#34;\n&#34;)
            
            # save tex file and compile pdf
            doc.generate_pdf(os.path.join(folder, &#34;latex&#34;,name), clean_tex=False)
    
    def _sort_variables(self, vars:List[sympy.Symbol]) -&gt; List[sympy.Symbol]:
        &#34;&#34;&#34;Sort variables for code generation starting with q, qd, qdd, 
        continuing with variable symbols and ending with constant 
        symbols.

        Args:
            vars (list of sympy.symbols): Variables to sort.

        Returns:
            list: Sorted list of variables.
        &#34;&#34;&#34;
        # vars as set
        vars = set(vars)
        # divide into variable and constant symbols
        var_syms = self.var_syms.intersection(vars)
        optional_var_syms = self.optional_var_syms.intersection(vars)
        rest = list(vars.difference(var_syms).difference(optional_var_syms))
        # divide variable symbols into q, dq, ddq and other variable symbols
        q = []
        dq = []
        ddq = []
        dddq = []
        ddddq = []
        var_rest = []
        WEE = []
        WDEE = []
        W2DEE = []
        for i in var_syms:
            if str(i).startswith(&#34;ddddq&#34;) or  (self.q4d and i in self.q4d):
                ddddq.append(i)
            elif str(i).startswith(&#34;dddq&#34;) or (self.q3d and i in self.q3d):
                dddq.append(i)
            elif str(i).startswith(&#34;ddq&#34;) or i in self.q2d:
                ddq.append(i)
            elif str(i).startswith(&#34;dq&#34;) or i in self.qd:
                dq.append(i)
            elif str(i).startswith(&#34;q&#34;) or i in self.q:
                q.append(i)
            else:
                var_rest.append(i)
                
        for i in optional_var_syms:
            if str(i).startswith(&#34;dd&#34;) or i in self.W2DEE:
                W2DEE.append(i)
            elif str(i).startswith(&#34;d&#34;) or i in self.WDEE:
                WDEE.append(i)
            else:
                WEE.append(i)
            
        def symsort(data: List[sympy.Symbol]) -&gt; List[sympy.Symbol]:
            &#34;&#34;&#34;Sort symbols

            Args:
                data (list): symbols

            Returns:
                list: sorted symbols
            &#34;&#34;&#34;
            return [x for _, x in sorted(zip(list(map(str, data)), data))]
        
        # return sorted list
        return (symsort(q) 
                + symsort(dq) 
                + symsort(ddq) 
                + symsort(dddq) 
                + symsort(ddddq) 
                + symsort(var_rest) 
                + symsort(WEE) 
                + symsort(WDEE) 
                + symsort(W2DEE) 
                + symsort(rest))
            
            
class SymbolicKinDyn(_AbstractCodeGeneration):
    BODY_FIXED = &#34;body_fixed&#34;
    SPATIAL = &#34;spatial&#34;
    
    def __init__(self, 
                 gravity_vector: MutableDenseMatrix=None, 
                 ee: Union[MutableDenseMatrix,List[MutableDenseMatrix]]=None, 
                 body_ref_config: List[MutableDenseMatrix]=[], 
                 joint_screw_coord: List[MutableDenseMatrix]=[], 
                 config_representation: str=&#34;spatial&#34;, 
                 Mb: List[MutableDenseMatrix]=[], 
                 parent: List[int]=[], 
                 support: List[List[int]]=[], 
                 child: List[List[int]]=[], 
                 ee_parent: Union[int,List[int]]=None,
                 q:MutableDenseMatrix=None, 
                 qd: MutableDenseMatrix=None, 
                 q2d: MutableDenseMatrix=None, 
                 q3d: MutableDenseMatrix=None, 
                 q4d: MutableDenseMatrix=None, 
                 WEE: Union[MutableDenseMatrix,List[MutableDenseMatrix]]=zeros(6, 1),
                 WDEE: Union[MutableDenseMatrix,List[MutableDenseMatrix]]=zeros(6, 1),
                 W2DEE: Union[MutableDenseMatrix,List[MutableDenseMatrix]]=zeros(6, 1),
                 **kwargs) -&gt; None:
        &#34;&#34;&#34;SymbolicKinDyn
        Symbolic tool to compute equations of motion of serial chain 
        robots and autogenerate code from the calculated equations. 
        This tool supports generation of python, C and Matlab code.

        Args:
            gravity_vector (sympy.Matrix, optional): 
                Vector of gravity. Defaults to None.
            ee (sympy.Matrix | list of sympy.Matrix, optional): 
                End-effector configuration with reference to last link 
                body fixed frame in the chain. This link can be selected 
                manually using the parameter ee_parent. 
                If there is more than one end-effector use a list of 
                transforms instead.
                Defaults to None.
            body_ref_config (list of sympy.Matrix, optional): 
                List of reference configurations of bodies in body-fixed
                or spatial representation, dependent on selected 
                config_representation. 
                Leave empty for dH Parameter usage (dhToScrewCoord(...)). 
                Defaults to [].
            joint_screw_coord (list of sympy.Matrix, optional): 
                List of joint screw coordinates in body-fixed 
                or spatial representation, dependent on selected 
                config_representation. 
                Leave empty for dH Parameter usage (dhToScrewCoord(...)). 
                Defaults to [].
            config_representation (str, optional): 
                Use body fixed or spatial representation for reference 
                configuration of bodies and joint screw coordinates.
                Has to be &#34;body_fixed&#34; or &#34;spatial&#34;. 
                Defaults to &#34;spatial&#34;.
            Mb (list of sympy.Matrix, optional): 
                List of Mass Inertia matrices for all links. Only 
                necessary for inverse dynamics. Defaults to [].
            parent (list, optional): 
                list of parent link indices for any joint. Use 0 for world.
                Only necessary for tree-like robot structures. 
                Defaults to [].
            support (list, optional): 
                list of lists with one list per link which includes all 
                support links beginning with the first link in the chain 
                and including the current link.
                Only necessary for tree-like robot structures. 
                Defaults to [].
            child (list, optional): 
                list of lists with one list per link which includes all
                child links. Use empty list if no child link is present.
                Only necessary for tree-like robot structures. 
                Defaults to [].
            ee_parent (int | list, optional): 
                parent link of the end effector frame. If there is more 
                than one end-effector, use a list of indices instead.
                Defaults to None (= last link).
            q (sympy.Matrix, optional): 
                (n,1) Generalized position vector. Defaults to None.
            qd (sympy.Matrix, optional): 
                (n,1) Generalized velocity vector. Defaults to None.
            q2d (sympy.Matrix, optional): 
                (n,1) Generalized acceleration vector. Defaults to None.
            q3d (sympy.Matrix, optional): 
                (n,1) Generalized jerk vector. Defaults to None.
            q4d (sympy.Matrix, optional): 
                (n,1) Generalized jounce vector. Defaults to None.
            WEE (sympy.Matrix | list, optional): 
                (6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time varying 
                wrench on the EE link. 
                If there is more than one end-effector, you can use a 
                list containing all wrenches instead.
                Defaults to zeros(6, 1).
            WDEE (sympy.Matrix | list, optional): 
                (6,1) WDEE (t) = [dMx,dMy,dMz,dFx,dFy,dFz] is the derivative 
                of the time varying wrench on the EE link. 
                If there is more than one end-effector, you can use a 
                list containing all wrenches instead.
                Defaults to zeros(6, 1).
            W2DEE (sympy.Matrix | list, optional): 
                (6,1) W2DEE (t) = [ddMx,ddMy,ddMz,ddFx,ddFy,ddFz] is the 
                2nd derivative of the time varying wrench on the EE link. 
                If there is more than one end-effector, you can use a 
                list containing all wrenches instead.
                Defaults to zeros(6, 1).
            
        &#34;&#34;&#34;
        super().__init__()
        self.n = None  # degrees of freedom
        self.gravity_vector = gravity_vector
        self.ee = ee

        self.B = [] # List of reference configurations of bodies in body-fixed representation.
        self.X = [] # List of joint screw coordinates in body-fixed representation.

        self.A = [] # List of reference configurations of bodies in spatial representation.
        self.Y = [] # List of joint screw coordinates in spatial representation.
        
        self.config_representation = config_representation # @property: checks for valid value 
        if body_ref_config != []:
            self.body_ref_config = body_ref_config # @property: sets A or B
        if joint_screw_coord != []:
            self.joint_screw_coord = joint_screw_coord # @property: sets X or Y
        # support of old syntax
        if &#34;A&#34; in kwargs:
            self.A = kwargs[&#34;A&#34;]
            n = len(self.A)
            if n:
                self.n = n
        if &#34;B&#34; in kwargs:
            self.B = kwargs[&#34;B&#34;]
            n = len(self.B)
            if n:
                self.n = n
        if &#34;X&#34; in kwargs:
            self.X = kwargs[&#34;X&#34;]
        if &#34;Y&#34; in kwargs:
            self.Y = kwargs[&#34;Y&#34;]

            
        self.Mb = Mb
        self.parent = parent
        self.child = child
        self.support = support
        
        # costom ee link
        self.ee_parent = ee_parent
        
        # temporary vars
        self._FK_C = None
        self._A = None
        self._a = None
        self._V = None  # system twist

        
        # Multiprocessing
        # dict of queues, which saves values and results
        self.queue_dict = {}  
        # dict of running processes
        self.process_dict = {}  
        
        # generalized vectors end external forces
        self.q = q
        self.qd = qd
        self.q2d = q2d
        self.q3d = q3d
        self.q4d = q4d
        self.WEE = WEE
        self.WDEE = WDEE
        self.W2DEE = W2DEE

        
    @property
    def config_representation(self) -&gt; str:
        return self._config_representation
    
    @config_representation.setter
    def config_representation(self, value: str) -&gt; None:
        if value not in {self.BODY_FIXED, self.SPATIAL}:
            raise ValueError(&#34;config_representation has to be &#39;body_fixed&#39; or &#39;spatial&#39;&#34;)
        self._config_representation = value
    
    @property
    def body_ref_config(self) -&gt; list:
        if self.config_representation == self.BODY_FIXED:
            return self.B
        elif self.config_representation == self.SPATIAL:
            return self.A
    
    @body_ref_config.setter
    def body_ref_config(self, value: List[MutableDenseMatrix]) -&gt; None:
        n = len(value)
        if n:
            self.n = n
        if self.config_representation == self.BODY_FIXED:
            self.B = value
        elif self.config_representation == self.SPATIAL:
            self.A = value
    
    @property
    def joint_screw_coord(self) -&gt; list:
        if self.config_representation == self.BODY_FIXED:
            return self.X
        elif self.config_representation == self.SPATIAL:
            return self.Y
    
    @joint_screw_coord.setter
    def joint_screw_coord(self, value: List[MutableDenseMatrix]) -&gt; None:
        if self.config_representation == self.BODY_FIXED:
            self.X = value
        elif self.config_representation == self.SPATIAL:
            self.Y = value
    
    def closed_form_kinematics_body_fixed(
        self, q:sympy.MutableDenseMatrix=None, qd: MutableDenseMatrix=None, 
        q2d: MutableDenseMatrix=None, simplify: bool=True, 
        cse: bool=False, parallel: bool=True) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Position, Velocity and Acceleration Kinematics using Body 
        fixed representation of the twists in closed form.

        The following expressions are saved in the class and can be 
        code generated afterwards:
        
            body_acceleration
            body_acceleration_ee
            body_jacobian_matrix
            body_jacobian_matrix_dot 
            body_jacobian_matrix_ee
            body_jacobian_matrix_ee_dot
            body_twist_ee
            forward_kinematics
            hybrid_acceleration
            hybrid_acceleration_ee
            hybrid_jacobian_matrix
            hybrid_jacobian_matrix_dot
            hybrid_jacobian_matrix_ee
            hybrid_jacobian_matrix_ee_dot
            hybrid_twist_ee

        Needs class parameters body_ref_config, joint_screw_coord and ee 
        to be defined.

        Args:
            q (sympy.Matrix, optional): 
                (n,1) Generalized position vector. Defaults to None.
            qd (sympy.Matrix, optional): 
                (n,1) Generalized velocity vector. Defaults to None.
            q2d (sympy.Matrix, optional): 
                (n,1) Generalized acceleration vector. Defaults to None.
            simplify (bool, optional): 
                Use simplify command on saved expressions. 
                Defaults to True.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.
            parallel (bool, optional): 
                Use parallel computation via multiprocessing. 
                Defaults to True.
        Raises:
            ValueError:
                Joint screw coordinates and/or reference configuration 
                of bodies not set.
                
        Returns:
            sympy.Matrix: Forward kinematics.
        &#34;&#34;&#34;
        if not q or not qd or not q2d:
            if not self.n:
                self.n = len(self.body_ref_config)
            if not self.q or not self.qd or not self.q2d:
                print(self.q, self.qd, self.q2d)
                q, qd, q2d = generalized_vectors(self.n,self._find_start_index())
            else:
                q, qd, q2d = self.q, self.qd, self.q2d
                
        self._save_vectors(q, qd, q2d, None, None, ..., ..., ...)
        self.n = len(q)
        
        # prepare ee link selection
        if self.ee_parent is None:
            self.ee_parent = [self.n]
        if type(self.ee) is not list: self.ee = [self.ee]
        if type(self.ee_parent) is not list: self.ee_parent = [self.ee_parent]
        assert(len(self.ee) == len(self.ee_parent))    
        self.n_ee = len(self.ee_parent)
        
        if parallel:
            self._closed_form_kinematics_body_fixed_parallel(
                q, qd, q2d, simplify, cse)
        else:
            self._closed_form_kinematics_body_fixed(
                q, qd, q2d, simplify, cse)
        return self.fkin

    def closed_form_inv_dyn_body_fixed(
        self, 
        q:sympy.MutableDenseMatrix=None, 
        qd: MutableDenseMatrix=None, 
        q2d: MutableDenseMatrix=None, 
        q3d: MutableDenseMatrix=None, 
        q4d: MutableDenseMatrix=None, 
        WEE: Union[MutableDenseMatrix,List[MutableDenseMatrix]]=..., 
        WDEE: Union[MutableDenseMatrix,List[MutableDenseMatrix]]=..., 
        W2DEE: Union[MutableDenseMatrix,List[MutableDenseMatrix]]=..., 
        simplify: bool=True, cse: bool=False, 
        parallel: bool=True) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Inverse dynamics using body fixed representation of the 
        twists in closed form. 

        The following expressions are saved in the class and can be 
        code generated afterwards:
            coriolis_centrifugal_matrix
            generalized_mass_inertia_matrix
            gravity_vector
            inverse_dynamics

        Args:
            q (sympy.Matrix, optional): 
                (n,1) Generalized position vector. Defaults to None.
            qd (sympy.Matrix, optional): 
                (n,1) Generalized velocity vector. Defaults to None.
            q2d (sympy.Matrix, optional): 
                (n,1) Generalized acceleration vector. Defaults to None.
            q3d (sympy.Matrix, optional): 
                (n,1) Generalized jerk vector. Defaults to None.
            q4d (sympy.Matrix, optional): 
                (n,1) Generalized jounce vector. Defaults to None.
            WEE (list | sympy.Matrix, optional): 
                (6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time varying 
                wrench on the EE link. 
                If there is more than one end-effector, you can use a 
                list containing all wrenches instead.
                Defaults to zeros(6, 1).
            WDEE (list | sympy.Matrix, optional): 
                (6,1) WDEE (t) = [dMx,dMy,dMz,dFx,dFy,dFz] is the derivative 
                of the time varying wrench on the EE link. 
                If there is more than one end-effector, you can use a 
                list containing all wrenches instead.
                Defaults to zeros(6, 1).
            W2DEE (list | sympy.Matrix, optional): 
                (6,1) W2DEE (t) = [ddMx,ddMy,ddMz,ddFx,ddFy,ddFz] is the 
                2nd derivative of the time varying wrench on the EE link. 
                If there is more than one end-effector, you can use a 
                list containing all wrenches instead.
                Defaults to zeros(6, 1).
            simplify (bool, optional): 
                Use simplify command on saved expressions. 
                Defaults to True.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.
            parallel (bool, optional): 
                Use parallel computation via multiprocessing. 
                Defaults to True.

        Raises:
            ValueError:
                Joint screw coordinates and/or reference configuration 
                of bodies not set.
        
        Returns:
            sympy.Matrix: Generalized forces
        &#34;&#34;&#34;
        if not q or not qd or not q2d:
            if not self.n:
                self.n = len(self.body_ref_config)
            if not self.q or not self.qd or not self.q2d:
                q, qd, q2d = generalized_vectors(self.n,self._find_start_index())
            else:
                q, qd, q2d, q3d, q4d = self.q, self.qd, self.q2d, self.q3d, self.q4d
        
        if WEE is Ellipsis:
            WEE = self.WEE
        if WDEE is Ellipsis:
            WDEE = self.WDEE
        if W2DEE is Ellipsis:
            W2DEE = self.W2DEE
        
        self._save_vectors(q, qd, q2d, q3d, q4d, WEE, WDEE, W2DEE)
        self.n = len(q)
        
        # prepare ee link selection
        if self.ee_parent is None:
            self.ee_parent = [self.n]
        if type(self.ee_parent) is not list: self.ee_parent = [self.ee_parent]
        self.n_ee = len(self.ee_parent)
        if self.n_ee &gt; 1:
            if type(WEE) is list and len(WEE) &gt; 1:
                assert(len(WEE) == len(self.ee_parent))
            if type(WDEE) is list and len(WDEE) &gt; 1:
                assert(len(WDEE) == len(self.ee_parent))
            if type(W2DEE) is list and len(W2DEE) &gt; 1:
                assert(len(W2DEE) == len(self.ee_parent)) 
        if type(WEE) is not list: WEE = [WEE]
        if type(WDEE) is not list: WDEE = [WDEE]
        if type(W2DEE) is not list: W2DEE = [W2DEE]
        
        if parallel:
            self._closed_form_inv_dyn_body_fixed_parallel(
                q, qd, q2d, q3d, q4d, WEE, WDEE, W2DEE, simplify, cse)
        else:
            self._closed_form_inv_dyn_body_fixed(
                q, qd, q2d, q3d, q4d, WEE, WDEE, W2DEE, simplify, cse)
        return self.Q

    def _closed_form_kinematics_body_fixed(
        self, q: MutableDenseMatrix, qd: MutableDenseMatrix, 
        q2d: MutableDenseMatrix, simplify: bool=True, 
        cse: bool=False) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Position, velocity and acceleration kinematics using 
        body fixed representation of the twists in closed form.

        The following expressions are saved in the class and can be 
        code generated afterwards:
            body_acceleration
            body_acceleration_ee
            body_jacobian_matrix
            body_jacobian_matrix_dot 
            body_jacobian_matrix_ee
            body_jacobian_matrix_ee_dot
            body_twist_ee
            forward_kinematics
            hybrid_acceleration
            hybrid_acceleration_ee
            hybrid_jacobian_matrix
            hybrid_jacobian_matrix_dot
            hybrid_jacobian_matrix_ee
            hybrid_jacobian_matrix_ee_dot
            hybrid_twist_ee

            Needs class parameters body_ref_config, joint_screw_coord 
            and ee to be defined.

        Args:
            q (sympy.Matrix): 
                (n,1) Generalized position vector.
            qd (sympy.Matrix): 
                (n,1) Generalized velocity vector.
            q2d (sympy.Matrix): 
                (n,1) Generalized acceleration vector.
            simplify (bool, optional): 
                Use simplify command on saved expressions. 
                Defaults to True.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.


        Returns:
            sympy.Matrix: Forward kinematics.
        &#34;&#34;&#34;
        print(&#34;Forward kinematics calculation&#34;)
        self.var_syms.update(q.free_symbols)
        self.var_syms.update(qd.free_symbols)
        self.var_syms.update(q2d.free_symbols)

        self.n = len(q)  # DOF

        # calc Forward kinematics
        if self.parent and self.support:
            FK_C, A = self._calc_A_matrix_tree(q)
        else:    
            FK_C, A = self._calc_A_matrix(q)
        
        fkin = [None]*self.n_ee
        for i in range(self.n_ee):
            fkin[i] = FK_C[self.ee_parent[i]-1]*self.ee[i]
            if simplify:
                fkin[i] = self.simplify(fkin[i], cse)
            elif cse:
                fkin[i] = self._cse_expression(fkin[i])    
        self.fkin = fkin if len(fkin)&gt;1 else fkin[0]
        
        if self.J is not None:
            J = self.J
            V = self._V
        else:
            # Block diagonal matrix X (6n x n) of the screw coordinate 
            # vector associated to all joints in the body frame (Constant)
            X = zeros(6*self.n, self.n)
            for i in range(self.n):
                X[6*i:6*i+6, i] = self.X[i]

            # System level Jacobian
            J = A*X
            if simplify:
                J = self.simplify(J, cse)
            elif cse:
                J = self._cse_expression(J)
            self.J = J

            # System twist (6n x 1)
            V = J*qd
            self._V = V

        R_i = [None]*self.n_ee
        R_BFn = [None]*self.n_ee
        Vb_BFn = [None]*self.n_ee
        Vh_BFn = [None]*self.n_ee
        Vb_ee = [None]*self.n_ee
        Vh_ee = [None]*self.n_ee
        Jh_ee = [None]*self.n_ee
        Jb_ee = [None]*self.n_ee
        Jh = [None]*self.n_ee
        Jb = [None]*self.n_ee
        for i in range(self.n_ee):
            # Different Jacobians
            R_i[i] = Matrix(fkin[i][:3, :3]).row_join(
                zeros(3, 1)).col_join(Matrix([0, 0, 0, 1]).T)
            if simplify:  # fastens later simplifications
                R_i[i] = self.simplify(R_i[i], cse)
            elif cse:
                R_i[i] = self._cse_expression(R_i[i])
            
            R_BFn[i] = Matrix(FK_C[self.ee_parent[i]-1][:3, :3]).row_join(
                zeros(3, 1)).col_join(Matrix([0, 0, 0, 1]).T)

            # Body fixed Jacobian of last moving body 
            # (This may not correspond to end-effector frame)
            Jb[i] = J[6*(self.ee_parent[i]-1):6*self.ee_parent[i], :] # used to be [-6:,:]
            if simplify:
                Jb[i] = self.simplify(Jb[i], cse)
            elif cse:
                Jb[i] = self._cse_expression(Jb[i])

            Vb_BFn[i] = Jb[i]*qd  # Body fixed twist of last moving body
            if simplify:
                Vb_BFn[i] = self.simplify(Vb_BFn[i], cse)
            elif cse:
                Vb_BFn[i] = self._cse_expression(Vb_BFn[i])
            Vh_BFn[i] = SE3AdjMatrix(R_BFn[i])*Vb_BFn[i]
            if simplify:
                Vh_BFn[i] = self.simplify(Vh_BFn[i], cse)
            elif cse:
                Vh_BFn[i] = self._cse_expression(Vh_BFn[i])
            
            # Body fixed twist of end-effector frame
            Vb_ee[i] = SE3AdjMatrix(SE3Inv(self.ee[i]))*Vb_BFn[i]
            if simplify:
                Vb_ee[i] = self.simplify(Vb_ee[i], cse)
            elif cse:
                Vb_ee[i] = self._cse_expression(Vb_ee[i])
            # Hybrid twist of end-effector frame
            Vh_ee[i] = SE3AdjMatrix(R_i[i])*Vb_ee[i]
            if simplify:
                Vh_ee[i] = self.simplify(Vh_ee[i], cse)
            elif cse:
                Vh_ee[i] = self._cse_expression(Vh_ee[i])

            # Body fixed Jacobian of end-effector frame
            Jb_ee[i] = SE3AdjMatrix(SE3Inv(self.ee[i]))*Jb[i]
            if simplify:
                Jb_ee[i] = self.simplify(Jb_ee[i], cse)
            elif cse:
                Jb_ee[i] = self._cse_expression(Jb_ee[i])

            # Hybrid Jacobian of end-effector frame
            Jh_ee[i] = SE3AdjMatrix(R_i[i])*Jb_ee[i]
            # Hybrid Jacobian of last moving body
            Jh[i] = SE3AdjMatrix(R_i[i])*Jb[i]  

            if simplify:
                Jh_ee[i] = self.simplify(Jh_ee[i], cse)
                Jh[i] = self.simplify(Jh[i], cse)
            elif cse:
                Jh_ee[i] = self._cse_expression(Jh_ee[i])
                Jh[i] = self._cse_expression(Jh[i])
            
        self.Vb_BFn = Vb_BFn if len(Vb_BFn)&gt;1 else Vb_BFn[0]
        self.Vh_BFn = Vh_BFn if len(Vh_BFn)&gt;1 else Vh_BFn[0]
        self.Vb_ee = Vb_ee if len(Vb_ee)&gt;1 else Vb_ee[0]
        self.Vh_ee = Vh_ee if len(Vh_ee)&gt;1 else Vh_ee[0]
        self.Jh_ee = Jh_ee if len(Jh_ee)&gt;1 else Jh_ee[0]
        self.Jb_ee = Jb_ee if len(Jb_ee)&gt;1 else Jb_ee[0]
        self.Jh = Jh if len(Jh)&gt;1 else Jh[0]
        self.Jb = Jb if len(Jb)&gt;1 else Jb[0]
        
        # Acceleration computations
        if self._a is not None:
            a = self._a
        else:
            # Block diagonal matrix a (6n x 6n)
            a = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                a[6*i:6*i+6, 6*i:6*i+6] = SE3adMatrix(self.X[i])*qd[i]
            if simplify:
                a = self.simplify(a, cse)
            elif cse:
                a = self._cse_expression(a)
            self._a = a

        # System acceleration (6n x 1)
        Jdot = -A*a*J  # Sys-level Jacobian time derivative
        if simplify:
            Jdot = self.simplify(Jdot, cse)
        elif cse:
            Jdot = self._cse_expression(Jdot)

        self.Jdot = Jdot

        Vbd = J*q2d - A*a*V

        Vbd_BFn = [None]*self.n_ee
        Vhd_BFn = [None]*self.n_ee
        Vbd_ee = [None]*self.n_ee
        Vhd_ee = [None]*self.n_ee
        Jb_dot = [None]*self.n_ee
        Jb_ee_dot = [None]*self.n_ee
        Jh_dot = [None]*self.n_ee
        Jh_ee_dot = [None]*self.n_ee
        for i in range(self.n_ee):
            # Hybrid acceleration of the last body
            Vbd_BFn[i] = Vbd[6*(self.ee_parent[i]-1):6*self.ee_parent[i], :] # used to be [-6:,:]
            if simplify:
                Vbd_BFn[i] = self.simplify(Vbd_BFn[i], cse)
            elif cse:
                Vbd_BFn[i] = self._cse_expression(Vbd_BFn[i])
            # Hybrid twist of end-effector frame 
            # TODO: check comments
            Vhd_BFn[i] = (SE3AdjMatrix(R_BFn[i])*Vbd_BFn[i] 
                    + SE3adMatrix(Matrix(Vh_BFn[i][:3, :])
                                        .col_join(Matrix([0, 0, 0])))
                    * SE3AdjMatrix(R_BFn[i])*Vb_BFn[i])  

            if simplify:
                Vhd_BFn[i] = self.simplify(Vhd_BFn[i], cse)
            elif cse:
                Vhd_BFn[i] = self._cse_expression(Vhd_BFn[i])

            # Body fixed twist of end-effector frame
            # Hybrid acceleration of the EE
            Vbd_ee[i] = SE3AdjMatrix(SE3Inv(self.ee[i]))*Vbd_BFn[i]
            if simplify:
                Vbd_ee[i] = self.simplify(Vbd_ee[i], cse)
            elif cse:
                Vbd_ee[i] = self._cse_expression(Vbd_ee[i])
            # Hybrid twist of end-effector frame
            Vhd_ee[i] = SE3AdjMatrix(R_i[i])*Vbd_ee[i] + SE3adMatrix(Matrix(
                Vh_ee[i][:3, :]).col_join(Matrix([0, 0, 0])))*\
                    SE3AdjMatrix(R_i[i])*Vb_ee[i]  
            if simplify:
                Vhd_ee[i] = self.simplify(Vhd_ee[i], cse)
            elif cse:
                Vhd_ee[i] = self._cse_expression(Vhd_ee[i])

            # Body Jacobian time derivative

            # For the last moving body
            Jb_dot[i] = Jdot[6*(self.ee_parent[i]-1):6*self.ee_parent[i], :] # used to be [-6:,:]

            # For the EE
            Jb_ee_dot[i] = SE3AdjMatrix(SE3Inv(self.ee[i]))*Jb_dot[i]
            if simplify:
                Jb_ee_dot[i] = self.simplify(Jb_ee_dot[i], cse)
            elif cse:
                Jb_ee_dot[i] = self._cse_expression(Jb_ee_dot[i])

            # Hybrid Jacobian time derivative
            # For the last moving body
            Jh_dot[i] = (SE3AdjMatrix(R_BFn[i])*Jb_dot[i] 
                    + SE3adMatrix(Matrix(Vh_BFn[i][:3, :]).col_join(Matrix([0, 0, 0])))
                    *SE3AdjMatrix(R_BFn[i])*Jb[i])
            if simplify:
                Jh_dot[i] = self.simplify(Jh_dot[i], cse)
            elif cse:
                Jh_dot[i] = self._cse_expression(Jh_dot[i])

            # For the EE
            Jh_ee_dot[i] = (SE3AdjMatrix(R_i[i])*Jb_ee_dot[i] 
                        + SE3adMatrix(Matrix(Vh_ee[i][:3, :]).col_join(Matrix([0, 0, 0])))
                        * SE3AdjMatrix(R_i[i])*Jb_ee[i])
            if simplify:
                Jh_ee_dot[i] = self.simplify(Jh_ee_dot[i], cse)
            elif cse:
                Jh_ee_dot[i] = self._cse_expression(Jh_ee_dot[i])
        
        self.Vbd_BFn = Vbd_BFn if len(Vbd_BFn)&gt;1 else Vbd_BFn[0]
        self.Vhd_BFn = Vhd_BFn if len(Vhd_BFn)&gt;1 else Vhd_BFn[0]
        self.Vbd_ee = Vbd_ee if len(Vbd_ee)&gt;1 else Vbd_ee[0]
        self.Vhd_ee = Vhd_ee if len(Vhd_ee)&gt;1 else Vhd_ee[0]
        self.Jb_dot = Jb_dot if len(Jb_dot)&gt;1 else Jb_dot[0]
        self.Jb_ee_dot = Jb_ee_dot if len(Jb_ee_dot)&gt;1 else Jb_ee_dot[0]
        self.Jh_dot = Jh_dot if len(Jh_dot)&gt;1 else Jh_dot[0]
        self.Jh_ee_dot = Jh_ee_dot if len(Jh_ee_dot)&gt;1 else Jh_ee_dot[0]

        for e in self._get_expressions():
            self.all_symbols.update(e.free_symbols)

        print(&#34;Done&#34;)
        return fkin

    def _closed_form_inv_dyn_body_fixed(self, q: MutableDenseMatrix, 
                                        qd: MutableDenseMatrix, 
                                        q2d: MutableDenseMatrix,
                                        q3d: MutableDenseMatrix=None, 
                                        q4d: MutableDenseMatrix=None, 
                                        WEE: List[MutableDenseMatrix]=[zeros(6, 1)], 
                                        WDEE: List[MutableDenseMatrix]=[zeros(6, 1)], 
                                        W2DEE: List[MutableDenseMatrix]=[zeros(6, 1)], 
                                        simplify: bool=True, 
                                        cse: bool=False) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Inverse dynamics using body fixed representation of the 
        twists in closed form. 

        The following expressions are saved in the class and can be code 
        generated afterwards:
            coriolis_centrifugal_matrix
            generalized_mass_inertia_matrix
            gravity_vector
            inverse_dynamics

        Args:
            q (sympy.Matrix): (n,1) Generalized position vector.
            qd (sympy.Matrix): (n,1 )Generalized velocity vector.
            q2d (sympy.Matrix): (n,1) Generalized acceleration vector.
            q3d (sympy.Matrix, optional): 
                (n,1) Generalized jerk vector. Defaults to None.
            q4d (sympy.Matrix, optional): 
                (n,1) Generalized jounce vector. Defaults to None.
            WEE (list of sympy.Matrix, optional): 
                (6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time varying 
                wrench on the EE link. 
                Defaults to [zeros(6, 1)].
            WDEE (list of sympy.Matrix, optional): 
                (6,1) WDEE (t) = [dMx,dMy,dMz,dFx,dFy,dFz] is the derivative 
                of the time varying wrench on the EE link. 
                Defaults to [zeros(6, 1)].
            W2DEE (list of sympy.Matrix, optional): 
                (6,1) W2DEE (t) = [ddMx,ddMy,ddMz,ddFx,ddFy,ddFz] is the 
                2nd derivative of the time varying wrench on the EE link. 
                Defaults to [zeros(6, 1)].
            simplify (bool, optional): Use simplify command 
                on saved expressions. Defaults to True.
            cse (bool, optional): Use common subexpression 
                elimination. Defaults to False.

        Returns:
            sympy.Matrix: Generalized forces
        &#34;&#34;&#34;
        print(&#34;Inverse dynamics calculation&#34;)

        self.var_syms.update(q.free_symbols)
        self.var_syms.update(qd.free_symbols)
        self.var_syms.update(q2d.free_symbols)
        if q3d: self.var_syms.update(q3d.free_symbols)
        if q4d: self.var_syms.update(q4d.free_symbols)
        for W in WEE:
            self.optional_var_syms.update(W.free_symbols)
        for WD in WDEE:
            self.optional_var_syms.update(WD.free_symbols)
        for W2D in W2DEE:
            self.optional_var_syms.update(W2D.free_symbols)

        self.n = len(q)

        # calc Forward kinematics
        if self.parent and self.support:
            FK_C, A = self._calc_A_matrix_tree(q)
        else:    
            FK_C, A = self._calc_A_matrix(q)
        
        if self.J is not None:
            J = self.J  # system level Jacobian
            V = self._V  # system twist
        else:
            # Block diagonal matrix X (6n x n) of the screw coordinate 
            # vector associated to all joints in the body frame (constant)
            X = zeros(6*self.n, self.n)
            for i in range(self.n):
                X[6*i:6*i+6, i] = self.X[i]

            # System level Jacobian
            J = A*X
            if simplify:
                J = self.simplify(J, cse)
            elif cse:
                J = self._cse_expression(J)
            self.J = J

            # System twist (6n x 1)
            V = J*qd
            self._V = V

        # Acceleration computations
        if self._a is not None:
            a = self._a
        else:
            # Block diagonal matrix a (6n x 6n)
            a = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                a[6*i:6*i+6, 6*i:6*i+6] = SE3adMatrix(self.X[i])*qd[i]
            self._a = a

        # System acceleration (6n x 1)
        Vd = J*q2d - A*a*V

        # Block Diagonal Mb (6n x 6n) Mass inertia matrix in body frame 
        # (constant)
        Mb = zeros(6*self.n, 6*self.n)
        for i in range(self.n):
            Mb[i*6:i*6+6, i*6:i*6+6] = self.Mb[i]

        # Block diagonal matrix b (6n x 6n) used in Coriolis matrix
        b = zeros(6*self.n, 6*self.n)
        for i in range(self.n):
            b[i*6:i*6+6, i*6:i*6+6] = SE3adMatrix(Matrix(V[6*i:6*i+6]))

        # Block diagonal matrix Cb (6n x 6n)
        Cb = -Mb*A*a - b.T * Mb

        # Lets setup the Equations of Motion

        # Mass inertia matrix in joint space (n x n)
        M = J.T*Mb*J
        if simplify:
            M = self.simplify(M, cse)
        elif cse:
            M = self._cse_expression(M)

        # Coriolis-Centrifugal matrix in joint space (n x n)
        C = J.T * Cb * J
        if simplify:
            C = self.simplify(C, cse)
        elif cse:
            C = self._cse_expression(C)

        # Gravity Term
        U = SE3AdjInvMatrix(FK_C[0])
        for k in range(1, self.n):
            U = U.col_join(SE3AdjInvMatrix(FK_C[k]))

        Vd_0 = zeros(6, 1)
        Vd_0[3:6, 0] = self.gravity_vector
        Qgrav = J.T*Mb*U*Vd_0
        if simplify:
            Qgrav = self.simplify(Qgrav, cse)
        elif cse:
            Qgrav = self._cse_expression(Qgrav)

        # External Wrench
        Wext = zeros(6*self.n, 1)
        # WEE (t) is the time varying wrench on the EE link.
        for i in range(self.n_ee):
            Wext[6*(self.ee_parent[i]-1):6*self.ee_parent[i], 0] = WEE[i if len(WEE) == self.n_ee else 0] # TODO: ee idx
        Qext = J.T * Wext

        # Generalized forces Q
        # Q = M*q2d + C*qd   # without gravity
        Q = M*q2d + C*qd + Qgrav + Qext

        if simplify:
            Q = self.simplify(Q, cse)
        elif cse:
            Q = self._cse_expression(Q)

        self.M = M
        self.C = C
        self.Q = Q
        self.Qgrav = Qgrav

        ##### First Order Derivatives of EOM #####
        if q3d is not None:        
            # First time derivative of Block diagonal matrix a (6n x 6n)
            ad = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                ad[i*6:i*6+6, i*6:i*6+6] = q2d[i] * SE3adMatrix(self.X[i])

            # Third order Forward Kinematics
            V2d = J*q3d - A*ad*V - 2*A*a*Vd - A*a*a*V
                        
            #  First time derivative of Block diagonal matrix b (6n x 6n) 
            # used in Coriolis matrix
            bd = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                bd[i*6:i*6+6, i*6:i*6+6] = SE3adMatrix(Matrix(Vd[i*6:i*6+6]))
            
            # First time derivative of Mass inertia matrix in joint space (n x n)
            Mbd = -Mb*A*a - (Mb*A*a).T
            Md = J.T * Mbd * J
            if simplify:
                Md = self.simplify(Md, cse)
            elif cse:
                Md = self._cse_expression(Md)
            
            # First time derivative of Coriolis-Centrifugal matrix in joint space (n x n)
            Cbd = Mb*A*a*A*a - Mb*A*a*a - Mb*A*ad - bd.T * Mb - Cb*A*a - a.T*A.T*Cb
            Cd = J.T*Cbd*J
            if simplify:
                Cd = self.simplify(Cd, cse)
            elif cse:
                Cd = self._cse_expression(Cd)
            
            # First time derivative of gravity force
            Qdgrav = J.T*Mbd*U*Vd_0
            if simplify:
                Qdgrav = self.simplify(Qdgrav, cse)
            elif cse:
                Qdgrav = self._cse_expression(Qdgrav)
            
            # First time derivative of External Wrench
            Wdext = zeros(6*self.n,1)
            for i in range(self.n_ee):
                Wdext[6*(self.ee_parent[i]-1):6*self.ee_parent[i], 0] = WDEE[i if len(WDEE) == self.n_ee else 0]
            Qdext = J.T*(Wdext - (A*a).T * Wext)
            
            # Qd = M*q3d + (Md + C)*q2d + Cd*qd  # without gravity 
            Qd = M*q3d + (Md + C)*q2d + Cd*qd + Qdgrav + Qdext # with gravity
            if simplify:
                Qd = self.simplify(Qd, cse)
            elif cse:
                Qd = self._cse_expression(Qd)
            
            self.Md = Md
            self.Cd = Cd
            self.Qdgrav = Qdgrav
            self.Qd = Qd

        ##### Second Order Derivatives of EOM #####
        if q3d is not None and q4d is not None:        
            # Second time derivative of Block diagonal matrix a (6n x 6n)
            a2d = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                a2d[i*6:i*6+6, i*6:i*6+6] = SE3adMatrix(self.X[i]) * q3d[i]
                
            # Second time derivative of Block diagonal matrix b (6n x 6n) 
            # used in Coriolis matrix
            b2d = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                b2d[i*6:i*6+6, i*6:i*6+6] = SE3adMatrix(Matrix(V2d[i*6:i*6+6]))
                
            # Second time derivative of Mass inertia matrix in joint space (n x n)
            Mb2d = (- Mb*A*ad - (Mb*A*ad).T + 2*Mb*A*a*A*a + 2*(Mb*A*a*A*a).T 
                    + 2*a.T*A.T*Mb*A*a - Mb*A*a*a - (Mb*A*a*a).T)
            M2d = J.T*Mb2d*J
            if simplify:
                M2d = self.simplify(M2d, cse)
            elif cse:
                M2d = self._cse_expression(M2d)

            # Second time derivative of Coriolis-Centrifugal matrix in joint space (n x n)
            Cddot = (- Mb*A*a2d - 3*Mb*A*a*ad - Mb*A*a*a*a - b2d.T*Mb 
                     + Mb*A*ad*A*a + Mb*A*a*a*A*a + 2*Mb*A*a*A*ad 
                     + 2*Mb*A*a*A*a*a - 2*Mb*A*a*A*a*A*a)
            Cb2d = (Cddot - (Cbd + a.T*A.T*Cb)*A*a - a.T*A.T*(Cbd + Cb*A*a) 
                    - Cb*A*ad - ad.T*A.T*Cb - Cb*A*a*a - a.T*a.T*A.T*Cb 
                    - Cbd*A*a - a.T*A.T*Cbd)
            C2d = J.T*Cb2d*J
            if simplify:
                C2d = self.simplify(C2d, cse)
            elif cse:
                C2d = self._cse_expression(C2d)
            
            # Second time derivative of gravity force
            Q2dgrav = J.T*Mb2d*U*Vd_0
            if simplify:
                Q2dgrav = self.simplify(Q2dgrav, cse)
            elif cse:
                Q2dgrav = self._cse_expression(Q2dgrav)

            # Second time derivative of External Wrench
            W2dext = zeros(6*self.n,1)
            for i in range(self.n_ee):
                W2dext[6*(self.ee_parent[i]-1):6*self.ee_parent[i], 0] = W2DEE[i if len(W2DEE) == self.n_ee else 0]
            Q2dext = J.T*(W2dext - 2*(A*a).T*Wdext + (2*(A*a*A*a).T - (A*ad).T - (A*a*a).T)*Wext)
            
            # Second time derivative of generalized forces
            # without gravity:
            # Q2d = M*q4d + (2*Md + C)*q3d + (M2d + 2*Cd)*q2d + C2d*qd   
            # with gravity and external forces:
            Q2d = M*q4d + (2*Md + C)*q3d + (M2d + 2*Cd)*q2d + C2d*qd + Q2dgrav + Q2dext
            if simplify:
                Q2d = self.simplify(Q2d, cse)
            elif cse:
                Q2d = self._cse_expression(Q2d)
            
            self.M2d = M2d
            self.C2d = C2d
            self.Q2dgrav = Q2dgrav
            self.Q2d = Q2d

        # save used symbols
        for e in self._get_expressions():
            self.all_symbols.update(e.free_symbols)

        print(&#34;Done&#34;)
        return Q

    def _closed_form_kinematics_body_fixed_parallel(
        self, q: MutableDenseMatrix, qd: MutableDenseMatrix, 
        q2d: MutableDenseMatrix, simplify: bool=True, 
        cse: bool=False) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Position, velocity and acceleration kinematics using 
        body fixed representation of the twists in closed form.

        The following expressions are saved in the class and can be 
        code generated afterwards:
            body_acceleration
            body_acceleration_ee
            body_jacobian_matrix
            body_jacobian_matrix_dot 
            body_jacobian_matrix_ee
            body_jacobian_matrix_ee_dot
            body_twist_ee
            forward_kinematics
            hybrid_acceleration
            hybrid_acceleration_ee
            hybrid_jacobian_matrix
            hybrid_jacobian_matrix_dot
            hybrid_jacobian_matrix_ee
            hybrid_jacobian_matrix_ee_dot
            hybrid_twist_ee

        Args:
            q (sympy.Matrix): 
                (n,1) Generalized position vector.
            qd (sympy.Matrix): 
                (n,1) Generalized velocity vector.
            q2d (sympy.Matrix): 
                (n,1) Generalized acceleration vector.
            simplify (bool, optional): 
                Use simplify command on saved expressions. 
                Defaults to True.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.

        Returns:
            sympy.Matrix: Forward kinematics.
        &#34;&#34;&#34;
        # This method does the same as _closed_form_kinematics_body_fixed.
        # Parallel computation is implemented by writing most values 
        # in queues, organized in a dict.
        # This ensures the correct order for the execution.
        # To understand the calculations it is recommended to read the 
        # code in _closed_form_kinematics_body_fixed since it is more 
        # readable and has the same structure.

        print(&#34;Forward kinematics calculation&#34;)
        self.var_syms.update(q.free_symbols)
        self.var_syms.update(qd.free_symbols)
        self.var_syms.update(q2d.free_symbols)

        self.n = len(q)
        self.queue_dict[&#34;subex_dict&#34;] = Queue()

        # calc Forward kinematics
        if self.parent and self.support:
            FK_C, A = self._calc_A_matrix_tree(q)
        else:    
            FK_C, A = self._calc_A_matrix(q)
        
        for i in range(self.n_ee):
            self._set_value(f&#34;fkin{i}&#34;, FK_C[self.ee_parent[i]-1]*self.ee[i])
            if simplify:
                self._start_simplification_process(f&#34;fkin{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;fkin{i}&#34;)

        if self.J is not None:
            self._set_value(&#34;J&#34;, self.J)
            self._set_value(&#34;V&#34;, self._V)
        else:
            # Block diagonal matrix X (6n x n) of the screw coordinate 
            # vector associated to all joints in the body frame (Constant)
            X = zeros(6*self.n, self.n)
            for i in range(self.n):
                X[6*i:6*i+6, i] = self.X[i]

            # System level Jacobian
            self._set_value(&#34;J&#34;, A*X)
            if simplify:
                self._start_simplification_process(&#34;J&#34;, cse)
            elif cse:
                self._start_cse_process(&#34;J&#34;)
            # System twist (6n x 1)
            self._set_value_as_process(&#34;V&#34;, lambda: self._get_value(&#34;J&#34;)*qd)

        for i in range(self.n_ee):
            # Different Jacobians
            self._set_value_as_process(
                f&#34;R_i{i}&#34;, 
                lambda: 
                    Matrix(self._get_value(f&#34;fkin{i}&#34;)[:3, :3])
                    .row_join(zeros(3, 1))
                    .col_join(Matrix([0, 0, 0, 1]).T)
                )

            if simplify:  # fastens later simplifications
                self._start_simplification_process(f&#34;R_i{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;R_i{i}&#34;)

            self._set_value(f&#34;R_BFn{i}&#34;, Matrix(FK_C[self.ee_parent[i]-1][:3, :3]).row_join(
                zeros(3, 1)).col_join(Matrix([0, 0, 0, 1]).T)) 

            # Body fixed Jacobian of last moving body 
            # (This may not correspond to end-effector frame)
            self._set_value_as_process(
                f&#34;Jb{i}&#34;, 
                lambda: self._get_value(&#34;J&#34;)[6*(self.ee_parent[i]-1):6*self.ee_parent[i], :])
            if simplify:
                self._start_simplification_process(f&#34;Jb{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Jb{i}&#34;)

            self._set_value_as_process(f&#34;Vb_BFn{i}&#34;, lambda: self._get_value(f&#34;Jb{i}&#34;)*qd)
            # Body fixed twist of last moving body
            if simplify:
                self._start_simplification_process(f&#34;Vb_BFn{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Vb_BFn{i}&#34;)

            self._set_value_as_process(f&#34;Vh_BFn{i}&#34;, lambda: SE3AdjMatrix(
                self._get_value(f&#34;R_BFn{i}&#34;))*self._get_value(f&#34;Vb_BFn{i}&#34;))
            if simplify:
                self._start_simplification_process(f&#34;Vh_BFn{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Vh_BFn{i}&#34;)

            # Body fixed twist of end-effector frame
            self._set_value_as_process(f&#34;Vb_ee{i}&#34;, lambda: SE3AdjMatrix(
                SE3Inv(self.ee[i]))*self._get_value(f&#34;Vb_BFn{i}&#34;))
            if simplify:
                self._start_simplification_process(f&#34;Vb_ee{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Vb_ee{i}&#34;)
            # Hybrid twist of end-effector frame
            self._set_value_as_process(f&#34;Vh_ee{i}&#34;, lambda: SE3AdjMatrix(
                self._get_value(f&#34;R_i{i}&#34;))*self._get_value(f&#34;Vb_ee{i}&#34;))
            if simplify:
                self._start_simplification_process(f&#34;Vh_ee{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Vh_ee{i}&#34;)

            # Body fixed Jacobian of end-effector frame
            self._set_value_as_process(f&#34;Jb_ee{i}&#34;, lambda: SE3AdjMatrix(
                SE3Inv(self.ee[i]))*self._get_value(f&#34;Jb{i}&#34;))
            if simplify:
                self._start_simplification_process(f&#34;Jb_ee{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Jb_ee{i}&#34;)

            # Hybrid Jacobian of end-effector frame
            self._set_value_as_process(f&#34;Jh_ee{i}&#34;, lambda: SE3AdjMatrix(
                self._get_value(f&#34;R_i{i}&#34;))*self._get_value(f&#34;Jb_ee{i}&#34;))
            # Hybrid Jacobian of last moving body
            self._set_value_as_process(f&#34;Jh{i}&#34;, lambda: SE3AdjMatrix(
                self._get_value(f&#34;R_i{i}&#34;))*self._get_value(f&#34;Jb{i}&#34;))

            if simplify:
                self._start_simplification_process(f&#34;Jh_ee{i}&#34;, cse)
                self._start_simplification_process(f&#34;Jh{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Jh_ee{i}&#34;)
                self._start_cse_process(f&#34;Jh{i}&#34;)

        # Acceleration computations
        if self._a is not None:
            self._set_value(&#34;a&#34;, self._a)
        else:
            # Block diagonal matrix a (6n x 6n)
            a = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                a[6*i:6*i+6, 6*i:6*i+6] = SE3adMatrix(self.X[i])*qd[i]
            self._set_value(&#34;a&#34;, a)
            if simplify:
                self._start_simplification_process(&#34;a&#34;, cse)
            elif cse:
                self._start_cse_process(&#34;a&#34;)

        # System acceleration (6n x 1)
        # System-level Jacobian time derivative
        self._set_value_as_process(
            &#34;Jdot&#34;, lambda: -A*self._get_value(&#34;a&#34;)*self._get_value(&#34;J&#34;))
        if simplify:
            self._start_simplification_process(&#34;Jdot&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Jdot&#34;)

        self._set_value_as_process(&#34;Vbd&#34;, lambda: self._get_value(
            &#34;J&#34;)*q2d - A*self._get_value(&#34;a&#34;)*self._get_value(&#34;V&#34;))

        for i in range(self.n_ee):
            # Hybrid acceleration of the last body
            self._set_value_as_process(
                f&#34;Vbd_BFn{i}&#34;, lambda: self._get_value(&#34;Vbd&#34;)[6*(self.ee_parent[i]-1):6*self.ee_parent[i], :])

            if simplify:
                self._start_simplification_process(f&#34;Vbd_BFn{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Vbd_BFn{i}&#34;)

            # Hybrid twist of end-effector frame
            self._set_value_as_process(
                f&#34;Vhd_BFn{i}&#34;, 
                lambda: 
                    SE3AdjMatrix(self._get_value(f&#34;R_BFn{i}&#34;))
                    * self._get_value(f&#34;Vbd_BFn{i}&#34;) 
                    + SE3adMatrix(Matrix(self._get_value(f&#34;Vh_BFn{i}&#34;)[:3, :])
                                    .col_join(Matrix([0, 0, 0])))
                    * SE3AdjMatrix(self._get_value(f&#34;R_BFn{i}&#34;))
                    * self._get_value(f&#34;Vb_BFn{i}&#34;)
                )

            if simplify:
                self._start_simplification_process(f&#34;Vhd_BFn{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Vhd_BFn{i}&#34;)

            # Body fixed twist of end-effector frame
            # Hybrid acceleration of the EE
            self._set_value_as_process(f&#34;Vbd_ee{i}&#34;, lambda: SE3AdjMatrix(
                SE3Inv(self.ee[i]))*self._get_value(f&#34;Vbd_BFn{i}&#34;))
            if simplify:
                self._start_simplification_process(f&#34;Vbd_ee{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Vbd_ee{i}&#34;)
            # Hybrid twist of end-effector frame
            self._set_value_as_process(
                f&#34;Vhd_ee{i}&#34;, 
                lambda: 
                    SE3AdjMatrix(self._get_value(f&#34;R_i{i}&#34;)) 
                    * self._get_value(f&#34;Vbd_ee{i}&#34;) 
                    + SE3adMatrix(Matrix(self._get_value(f&#34;Vh_ee{i}&#34;)[:3, :])
                                    .col_join(Matrix([0, 0, 0])))
                    * SE3AdjMatrix(self._get_value(f&#34;R_i{i}&#34;))
                    * self._get_value(f&#34;Vb_ee{i}&#34;)
                )  # Hybrid twist of end-effector frame

            if simplify:
                self._start_simplification_process(f&#34;Vhd_ee{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Vhd_ee{i}&#34;)

            # Body Jacobian time derivative

            # For the last moving body
            self._set_value_as_process(
                f&#34;Jb_dot{i}&#34;, lambda: self._get_value(&#34;Jdot&#34;)[6*(self.ee_parent[i]-1):6*self.ee_parent[i], :])

            # For the EE
            self._set_value_as_process(f&#34;Jb_ee_dot{i}&#34;, lambda: SE3AdjMatrix(
                SE3Inv(self.ee[i]))*self._get_value(f&#34;Jb_dot{i}&#34;))
            if simplify:
                self._start_simplification_process(f&#34;Jb_ee_dot{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Jb_ee_dot{i}&#34;)

            # Hybrid Jacobian time derivative
            # For the last moving body
            self._set_value_as_process(
                f&#34;Jh_dot{i}&#34;, 
                lambda: 
                    SE3AdjMatrix(self._get_value(f&#34;R_BFn{i}&#34;))
                    * self._get_value(f&#34;Jb_dot{i}&#34;) 
                    + SE3adMatrix(Matrix(self._get_value(f&#34;Vh_BFn{i}&#34;)[:3, :])
                                    .col_join(Matrix([0, 0, 0])))
                    * SE3AdjMatrix(self._get_value(f&#34;R_BFn{i}&#34;))
                    * self._get_value(f&#34;Jb{i}&#34;)
                )
            if simplify:
                self._start_simplification_process(f&#34;Jh_dot{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Jh_dot{i}&#34;)

            # For the EE
            self._set_value_as_process(
                f&#34;Jh_ee_dot{i}&#34;, 
                lambda: 
                    SE3AdjMatrix(self._get_value(f&#34;R_i{i}&#34;))
                    * self._get_value(f&#34;Jb_ee_dot{i}&#34;) 
                    + SE3adMatrix(Matrix(self._get_value(f&#34;Vh_ee{i}&#34;)[:3, :])
                                    .col_join(Matrix([0, 0, 0])))
                    * SE3AdjMatrix(self._get_value(f&#34;R_i{i}&#34;))
                    * self._get_value(f&#34;Jb_ee{i}&#34;)
                )
            if simplify:
                self._start_simplification_process(f&#34;Jh_ee_dot{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Jh_ee_dot{i}&#34;)
                
        self._a = self._get_value(&#34;a&#34;)
        self._V = self._get_value(&#34;V&#34;)

        # variables for Code Generation:
        self.J = self._get_value(&#34;J&#34;)
        self.Jdot = self._get_value(&#34;Jdot&#34;)
        self.fkin = [self._get_value(f&#34;fkin{i}&#34;) for i in range(self.n_ee)]
        self.Jb = [self._get_value(f&#34;Jb{i}&#34;) for i in range(self.n_ee)]
        self.Jh = [self._get_value(f&#34;Jh{i}&#34;) for i in range(self.n_ee)]
        self.Vb_ee = [self._get_value(f&#34;Vb_ee{i}&#34;) for i in range(self.n_ee)]
        self.Vh_ee = [self._get_value(f&#34;Vh_ee{i}&#34;) for i in range(self.n_ee)]
        self.Jb_ee = [self._get_value(f&#34;Jb_ee{i}&#34;) for i in range(self.n_ee)]
        self.Jh_ee = [self._get_value(f&#34;Jh_ee{i}&#34;) for i in range(self.n_ee)]
        self.Vh_BFn = [self._get_value(f&#34;Vh_BFn{i}&#34;) for i in range(self.n_ee)]
        self.Vb_BFn = [self._get_value(f&#34;Vb_BFn{i}&#34;) for i in range(self.n_ee)]
        self.Vhd_BFn = [self._get_value(f&#34;Vhd_BFn{i}&#34;) for i in range(self.n_ee)]
        self.Vbd_BFn = [self._get_value(f&#34;Vbd_BFn{i}&#34;) for i in range(self.n_ee)]
        self.Vhd_ee = [self._get_value(f&#34;Vhd_ee{i}&#34;) for i in range(self.n_ee)]
        self.Vbd_ee = [self._get_value(f&#34;Vbd_ee{i}&#34;) for i in range(self.n_ee)]
        self.Jh_dot = [self._get_value(f&#34;Jh_dot{i}&#34;) for i in range(self.n_ee)]
        self.Jb_dot = [self._get_value(f&#34;Jb_dot{i}&#34;) for i in range(self.n_ee)]
        self.Jh_ee_dot = [self._get_value(f&#34;Jh_ee_dot{i}&#34;) for i in range(self.n_ee)]
        self.Jb_ee_dot = [self._get_value(f&#34;Jb_ee_dot{i}&#34;) for i in range(self.n_ee)]

        if self.n_ee == 1:
            self.fkin = self.fkin[0] 
            self.Jb = self.Jb[0] 
            self.Jh = self.Jh[0] 
            self.Vb_ee = self.Vb_ee[0] 
            self.Vh_ee = self.Vh_ee[0] 
            self.Jb_ee = self.Jb_ee[0] 
            self.Jh_ee = self.Jh_ee[0] 
            self.Vh_BFn = self.Vh_BFn[0] 
            self.Vb_BFn = self.Vb_BFn[0] 
            self.Vhd_BFn = self.Vhd_BFn[0] 
            self.Vbd_BFn = self.Vbd_BFn[0] 
            self.Vhd_ee = self.Vhd_ee[0] 
            self.Vbd_ee = self.Vbd_ee[0] 
            self.Jh_dot = self.Jh_dot[0] 
            self.Jb_dot = self.Jb_dot[0] 
            self.Jh_ee_dot = self.Jh_ee_dot[0] 
            self.Jb_ee_dot = self.Jb_ee_dot[0] 
        
        try:
            while True:
                self.subex_dict.update(
                    self.queue_dict[&#34;subex_dict&#34;].get(timeout=0.05))
        except queue.Empty:
            pass

        # empty Queues
        for i in self.queue_dict:
            self._flush_queue(self.queue_dict[i])
        self.queue_dict = {}

        # join Processes
        for i in self.process_dict:
            self.process_dict[i].join()
        self.process_dict = {}

        # save used symbols
        for e in self._get_expressions():
            self.all_symbols.update(e.free_symbols)

        print(&#34;Done&#34;)
        return self.fkin

    def _closed_form_inv_dyn_body_fixed_parallel(
        self, 
        q: MutableDenseMatrix, 
        qd: MutableDenseMatrix, 
        q2d: MutableDenseMatrix, 
        q3d: MutableDenseMatrix, 
        q4d: MutableDenseMatrix, 
        WEE: List[MutableDenseMatrix]=[zeros(6, 1)], 
        WDEE: List[MutableDenseMatrix]=[zeros(6, 1)], 
        W2DEE: List[MutableDenseMatrix]=[zeros(6, 1)], 
        simplify: bool=True, cse: bool=False) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Inverse dynamics using body fixed representation of the 
        twists in closed form. 

        The following expressions are saved in the class and can be 
        code generated afterwards:
            coriolis_centrifugal_matrix
            generalized_mass_inertia_matrix
            gravity_vector
            inverse_dynamics

        Args:
            q (sympy.Matrix): 
                (n,1) Generalized position vector.
            qd (sympy.Matrix): 
                (n,1 )Generalized velocity vector.
            q2d (sympy.Matrix): 
                (n,1) Generalized acceleration vector.
            q3d (sympy.Matrix, optional): 
                (n,1) Generalized jerk vector. Defaults to None.
            q4d (sympy.Matrix, optional): 
                (n,1) Generalized jounce vector. Defaults to None.
            WEE (list of sympy.Matrix, optional): 
                (6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time varying 
                wrench on the EE link. 
                Defaults to [zeros(6, 1)].
            WDEE (list of sympy.Matrix, optional): 
                (6,1) WDEE (t) = [dMx,dMy,dMz,dFx,dFy,dFz] is the derivative 
                of the time varying wrench on the EE link. 
                Defaults to [zeros(6, 1)].
            W2DEE (list of sympy.Matrix, optional): 
                (6,1) W2DEE (t) = [ddMx,ddMy,ddMz,ddFx,ddFy,ddFz] is the 
                2nd derivative of the time varying wrench on the EE link. 
                Defaults to [zeros(6, 1)].
            simplify (bool, optional): 
                Use simplify command on saved expressions. 
                Defaults to True.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.

        Returns:
            sympy.Matrix: Generalized Forces
        &#34;&#34;&#34;
        # This method does the same as _closed_form_inv_dyn_body_fixed.
        # Parallel computation is implemented by writing most values 
        # in queues, organized in a dict.
        # This ensures the correct order for the execution.
        # To understand the calculations it is recommended to read the 
        # code in _closed_form_inv_dyn_body_fixed since it is more 
        # readable and has the same structure.

        print(&#34;Inverse dynamics calculation&#34;)

        self.var_syms.update(q.free_symbols)
        self.var_syms.update(qd.free_symbols)
        self.var_syms.update(q2d.free_symbols)
        if q3d: self.var_syms.update(q3d.free_symbols)
        if q4d: self.var_syms.update(q4d.free_symbols)
        for W in WEE:
            self.optional_var_syms.update(W.free_symbols)
        for WD in WDEE:
            self.optional_var_syms.update(WD.free_symbols)
        for W2D in W2DEE:
            self.optional_var_syms.update(W2D.free_symbols)
        
        self.n = len(q)
        self.queue_dict[&#34;subex_dict&#34;] = Queue()

        # calc Forward kinematics
        if self.parent and self.support:
            FK_C, A = self._calc_A_matrix_tree(q)
        else:    
            FK_C, A = self._calc_A_matrix(q)
        
        if self.J is not None:
            self._set_value(&#34;J&#34;, self.J)
            self._set_value(&#34;V&#34;, self._V)
        else:
            # Block diagonal matrix X (6n x n) of the screw coordinate 
            # vector associated to all joints in the body frame (Constant)
            X = zeros(6*self.n, self.n)
            for i in range(self.n):
                X[6*i:6*i+6, i] = self.X[i]

            # System level Jacobian
            self._set_value(&#34;J&#34;, A*X)
            if simplify:
                self._start_simplification_process(&#34;J&#34;, cse)
            elif cse:
                self._start_cse_process(&#34;J&#34;)

            # System twist (6n x 1)
            self._set_value_as_process(&#34;V&#34;, lambda: self._get_value(&#34;J&#34;)*qd)

        # Acceleration computations

        if self._a is not None:
            a = self._a
        else:
            # Block diagonal matrix a (6n x 6n)
            a = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                a[6*i:6*i+6, 6*i:6*i+6] = SE3adMatrix(self.X[i])*qd[i]
            self._a = a

        # System acceleration (6n x 1)
        # Vd = J*q2d - A*a*V
        self._set_value_as_process(&#34;Vd&#34;, lambda: self._get_value(
            &#34;J&#34;)*q2d - A*a*self._get_value(&#34;V&#34;))

        # Block Diagonal Mb (6n x 6n) Mass inertia matrix in body frame 
        # (Constant)
        Mb = zeros(6*self.n, 6*self.n)
        for i in range(self.n):
            Mb[i*6:i*6+6, i*6:i*6+6] = self.Mb[i]

        # Block diagonal matrix b (6n x 6n) used in Coriolis matrix
        def _b():
            nonlocal self
            b = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                b[i*6:i*6+6, i*6:i*6 + 6] = SE3adMatrix(
                    Matrix(self._get_value(&#34;V&#34;)[6*i:6*i+6]))
            return b
        self._set_value_as_process(&#34;b&#34;, _b)

        # Block diagonal matrix Cb (6n x 6n)
        self._set_value_as_process(
            &#34;Cb&#34;, lambda: -Mb*A*a - self._get_value(&#34;b&#34;).T * Mb)

        # Lets setup the Equations of Motion

        # Mass inertia matrix in joint space (n x n)
        self._set_value_as_process(
            &#34;M&#34;, lambda: self._get_value(&#34;J&#34;).T*Mb*self._get_value(&#34;J&#34;))
        if simplify:
            self._start_simplification_process(&#34;M&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;M&#34;)

        # Coriolis-Centrifugal matrix in joint space (n x n)
        self._set_value_as_process(&#34;C&#34;, lambda: self._get_value(
            &#34;J&#34;).T*self._get_value(&#34;Cb&#34;)*self._get_value(&#34;J&#34;))
        if simplify:
            self._start_simplification_process(&#34;C&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;C&#34;)

        # Gravity Term
        U = SE3AdjInvMatrix(FK_C[0])
        for k in range(1, self.n):
            U = U.col_join(SE3AdjInvMatrix(FK_C[k]))

        Vd_0 = zeros(6, 1)
        Vd_0[3:6, 0] = self.gravity_vector
        self._set_value_as_process(
            &#34;Qgrav&#34;, lambda: self._get_value(&#34;J&#34;).T*Mb*U*Vd_0)
        if simplify:
            self._start_simplification_process(&#34;Qgrav&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Qgrav&#34;)

        # External Wrench
        Wext = zeros(6*self.n, 1)
        # WEE (t) is the time varying wrench on the EE link.
        for i in range(self.n_ee):
                Wext[6*(self.ee_parent[i]-1):6*self.ee_parent[i], 0] = WEE[i if len(WEE) == self.n_ee else 0]
        self._set_value_as_process(
            &#34;Qext&#34;, lambda: self._get_value(&#34;J&#34;).T * Wext)

        # Generalized forces Q
        self._set_value_as_process(
            &#34;Q&#34;, 
            lambda: 
                self._get_value(&#34;M&#34;) * q2d 
                + self._get_value(&#34;C&#34;) * qd 
                + self._get_value(&#34;Qgrav&#34;) 
                + self._get_value(&#34;Qext&#34;)
            )

        if simplify:
            self._start_simplification_process(&#34;Q&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Q&#34;)

        ##### First Order Derivatives of EOM #####
        if q3d is not None:
            # First time derivative of Block diagonal matrix a (6n x 6n)
            ad = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                ad[i*6:i*6+6, i*6:i*6+6] = q2d[i] * SE3adMatrix(self.X[i])

            # Third order Forward Kinematics
            self._set_value_as_process(
                &#34;V2d&#34;, 
                lambda: self._get_value(&#34;J&#34;)*q3d - A*ad*self._get_value(&#34;V&#34;)
                - 2*A*a*self._get_value(&#34;Vd&#34;) - A*a*a*self._get_value(&#34;V&#34;))
                        
            #  First time derivative of Block diagonal matrix b (6n x 6n) 
            # used in Coriolis matrix
            def _bd():
                nonlocal self
                bd = zeros(6*self.n, 6*self.n)
                for i in range(self.n):
                    bd[i*6:i*6+6, i*6:i*6+6] = SE3adMatrix(Matrix(self._get_value(&#34;Vd&#34;)[i*6:i*6+6]))
                return bd
            self._set_value_as_process(&#34;bd&#34;, _bd)
            
            # First time derivative of Mass inertia matrix in joint space (n x n)
            Mbd = -Mb*A*a - (Mb*A*a).T
            self._set_value_as_process(
                &#34;Md&#34;,
                lambda: self._get_value(&#34;J&#34;).T * Mbd * self._get_value(&#34;J&#34;))
            if simplify:
                self._start_simplification_process(&#34;Md&#34;,cse)
            elif cse:
                self._start_cse_process(&#34;Md&#34;)
            
            # First time derivative of Coriolis-Centrifugal matrix in joint space (n x n)
            self._set_value_as_process(
                &#34;Cbd&#34;,
                lambda: Mb*A*a*A*a - Mb*A*a*a - Mb*A*ad - self._get_value(&#34;bd&#34;).T * Mb 
                        - self._get_value(&#34;Cb&#34;)*A*a - a.T*A.T*self._get_value(&#34;Cb&#34;))
            self._set_value_as_process(
                &#34;Cd&#34;, 
                lambda: self._get_value(&#34;J&#34;).T*self._get_value(&#34;Cbd&#34;)*self._get_value(&#34;J&#34;))
            if simplify:
                self._start_simplification_process(&#34;Cd&#34;,cse)
            elif cse:
                self._start_cse_process(&#34;Cd&#34;)
            
            # First time derivative of gravity force
            self._set_value_as_process(
                &#34;Qdgrav&#34;,
                lambda: self._get_value(&#34;J&#34;).T*Mbd*U*Vd_0)
            if simplify:
                self._start_simplification_process(&#34;Qdgrav&#34;,cse)
            elif cse:
                self._start_cse_process(&#34;Qdgrav&#34;)
            
            # First time derivative of External Wrench
            Wdext = zeros(6*self.n,1)
            for i in range(self.n_ee):
                Wdext[6*(self.ee_parent[i]-1):6*self.ee_parent[i], 0] = WDEE[i if len(WDEE) == self.n_ee else 0]
            self._set_value_as_process(
                &#34;Qdext&#34;,
                lambda: self._get_value(&#34;J&#34;).T*(Wdext - (A*a).T * Wext))
            
            self._set_value_as_process(
                &#34;Qd&#34;,
                lambda: self._get_value(&#34;M&#34;)*q3d 
                        + (self._get_value(&#34;Md&#34;) + self._get_value(&#34;C&#34;))*q2d 
                        + self._get_value(&#34;Cd&#34;)*qd + self._get_value(&#34;Qdgrav&#34;) 
                        + self._get_value(&#34;Qdext&#34;)
            )
            if simplify:
                self._start_simplification_process(&#34;Qd&#34;,cse)
            elif cse:
                self._start_cse_process(&#34;Qd&#34;)
            
        ##### Second Order Derivatives of EOM #####
        if q3d is not None and q4d is not None:        
            # Second time derivative of Block diagonal matrix a (6n x 6n)
            a2d = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                a2d[i*6:i*6+6, i*6:i*6+6] = SE3adMatrix(self.X[i]) * q3d[i]
                
            # Second time derivative of Block diagonal matrix b (6n x 6n) 
            # used in Coriolis matrix
            def _b2d():
                nonlocal self
                b2d = zeros(6*self.n, 6*self.n)
                for i in range(self.n):
                    b2d[i*6:i*6+6, i*6:i*6+6] = SE3adMatrix(
                        Matrix(self._get_value(&#34;V2d&#34;)[i*6:i*6+6]))
                return b2d
            self._set_value_as_process(&#34;b2d&#34;, _b2d)
                
            # Second time derivative of Mass inertia matrix in joint space (n x n)
            Mb2d = (- Mb*A*ad - (Mb*A*ad).T + 2*Mb*A*a*A*a + 2*(Mb*A*a*A*a).T 
                    + 2*a.T*A.T*Mb*A*a - Mb*A*a*a - (Mb*A*a*a).T)
            self._set_value_as_process(
                &#34;M2d&#34;,
                lambda: self._get_value(&#34;J&#34;).T*Mb2d*self._get_value(&#34;J&#34;))
            if simplify:
                self._start_simplification_process(&#34;M2d&#34;,cse)
            elif cse:
                self._start_cse_process(&#34;M2d&#34;)

            # Second time derivative of Coriolis-Centrifugal matrix in joint space (n x n)
            self._set_value_as_process(
                &#34;Cddot&#34;,
                lambda: - Mb*A*a2d - 3*Mb*A*a*ad - Mb*A*a*a*a 
                        - self._get_value(&#34;b2d&#34;).T*Mb 
                        + Mb*A*ad*A*a + Mb*A*a*a*A*a + 2*Mb*A*a*A*ad 
                        + 2*Mb*A*a*A*a*a - 2*Mb*A*a*A*a*A*a
            )
            self._set_value_as_process(
                &#34;Cb2d&#34;,
                lambda: self._get_value(&#34;Cddot&#34;) 
                        - (self._get_value(&#34;Cbd&#34;) + a.T*A.T*self._get_value(&#34;Cb&#34;))*A*a 
                        - a.T*A.T*(self._get_value(&#34;Cbd&#34;) + self._get_value(&#34;Cb&#34;)*A*a) 
                        - self._get_value(&#34;Cb&#34;)*A*ad - ad.T*A.T*self._get_value(&#34;Cb&#34;) 
                        - self._get_value(&#34;Cb&#34;)*A*a*a - a.T*a.T*A.T*self._get_value(&#34;Cb&#34;) 
                        - self._get_value(&#34;Cbd&#34;)*A*a - a.T*A.T*self._get_value(&#34;Cbd&#34;)
            )
            self._set_value_as_process(
                &#34;C2d&#34;,
                lambda: self._get_value(&#34;J&#34;).T*self._get_value(&#34;Cb2d&#34;)*self._get_value(&#34;J&#34;)
            )
            if simplify:
                self._start_simplification_process(&#34;C2d&#34;, cse)
            elif cse:
                self._start_cse_process(&#34;C2d&#34;)
            
            # Second time derivative of gravity force
            self._set_value_as_process(
                &#34;Q2dgrav&#34;,
                lambda: self._get_value(&#34;J&#34;).T*Mb2d*U*Vd_0
            )
            if simplify:
                self._start_simplification_process(&#34;Q2dgrav&#34;,cse)
            elif cse:
                self._start_cse_process(&#34;Q2dgrav&#34;)

            # Second time derivative of External Wrench
            W2dext = zeros(6*self.n,1)
            for i in range(self.n_ee):
                W2dext[6*(self.ee_parent[i]-1):6*self.ee_parent[i], 0] = W2DEE[i if len(W2DEE) == self.n_ee else 0]
            self._set_value_as_process(
                &#34;Q2dext&#34;,
                lambda: self._get_value(&#34;J&#34;).T
                        * (W2dext - 2*(A*a).T*Wdext + (2*(A*a*A*a).T - (A*ad).T - (A*a*a).T)*Wext) 
            )
            
            # Second time derivative of generalized forces
            # with gravity and external forces:
            self._set_value_as_process(
                &#34;Q2d&#34;,
                lambda: self._get_value(&#34;M&#34;)*q4d 
                        + (2*self._get_value(&#34;Md&#34;) + self._get_value(&#34;C&#34;))*q3d 
                        + (self._get_value(&#34;M2d&#34;) + 2*self._get_value(&#34;Cd&#34;))*q2d 
                        + self._get_value(&#34;C2d&#34;)*qd 
                        + self._get_value(&#34;Q2dgrav&#34;) 
                        + self._get_value(&#34;Q2dext&#34;) 
            )
            if simplify:
                self._start_simplification_process(&#34;Q2d&#34;,cse)
            elif cse:
                self._start_cse_process(&#34;Q2d&#34;)
                Q2d = self._cse_expression(Q2d)
            

        self._V = self._get_value(&#34;V&#34;)
        self.J = self._get_value(&#34;J&#34;)
        self.M = self._get_value(&#34;M&#34;)
        self.C = self._get_value(&#34;C&#34;)
        self.Qgrav = self._get_value(&#34;Qgrav&#34;)
        self.Q = self._get_value(&#34;Q&#34;)
        if q3d is not None:
            self.Md = self._get_value(&#34;Md&#34;)
            self.Cd = self._get_value(&#34;Cd&#34;)
            self.Qdgrav = self._get_value(&#34;Qdgrav&#34;)
            self.Qd = self._get_value(&#34;Qd&#34;)
        if q3d is not None and q4d is not None:
            self.M2d = self._get_value(&#34;M2d&#34;)
            self.C2d = self._get_value(&#34;C2d&#34;)
            self.Q2dgrav = self._get_value(&#34;Q2dgrav&#34;)
            self.Q2d = self._get_value(&#34;Q2d&#34;)

        try:
            while True:
                self.subex_dict.update(
                    self.queue_dict[&#34;subex_dict&#34;].get(timeout=0.05))
        except queue.Empty:
            pass

        # empty Queues
        for i in self.queue_dict:
            self._flush_queue(self.queue_dict[i])
        self.queue_dict = {}

        # join Processes
        for i in self.process_dict:
            self.process_dict[i].join()
        self.process_dict = {}

        # save used symbols
        for e in self._get_expressions():
            self.all_symbols.update(e.free_symbols)

        print(&#34;Done&#34;)
        return self.Q

    def partial_factor(self, exp: sympy.Expr) -&gt; sympy.Expr:
        &#34;&#34;&#34;Partial factor simplification for sympy expression.

        Args:
            exp (sympy.Expr): sympy expression.

        Returns:
            sympy.Expr: modified sympy expression.
        &#34;&#34;&#34;
        # split up matrices
        if (type(exp) == sympy.matrices.immutable.ImmutableDenseMatrix
            or type(exp) == sympy.matrices.dense.MutableDenseMatrix):
            new_expr = zeros(*exp.shape)
            for i in range(exp.shape[0]):
                for j in range(exp.shape[1]):
                    new_expr[i,j] = self.partial_factor(exp[i,j])
            return new_expr
            
        # seach for factors
        factor_map = defaultdict(set)
        const, additive_terms = exp.as_coeff_add()
        for term1, term2 in combinations(additive_terms, 2):
            common_terms = (
                set(term1.as_coeff_mul()[-1])
                &amp; set(term2.as_coeff_mul()[-1])
            )
            if common_terms:
                common_factor = sympy.Mul(*common_terms)
                factor_map[common_factor] |= {term1, term2}
        
        # sort by number of operations represented by the terms
        factor_list = sorted(
            factor_map.items(),
            key = lambda i: (i[0].count_ops() + 1) * len(i[1])
        )[::-1]

        # rebuild expression
        used = set()
        new_expr = nsimplify(0)
        for item in factor_list:
            factor = item[0]
            appearances = item[-1]
            terms = 0
            for instance in appearances:
                if instance not in used:
                    terms += instance.as_coefficient(factor)
                    used.add(instance)
            new_expr += factor * terms
        for term in set(additive_terms) - used:
            new_expr += term
        return new_expr + const

    def simplify(self, exp: sympy.Expr, cse: bool=False) -&gt; sympy.Expr:
        &#34;&#34;&#34;Faster simplify implementation for sympy expressions.
        Expressions can be different simplified as with sympy.simplify.

        Args:
            exp (sympy expression): 
                Expression to simplify.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.

        Returns:
            sympy expression: Simplified expression.
        &#34;&#34;&#34;
        if cse:
            exp = self._cse_expression(exp)
        if (type(exp) == sympy.matrices.immutable.ImmutableDenseMatrix
                or type(exp) == sympy.matrices.dense.MutableDenseMatrix):
            # fasten simplification of symmetric matrices
            if exp.is_square:
                # test if matrix is symmetric
                # numeric test is faster than is_symmetric method  for 
                # long expressions
                
                # create matrix with randon values
                num = lambdify(list(exp.free_symbols), exp, &#34;numpy&#34;)(
                    *(random.random() for i in exp.free_symbols))
                # if (random) matrix is symmetric, we have to simplify 
                # less values
                if numpy.allclose(num, num.T):
                    shape = exp.shape
                    m_exp = exp.as_mutable()
                    # simplify values only once in symmetric matrices
                    for i in range(shape[0]):
                        for j in range(i):
                            m_exp[i, j] = self.simplify(exp[i, j])
                            if i != j:
                                m_exp[j, i] = exp[j, i]
                    return Matrix(m_exp)
        if type(exp) == sympy.matrices.dense.MutableDenseMatrix:
            exp = exp.as_immutable()
        exp = fu(exp)  # fast function to simplify sin and cos expressions
        exp = cancel(exp)
        exp = factor(exp)
        exp = powsimp(exp)
        exp = self.partial_factor(exp)
        exp = exp.doit()
        return exp

    def _create_topology_lists(self,robot: URDF) -&gt; None:
        &#34;&#34;&#34;Generate parent, support and child list from URDF.

        Args:
            robot (URDF): URDF of robot.
        &#34;&#34;&#34;
        # names of all links in urdf
        link_names = [link.name for link in robot.links] 
        parent_names = [] # names of parent links corresponding link_names
        connection_type = [] # 0 for fixed, None for base, 1 else
        body_index = [] # index of link; -1 for fixed links
        parent = [] # parent array
        child = [] # child array
        support = [] # support array
        # find parent link names and search for fixed joints
        for name in link_names:
            for joint in robot.joints:
                if joint.child == name:
                    parent_names.append(joint.parent)
                    body_index.append(None) # specify later
                    if joint.joint_type == &#34;fixed&#34;:
                        connection_type.append(0)
                    else:
                        connection_type.append(1)
                    break
            else: # base link
                parent_names.append(None)
                connection_type.append(None)
                body_index.append(0)

        # generate body indices concatenating fixed bodies
        while None in body_index:
            i1 = body_index.index(None) # i of current link
            # update until parent is already specified
            while body_index[link_names.index(parent_names[i1])] is None:
                i1 = link_names.index(parent_names[i1])
            # fixed links get index -1
            if connection_type[i1] == 0:
                body_index[i1] = -1
                continue
            i2 = link_names.index(parent_names[i1]) # i of parent link
            while body_index[i2] == -1: # find forst non fixed parent
                i2 = link_names.index(parent_names[i2])
            index = body_index[i2]+1 # body index
            while index in body_index: # find first unused index
                index+=1
            body_index[i1] = index
            
        parent = [None for _ in range(max(body_index))] 
        child = [[] for _ in range(max(body_index))]
        support = [[] for _ in range(max(body_index))]

        # fill parent, child and support array
        for i in range(len(body_index)):
            idx = body_index[i] # get index of current body
            if idx &lt;= 0: # ignore base and fixed bodys
                continue
            i1 = link_names.index(parent_names[i]) # parent index
            while body_index[i1] == -1: # find first non fixed parent
                i1 = link_names.index(parent_names[i1])
            parent[idx-1] = body_index[i1] # save parent index
            if body_index[i1] &gt; 0: # ignore base
                child[body_index[i1]-1].append(idx) # save child to parent
            i2 = i
            while body_index[i2] != 0: # save all indices in support path
                if  body_index[i2] &gt; 0: # ignore fixed links
                    support[idx-1].append(body_index[i2])
                i2 = link_names.index(parent_names[i2])
            support[idx-1].reverse()
        self.support = support
        self.child = child
        self.parent = parent
            
    def _nsimplify(
        self,num: float, *args, max_denominator: int=0, **kwargs
        ) -&gt; Union[sympy.Expr, float]:
        &#34;&#34;&#34;Find a simple sympy representation for a number like 1/2 
        instead of 0.5. This function extends sympy.nsimplify with a 
        parameter to specify a maximum denominator to avoid simplifications
        like 13/157.  

        Args:
            num (float): number to simplify.
            max_denominator (int, optional): 
                maximum denominator to use. Use 0 to deactivate. 
                Defaults to 0.

        Returns:
            Union[sympy.Expr, float]: simplified number.
        &#34;&#34;&#34;
        ex = nsimplify(num,*args,**kwargs)
        if not max_denominator:
            return ex
        if ex.is_rational:
            try:
                d = ex.denominator
                if d &gt; max_denominator:
                    return num
            except ValueError:
                return ex
        elif type(ex) in {sympy.core.add.Add, sympy.core.power.Pow}:
            return num
        for i in regex.findall(&#34;(?&lt;=Rational\(\d*, )\d*&#34;, sympy.srepr(ex)):
            if abs(int(i)) &gt; max_denominator:
                return num
        return ex
        
    def load_from_urdf(self, path: str, symbolic: bool=True, 
                       cse: bool=False, simplify_numbers: bool=True,  
                       tolerance: float=0.0001, max_denominator: int=9) -&gt; None:
        &#34;&#34;&#34;Load robot from urdf.

        Args:
            path (str): path to URDF.
            symbolic (bool, optional): 
                generate symbols for numeric values. 
                Defaults to True.
            cse (bool, optional): 
                use common subexpression elimination. Defaults to False.
            simplify_numbers (bool, optional): 
                Use eg. pi/2 instead of 1.5708. Defaults to True.
            tolerance (float, optional): 
                tolerance for simplify_numbers. Defaults to 0.0001.
            max_denominator (int, optional): 
                Maximum denominator to use for simplify numbers to avoid
                values like 13/153. Use 0 to deactivate. Defaults to 9.

        Raises:
            NotImplementedError: supports only the joint types 
                &#34;revolute&#34;, &#34;continuous&#34; and &#34;prismatic&#34;.
        &#34;&#34;&#34;        
        with open(path, &#34;r&#34;) as f:
            robot = URDF.from_xml_string(f.read())
        self.B = []
        self.X = []
        self._create_topology_lists(robot) # TODO: check!
        fixed_origin = None
        fixed_links = []
        DOF = 0
        xyz_rpy_syms = []
        for joint in robot.joints:
            if joint.joint_type in [&#34;revolute&#34;, &#34;continuous&#34;, &#34;prismatic&#34;]:
                DOF += 1
            elif joint.joint_type in [&#34;fixed&#34;]:
                pass
            else:
                raise NotImplementedError(
                    &#34;Joint type &#39;&#34; + joint.joint_type+&#34;&#39; not implemented yet!&#34;)

        ji = 0  # joint index of used joints
        jia = 0  # joint index of all joints (fixed included)
        joint_origins = []
        for joint in robot.joints:
            name = joint.name
            origin = xyz_rpy_to_matrix(joint.origin.xyz+joint.origin.rpy)
            if symbolic:
                xyz_rpy = Matrix(joint.origin.xyz+joint.origin.rpy)
                xyz_rpy_syms.append(symbols(
                    &#34; &#34;.join([name+&#34;_%s&#34; % s for s in [&#34;x&#34;, &#34;y&#34;, &#34;z&#34;, &#34;roll&#34;, &#34;pitch&#34;, &#34;yar&#34;]])))
                xyzrpylist = []
                if simplify_numbers:
                    for i in range(6):
                        if (self._nsimplify(xyz_rpy[i], 
                                           tolerance=tolerance, 
                                           max_denominator=max_denominator) 
                            in [0, -1, 1, pi, -pi, pi/2, -pi/2, 3*pi/2, -3*pi/2]
                            ):
                            xyzrpylist.append(
                                self._nsimplify(xyz_rpy[i], tolerance=tolerance,
                                                max_denominator=max_denominator))
                        else:
                            xyzrpylist.append(xyz_rpy_syms[jia][i])
                            self.assignment_dict[xyz_rpy_syms[jia]
                                                 [i]] = xyz_rpy[i]
                else:
                    for i in range(6):
                        if xyz_rpy[i] == 0:
                            xyzrpylist.append(0)
                        elif xyz_rpy[i] == 1:
                            xyzrpylist.append(1)
                        elif xyz_rpy[i] == -1:
                            xyzrpylist.append(-1)
                        else:
                            xyzrpylist.append(xyz_rpy_syms[jia][i])
                            self.assignment_dict[xyz_rpy_syms[jia]
                                                 [i]] = xyz_rpy[i]
                origin = xyz_rpy_to_matrix(xyzrpylist)
                if cse:
                    origin = self._cse_expression(origin)
            elif simplify_numbers:
                for i in range(4):
                    for j in range(4):
                        origin[i, j] = self._nsimplify(
                            origin[i, j], [pi], tolerance=tolerance,
                            max_denominator=max_denominator)
            joint_origins.append(origin)
            if joint.joint_type in [&#34;revolute&#34;, &#34;continuous&#34;, &#34;prismatic&#34;]:
                axis = Matrix(joint.axis)
                if simplify_numbers:
                    for i in range(3):
                        axis[i] = self._nsimplify(axis[i], [pi], tolerance=tolerance,
                                            max_denominator=max_denominator)
                if fixed_origin:
                    origin *= fixed_origin
                    fixed_origin = None
                self.B.append(Matrix(origin))

                if joint.joint_type in [&#34;revolute&#34;, &#34;continuous&#34;]:
                    self.X.append(Matrix(axis).col_join(Matrix([0, 0, 0])))
                else:
                    self.X.append(Matrix(Matrix([0, 0, 0])).col_join(axis))
                ji += 1
            elif joint.joint_type == &#34;fixed&#34;:
                if fixed_origin:
                    fixed_origin *= origin
                else:
                    fixed_origin = origin
                fixed_links.append((joint.parent, joint.child))
            jia += 1

        self.Mb = []
        i = 0
        first_non_fixed = 1
        for link in robot.links:
            name = link.name
            # ignore base link
            if i &lt; first_non_fixed:
                if name in [x[1] for x in fixed_links]:
                    first_non_fixed += 1
                i += 1
                continue
            inertia = Matrix(link.inertial.inertia.to_matrix())
            mass = link.inertial.mass
            inertiaorigin = xyz_rpy_to_matrix(link.inertial.origin.xyz+link.inertial.origin.rpy)
            if symbolic:
                I_syms = symbols(&#34;Ixx_%s Ixy_%s Ixz_%s Iyy_%s Iyz_%s Izz_%s&#34; % (
                    name, name, name, name, name, name))
                c_syms = symbols(&#34;cx_%s cy_%s cz_%s&#34; % (name, name, name))
                I = inertia_matrix(*I_syms)
                m = symbols(&#34;m_%s&#34; % name)
                cg = Matrix([*c_syms])
            else:
                if simplify_numbers:
                    for i in range(4):
                        for j in range(4):
                            inertiaorigin[i, j] = self._nsimplify(
                                inertiaorigin[i, j], [pi], tolerance=tolerance,
                                max_denominator=max_denominator)
                    for i in range(3):
                        for j in range(3):
                            inertia[i, j] = self._nsimplify(
                                inertia[i, j], [pi], tolerance=tolerance,
                                max_denominator=max_denominator)
                I = Matrix(inertia)
                m = mass
                cg = Matrix(inertiaorigin[0:3, 3])
            M = mass_matrix_mixed_data(m, I, cg)
            if name in [x[1] for x in fixed_links]:
                j = i
                # transform Mass matrix
                while robot.links[j].name in [x[1] for x in fixed_links]:
                    M = SE3AdjInvMatrix(
                        joint_origins[j-1]).T * M * SE3AdjInvMatrix(joint_origins[j-1])
                    j -= 1
                self.Mb[-1] += M
                i += 1
                continue
            self.Mb.append(M)
            i += 1
        return

    def dh_to_screw_coord(self, DH_param_table: MutableDenseMatrix) -&gt; None:
        &#34;&#34;&#34;Build screw coordinate paramters (joint axis frames and 
        body reference frames) from a given modified Denavit-Hartenberg 
        (DH) parameter table.
        Joint screw coordinates and reference configurations of bodies 
        are directly applied to class.

        Args:
            DH_param_table (array_like): 
                Table with modified DH parameters (n,5) 
                -&gt; (gamma,alpha,d,theta,r)
        &#34;&#34;&#34;
        number_of_frames = DH_param_table.shape[0]
        self.B = []
        self.X = []
        for i in range(number_of_frames):
            # Reference configurations of bodies (i.e. of body-fixed 
            # reference frames) w.r.t their previous bodies
            # gamma, alpha, d, theta,r
            frame = DH_param_table[i, :]
            gamma = frame[0]
            alpha = frame[1]
            d = frame[2]
            theta = frame[3]
            r = frame[4]
            self.B.append(SO3Exp(Matrix([1, 0, 0]), alpha)
                          .row_join(Matrix([d, 0, 0]))
                          .col_join(Matrix([0, 0, 0, 1]).T)
                          * SO3Exp(Matrix([0, 0, 1]), theta)
                          .row_join(Matrix([0, 0, r]))
                          .col_join(Matrix([0, 0, 0, 1]).T)
                          )

            #  Joint screw coordinates in body-fixed representation
            if gamma == 0:
                self.X.append(Matrix([0, 0, 1, 0, 0, 0]))
            else:
                self.X.append(Matrix([0, 0, 0, 0, 0, 1]))

    def _set_value_as_process(self, name: str, target: Callable) -&gt; None:
        &#34;&#34;&#34;Set return value of target as value to queue in 
        self.queue_dict with identifier name.

        Args:
            name (str): Identifier.
            target (function): function, which returns value. 
        &#34;&#34;&#34;
        if name not in self.queue_dict:
            self.queue_dict[name] = Queue()
        if name in self.process_dict:
            print(&#34;already there&#34;)
        self.process_dict[name] = Process(
            target=lambda: self._set_value(name, target()), args=(), name=name)
        self.process_dict[name].start()

    def _set_value(self, name: str, var: Any) -&gt; None:
        &#34;&#34;&#34;Set value to queue in self.queue_dict.

        Args:
            name (str): Identifier.
            var (any): Value to save.
        &#34;&#34;&#34;
        if name not in self.queue_dict:
            self.queue_dict[name] = Queue()
        self.queue_dict[name].put(var)

    def _start_simplification_process(
        self, name: str, cse: bool=False) -&gt; None:
        &#34;&#34;&#34;Start Process, which simplifies and overwrites value in 
        queue from self.queue_dict.

        Args:
            name (str): Identifier
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.
        &#34;&#34;&#34;
        if name not in self.queue_dict:
            self.queue_dict[name] = Queue()
        self.process_dict[name+&#34;_simplify&#34;] = Process(
            target=self._simplify_parallel, 
            args=(name, cse,), 
            name=name+&#34;_simplify&#34;)
        self.process_dict[name+&#34;_simplify&#34;].start()

    def _start_cse_process(self, name: str) -&gt; None:
        &#34;&#34;&#34;Start Process, which generates cse expression and overwrites value in 
        queue from self.queue_dict.

        Args:
            name (str): Identifier
        &#34;&#34;&#34;
        if name not in self.queue_dict:
            self.queue_dict[name] = Queue()
        self.process_dict[name+&#34;_cse&#34;] = Process(
            target=self._cse_parallel, 
            args=(name,), 
            name=name+&#34;_cse&#34;)
        self.process_dict[name+&#34;_cse&#34;].start()

    def _get_value(self, name: str) -&gt; Any:
        &#34;&#34;&#34;Get value from queue in self.queue_dict and put it in again.

        Args:
            name (str): Identifier.

        Returns:
            any: Value
        &#34;&#34;&#34;
        value = self.queue_dict[name].get()
        self.queue_dict[name].put(value)
        return value

    def _simplify_parallel(self, name: str, cse: bool=False) -&gt; None:
        &#34;&#34;&#34;Take value from self.queue_dict, simplify it and put it in 
        again.

        Args:
            name (str): Identifier
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.
        &#34;&#34;&#34;
        value = self.simplify(self.queue_dict[name].get(), cse)
        self.queue_dict[name].put(value)
        
    def _cse_parallel(self, name: str) -&gt; None:
        &#34;&#34;&#34;Take value from self.queue_dict, generate cse_expressions and 
        put it in again.

        Args:
            name (str): Identifier
        &#34;&#34;&#34;
        value = self._cse_expression(self.queue_dict[name].get())
        self.queue_dict[name].put(value)

    def _flush_queue(self, q: Queue) -&gt; None:
        &#34;&#34;&#34;Flush all items in queue

        Args:
            q (Queue): Queue to flush
        &#34;&#34;&#34;
        try:
            while True:
                q.get(block=False)
        except queue.Empty:
            pass

    def _individual_numbered_symbols(
        self, exclude: list=[], i: List[int]=[0]) -&gt; Generator[sympy.Symbol, None, None]:
        &#34;&#34;&#34;create individual symbol names for subexpressions using 
        multiprocessing.

        Args:
            exclude (list, optional): 
                List of names, which should not be used. Defaults to [].
            i (list, optional): 
                List with starting value -1 as first value. Is used as 
                counter and should not be set. Defaults to [0].

        Returns:
            sympy.numbered_symbols:  Symbols
        &#34;&#34;&#34;
        i[0] += 1
        prefix=&#34;sub%s_%s_&#34; % (
            &#34;_&#34;.join([str(j) for j in multiprocessing.current_process()._identity]), 
            i[0]
            )
        prefix = prefix.replace(&#34;sub_&#34;,&#34;sub0_&#34;)
        return numbered_symbols(
            prefix=prefix, 
            exclude=exclude)

    def _cse_expression(self, exp: sympy.Expr) -&gt; sympy.Expr:
        &#34;&#34;&#34;Use common subexpression elimination to shorten expression.
        The used subexpressions are saved to the class internal 
        subex_dict.

        Args:
            exp (Sympy expression): Expression to shorten using cse.

        Returns:
            Sympy expression: Shortened expression.
        &#34;&#34;&#34;
        # cse expression
        r, e = sympy.cse([exp, exp], self._individual_numbered_symbols(
            exclude=self.all_symbols), order=&#34;canonical&#34;, ignore=self.var_syms)
        # add subexpressions to dict
        for (sym, val) in r:
            self.subex_dict[sym] = val
            # for multiprocessing save in queue
            try:
                self.queue_dict[&#34;subex_dict&#34;].put(self.subex_dict)
            except:
                pass
            # update used symbols
            self.all_symbols.update({sym})
        return e[0]

    def _get_expressions(self) -&gt; List[sympy.Expr]:
        &#34;&#34;&#34;Get list of all generated expressions.

        Returns:
            list: generated expressions.
        &#34;&#34;&#34;
        expression_dict = self.get_expressions_dict()
        expressions = [expression_dict[i] for i in expression_dict]
        return expressions

    def _calc_A_matrix(
        self, q: MutableDenseMatrix
        ) -&gt; Tuple[List[MutableDenseMatrix], MutableDenseMatrix]:
        &#34;&#34;&#34;Calculate forward kinematics and the block diagonal matrix 
        A (6n x 6n) of the Adjoint of body frame for serial robots.

        Args:
            q (sympy.MutableDenseMatrix): 
                Generalized position vector.

        Raises:
            ValueError: 
                Joint screw coordinates or body reference configuration 
                not found.

        Returns:
            Tuple[List[MutableDenseMatrix], MutableDenseMatrix]: (FK, A)
        &#34;&#34;&#34;
        # calc Forward kinematics
        if self._FK_C is not None:
            FK_C = self._FK_C
        elif self.A:
            # print(&#34;Using absolute configuration (A) of the body frames&#34;)
            FK_f = [SE3Exp(self.Y[0], q[0])]
            FK_C = [FK_f[0]*self.A[0]]
            for i in range(1, self.n):
                FK_f.append(FK_f[i-1]*SE3Exp(self.Y[i], q[i]))
                FK_C.append(FK_f[i]*self.A[i])
            self._FK_C = FK_C
            if not self.X:
                # Joint screw coordinates in body-fixed representation 
                # computed from screw coordinates in IFR
                self.X = [SE3AdjInvMatrix(
                    self.A[i])*self.Y[i] for i in range(self.n)]

        elif self.B:
            # print(&#39;Using relative configuration (B) of the body frames&#39;)
            FK_C = [self.B[0]*SE3Exp(self.X[0], q[0])]
            for i in range(1, self.n):
                FK_C.append(FK_C[i-1]*self.B[i]*SE3Exp(self.X[i], q[i]))
            self._FK_C = FK_C
        else:
            # &#39;Absolute (A) or Relative (B) configuration of the bodies should be provided in class!&#39;
            raise ValueError(&#34;Joint screw coordinates and/or reference configuration of bodies not set.&#34;)

        # Block diagonal matrix A (6n x 6n) of the Adjoint of body frame
        if self._A is not None:
            A = self._A
        else:
            A = Matrix(Identity(6*self.n))
            for i in range(self.n):
                for j in range(i):
                    Crel = SE3Inv(FK_C[i])*FK_C[j]
                    AdCrel = SE3AdjMatrix(Crel)
                    r = 6*(i)
                    c = 6*(j)
                    A[r:r+6, c:c+6] = AdCrel
            self._A = A
        return FK_C, A

    def _calc_A_matrix_tree(self, q: MutableDenseMatrix):
        &#34;&#34;&#34;Calculate forward kinematics and the block diagonal matrix 
        A (6n x 6n) of the Adjoint of body frame for tree like robot 
        structures.

        Args:
            q (sympy.MutableDenseMatrix): 
                Generalized position vector.

        Raises:
            ValueError: 
                Joint screw coordinates or body reference configuration 
                not found.

        Returns:
            Tuple[List[MutableDenseMatrix], MutableDenseMatrix]: (FK, A)
        &#34;&#34;&#34;
        if self._FK_C is not None:
            FK_C = self._FK_C
        elif self.A:
            # print(&#34;Using absolute configuration (A) of the body frames&#34;)
            FK_f = []
            FK_C = []
            for i in range(self.n):
                if self.parent[i] == 0: # bodies with no predecessor
                    # Initialization for the first body
                    FK_f.append(SE3Exp(self.Y[i], q[i]))
                    FK_C.append(FK_f[i]*self.A[i])
                else:
                    FK_f.append(FK_f[self.parent[i]-1]*SE3Exp(self.Y[i], q[i]))
                    FK_C.append(FK_f[i]*self.A[i])      
            self._FK_C = FK_C
            if not self.X:
                # Joint screw coordinates in body-fixed representation 
                # computed from screw coordinates in IFR
                self.X = [SE3AdjInvMatrix(
                    self.A[i])*self.Y[i] for i in range(self.n)]

        elif self.B:
            # print(&#39;Using relative configuration (B) of the body frames&#39;)
            FK_C = []
            for i in range(self.n):
                if self.parent[i] == 0: # bodies with no predecessor
                    # Initialization for the first body
                    FK_C.append(self.B[i]*SE3Exp(self.X[i], q[i]))
                else:
                    FK_C.append(FK_C[self.parent[i]-1]*self.B[i]*SE3Exp(self.X[i], q[i]))
        else:
            # &#39;Absolute (A) or Relative (B) configuration of the bodies should be provided in class!&#39;
            raise ValueError(&#34;Joint screw coordinates and/or reference configuration of bodies not set.&#34;)

        # Block diagonal matrix A (6n x 6n) of the Adjoint of body frame
        if self._A is not None:
            A = self._A
        else:
            A = Matrix(Identity(6*self.n))
            for i in range(self.n):        
                if True:
                # if self.parent[i] != 0:
                    for k in self.support[i]:
                        j = k-1
                        Crel = SE3Inv(FK_C[i])*FK_C[j]
                        AdCrel = SE3AdjMatrix(Crel)
                        r = 6*(i)
                        c = 6*(j)
                        A[r:r+6, c:c+6] = AdCrel
            self._A = A
        return FK_C, A
    
    def _find_start_index(self) -&gt; int:
        &#34;&#34;&#34;Guess if 0 or 1 is the first index in the robot by analysing 
        used variable names.

        Returns:
            int: index.
        &#34;&#34;&#34;
        # search all symbols
        syms = set()
        for i in self.Mb:
            syms.update(i.free_symbols)
        for i in self.body_ref_config:
            syms.update(i.free_symbols)
        for i in self.joint_screw_coord:
            syms.update(i.free_symbols)
        # search all indices in symbols
        indices = []
        for i in syms:
            indices.extend(regex.findall(&#34;\d+&#34;,str(i)))
        #find smalles used index
        if indices:
            if min([int(i) for i in indices]) == 0:
                return 0
            if max([int(i) for i in indices]) == self.n -1:
                return 0
        return 1

    def _save_vectors(self, q: MutableDenseMatrix, qd: MutableDenseMatrix, 
                      q2d: MutableDenseMatrix, q3d: MutableDenseMatrix, 
                      q4d: MutableDenseMatrix, WEE: MutableDenseMatrix, 
                      WDEE: MutableDenseMatrix, W2DEE: MutableDenseMatrix) -&gt; None:
        &#34;&#34;&#34;Save generalized vectors als class parameter.

        Args:
            q (sympy.Matrix): 
                (n,1) Generalized position vector.
            qd (sympy.Matrix): 
                (n,1) Generalized velocity vector.
            q2d (sympy.Matrix): 
                (n,1) Generalized acceleration vector.
            q3d (sympy.Matrix): 
                (n,1) Generalized jerk vector.
            q4d (sympy.Matrix): 
                (n,1) Generalized jounce vector.
            WEE (sympy.Matrix): 
                (6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time varying 
                wrench on the EE link. 
            WDEE (sympy.Matrix): 
                (6,1) WDEE (t) = [dMx,dMy,dMz,dFx,dFy,dFz] is the derivative 
                of the time varying wrench on the EE link. 
            W2DEE (sympy.Matrix): 
                (6,1) W2DEE (t) = [ddMx,ddMy,ddMz,ddFx,ddFy,ddFz] is the 
                2nd derivative of the time varying wrench on the EE link. 
        &#34;&#34;&#34;
        if not self.q: self.q = q 
        if not self.qd: self.qd = qd 
        if not self.q2d: self.q2d = q2d 
        if not self.q3d: self.q3d = q3d 
        if not self.q4d: self.q4d = q4d
        if self.WEE == zeros(6,1) and WEE is not Ellipsis: self.WEE = WEE
        if self.WDEE == zeros(6,1) and WDEE is not Ellipsis: self.WDEE = WDEE
        if self.W2DEE == zeros(6,1) and W2DEE is not Ellipsis: self.W2DEE = W2DEE
        
    def _time_derivative(self, expression: sympy.Expr, level: int=1) -&gt; sympy.Expr:
        &#34;&#34;&#34;Generate time derivative of expression by substituting 
        generalized vectors with time dependent functions,
        let sympy calculate the time derivative, and resubstitute the 
        generalized vectors.

        Used for unit testing.
        
        Warning: This does not support external wrenches yet.

        Args:
            expression (sympy.Expr): 
                expression dependent on generalized vectors.
            level (int, optional): 
                Order of derivative to evaluate. Defaults to 1.

        Returns:
            sympy.Expr: Derived expression.
        &#34;&#34;&#34;
        # generate dynamic symbols as substitutes
        startindex = 1
        if self.n &gt; 1:
            subq = Matrix(sympy.physics.mechanics.dynamicsymbols(
                &#34; &#34;.join(f&#34;subq{i}&#34; for i in range(startindex,startindex+self.n))))
            subqd =  subq.diff()
            subq2d = subqd.diff() 
            subq3d = subq2d.diff() 
            subq4d = subq3d.diff() 
        else:
            subq = Matrix([sympy.physics.mechanics.dynamicsymbols(
                &#34; &#34;.join(f&#34;subq{i}&#34; for i in range(startindex,startindex+self.n)))])
            subqd =  subq.diff()
            subq2d = subqd.diff() 
            subq3d = subq2d.diff() 
            subq4d = subq3d.diff()
        # substitute
        expression = (expression.subs(zip(self.q,subq))
                                .subs(zip(self.qd,subqd))
                                .subs(zip(self.q2d,subq2d))
                                .subs(zip(self.q3d,subq3d))
                                .subs(zip(self.q4d,subq4d)))
        # derivative
        for _ in range(level):
            expression = expression.diff(&#34;t&#34;)
        # resubstitute
        expression = (expression.subs(zip(subq4d,self.q4d))
                                .subs(zip(subq3d,self.q3d))
                                .subs(zip(subq2d,self.q2d))
                                .subs(zip(subqd,self.qd))
                                .subs(zip(subq,self.q))
                                )
        return expression</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="skidy.kinematics_generator.SymbolicKinDyn"><code class="flex name class">
<span>class <span class="ident">SymbolicKinDyn</span></span>
<span>(</span><span>gravity_vector:sympy.matrices.dense.MutableDenseMatrix=None, ee:Union[sympy.matrices.dense.MutableDenseMatrix,List[sympy.matrices.dense.MutableDenseMatrix]]=None, body_ref_config:List[sympy.matrices.dense.MutableDenseMatrix]=[], joint_screw_coord:List[sympy.matrices.dense.MutableDenseMatrix]=[], config_representation:str='spatial', Mb:List[sympy.matrices.dense.MutableDenseMatrix]=[], parent:List[int]=[], support:List[List[int]]=[], child:List[List[int]]=[], ee_parent:Union[int,List[int]]=None, q:sympy.matrices.dense.MutableDenseMatrix=None, qd:sympy.matrices.dense.MutableDenseMatrix=None, q2d:sympy.matrices.dense.MutableDenseMatrix=None, q3d:sympy.matrices.dense.MutableDenseMatrix=None, q4d:sympy.matrices.dense.MutableDenseMatrix=None, WEE:Union[sympy.matrices.dense.MutableDenseMatrix,List[sympy.matrices.dense.MutableDenseMatrix]]=Matrix([
[0],
[0],
[0],
[0],
[0],
[0]]), WDEE:Union[sympy.matrices.dense.MutableDenseMatrix,List[sympy.matrices.dense.MutableDenseMatrix]]=Matrix([
[0],
[0],
[0],
[0],
[0],
[0]]), W2DEE:Union[sympy.matrices.dense.MutableDenseMatrix,List[sympy.matrices.dense.MutableDenseMatrix]]=Matrix([
[0],
[0],
[0],
[0],
[0],
[0]]), **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>SymbolicKinDyn
Symbolic tool to compute equations of motion of serial chain
robots and autogenerate code from the calculated equations.
This tool supports generation of python, C and Matlab code.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gravity_vector</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>Vector of gravity. Defaults to None.</dd>
<dt>ee (sympy.Matrix | list of sympy.Matrix, optional):</dt>
<dt>End-effector configuration with reference to last link</dt>
<dt>body fixed frame in the chain. This link can be selected</dt>
<dt>manually using the parameter ee_parent.</dt>
<dt>If there is more than one end-effector use a list of</dt>
<dt>transforms instead.</dt>
<dt>Defaults to None.</dt>
<dt><strong><code>body_ref_config</code></strong> :&ensp;<code>list</code> of <code>sympy.Matrix</code>, optional</dt>
<dd>List of reference configurations of bodies in body-fixed
or spatial representation, dependent on selected
config_representation.
Leave empty for dH Parameter usage (dhToScrewCoord(&hellip;)).
Defaults to [].</dd>
<dt><strong><code>joint_screw_coord</code></strong> :&ensp;<code>list</code> of <code>sympy.Matrix</code>, optional</dt>
<dd>List of joint screw coordinates in body-fixed
or spatial representation, dependent on selected
config_representation.
Leave empty for dH Parameter usage (dhToScrewCoord(&hellip;)).
Defaults to [].</dd>
<dt><strong><code>config_representation</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Use body fixed or spatial representation for reference
configuration of bodies and joint screw coordinates.
Has to be "body_fixed" or "spatial".
Defaults to "spatial".</dd>
<dt><strong><code>Mb</code></strong> :&ensp;<code>list</code> of <code>sympy.Matrix</code>, optional</dt>
<dd>List of Mass Inertia matrices for all links. Only
necessary for inverse dynamics. Defaults to [].</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>list of parent link indices for any joint. Use 0 for world.
Only necessary for tree-like robot structures.
Defaults to [].</dd>
<dt><strong><code>support</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>list of lists with one list per link which includes all
support links beginning with the first link in the chain
and including the current link.
Only necessary for tree-like robot structures.
Defaults to [].</dd>
<dt><strong><code>child</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>list of lists with one list per link which includes all
child links. Use empty list if no child link is present.
Only necessary for tree-like robot structures.
Defaults to [].</dd>
<dt>ee_parent (int | list, optional):</dt>
<dt>parent link of the end effector frame. If there is more</dt>
<dt>than one end-effector, use a list of indices instead.</dt>
<dt>Defaults to None (= last link).</dt>
<dt><strong><code>q</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(n,1) Generalized position vector. Defaults to None.</dd>
<dt><strong><code>qd</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(n,1) Generalized velocity vector. Defaults to None.</dd>
<dt><strong><code>q2d</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(n,1) Generalized acceleration vector. Defaults to None.</dd>
<dt><strong><code>q3d</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(n,1) Generalized jerk vector. Defaults to None.</dd>
<dt><strong><code>q4d</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(n,1) Generalized jounce vector. Defaults to None.</dd>
</dl>
<p>WEE (sympy.Matrix | list, optional):
(6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time varying
wrench on the EE link.
If there is more than one end-effector, you can use a
list containing all wrenches instead.
Defaults to zeros(6, 1).
WDEE (sympy.Matrix | list, optional):
(6,1) WDEE (t) = [dMx,dMy,dMz,dFx,dFy,dFz] is the derivative
of the time varying wrench on the EE link.
If there is more than one end-effector, you can use a
list containing all wrenches instead.
Defaults to zeros(6, 1).
W2DEE (sympy.Matrix | list, optional):
(6,1) W2DEE (t) = [ddMx,ddMy,ddMz,ddFx,ddFy,ddFz] is the
2nd derivative of the time varying wrench on the EE link.
If there is more than one end-effector, you can use a
list containing all wrenches instead.
Defaults to zeros(6, 1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SymbolicKinDyn(_AbstractCodeGeneration):
    BODY_FIXED = &#34;body_fixed&#34;
    SPATIAL = &#34;spatial&#34;
    
    def __init__(self, 
                 gravity_vector: MutableDenseMatrix=None, 
                 ee: Union[MutableDenseMatrix,List[MutableDenseMatrix]]=None, 
                 body_ref_config: List[MutableDenseMatrix]=[], 
                 joint_screw_coord: List[MutableDenseMatrix]=[], 
                 config_representation: str=&#34;spatial&#34;, 
                 Mb: List[MutableDenseMatrix]=[], 
                 parent: List[int]=[], 
                 support: List[List[int]]=[], 
                 child: List[List[int]]=[], 
                 ee_parent: Union[int,List[int]]=None,
                 q:MutableDenseMatrix=None, 
                 qd: MutableDenseMatrix=None, 
                 q2d: MutableDenseMatrix=None, 
                 q3d: MutableDenseMatrix=None, 
                 q4d: MutableDenseMatrix=None, 
                 WEE: Union[MutableDenseMatrix,List[MutableDenseMatrix]]=zeros(6, 1),
                 WDEE: Union[MutableDenseMatrix,List[MutableDenseMatrix]]=zeros(6, 1),
                 W2DEE: Union[MutableDenseMatrix,List[MutableDenseMatrix]]=zeros(6, 1),
                 **kwargs) -&gt; None:
        &#34;&#34;&#34;SymbolicKinDyn
        Symbolic tool to compute equations of motion of serial chain 
        robots and autogenerate code from the calculated equations. 
        This tool supports generation of python, C and Matlab code.

        Args:
            gravity_vector (sympy.Matrix, optional): 
                Vector of gravity. Defaults to None.
            ee (sympy.Matrix | list of sympy.Matrix, optional): 
                End-effector configuration with reference to last link 
                body fixed frame in the chain. This link can be selected 
                manually using the parameter ee_parent. 
                If there is more than one end-effector use a list of 
                transforms instead.
                Defaults to None.
            body_ref_config (list of sympy.Matrix, optional): 
                List of reference configurations of bodies in body-fixed
                or spatial representation, dependent on selected 
                config_representation. 
                Leave empty for dH Parameter usage (dhToScrewCoord(...)). 
                Defaults to [].
            joint_screw_coord (list of sympy.Matrix, optional): 
                List of joint screw coordinates in body-fixed 
                or spatial representation, dependent on selected 
                config_representation. 
                Leave empty for dH Parameter usage (dhToScrewCoord(...)). 
                Defaults to [].
            config_representation (str, optional): 
                Use body fixed or spatial representation for reference 
                configuration of bodies and joint screw coordinates.
                Has to be &#34;body_fixed&#34; or &#34;spatial&#34;. 
                Defaults to &#34;spatial&#34;.
            Mb (list of sympy.Matrix, optional): 
                List of Mass Inertia matrices for all links. Only 
                necessary for inverse dynamics. Defaults to [].
            parent (list, optional): 
                list of parent link indices for any joint. Use 0 for world.
                Only necessary for tree-like robot structures. 
                Defaults to [].
            support (list, optional): 
                list of lists with one list per link which includes all 
                support links beginning with the first link in the chain 
                and including the current link.
                Only necessary for tree-like robot structures. 
                Defaults to [].
            child (list, optional): 
                list of lists with one list per link which includes all
                child links. Use empty list if no child link is present.
                Only necessary for tree-like robot structures. 
                Defaults to [].
            ee_parent (int | list, optional): 
                parent link of the end effector frame. If there is more 
                than one end-effector, use a list of indices instead.
                Defaults to None (= last link).
            q (sympy.Matrix, optional): 
                (n,1) Generalized position vector. Defaults to None.
            qd (sympy.Matrix, optional): 
                (n,1) Generalized velocity vector. Defaults to None.
            q2d (sympy.Matrix, optional): 
                (n,1) Generalized acceleration vector. Defaults to None.
            q3d (sympy.Matrix, optional): 
                (n,1) Generalized jerk vector. Defaults to None.
            q4d (sympy.Matrix, optional): 
                (n,1) Generalized jounce vector. Defaults to None.
            WEE (sympy.Matrix | list, optional): 
                (6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time varying 
                wrench on the EE link. 
                If there is more than one end-effector, you can use a 
                list containing all wrenches instead.
                Defaults to zeros(6, 1).
            WDEE (sympy.Matrix | list, optional): 
                (6,1) WDEE (t) = [dMx,dMy,dMz,dFx,dFy,dFz] is the derivative 
                of the time varying wrench on the EE link. 
                If there is more than one end-effector, you can use a 
                list containing all wrenches instead.
                Defaults to zeros(6, 1).
            W2DEE (sympy.Matrix | list, optional): 
                (6,1) W2DEE (t) = [ddMx,ddMy,ddMz,ddFx,ddFy,ddFz] is the 
                2nd derivative of the time varying wrench on the EE link. 
                If there is more than one end-effector, you can use a 
                list containing all wrenches instead.
                Defaults to zeros(6, 1).
            
        &#34;&#34;&#34;
        super().__init__()
        self.n = None  # degrees of freedom
        self.gravity_vector = gravity_vector
        self.ee = ee

        self.B = [] # List of reference configurations of bodies in body-fixed representation.
        self.X = [] # List of joint screw coordinates in body-fixed representation.

        self.A = [] # List of reference configurations of bodies in spatial representation.
        self.Y = [] # List of joint screw coordinates in spatial representation.
        
        self.config_representation = config_representation # @property: checks for valid value 
        if body_ref_config != []:
            self.body_ref_config = body_ref_config # @property: sets A or B
        if joint_screw_coord != []:
            self.joint_screw_coord = joint_screw_coord # @property: sets X or Y
        # support of old syntax
        if &#34;A&#34; in kwargs:
            self.A = kwargs[&#34;A&#34;]
            n = len(self.A)
            if n:
                self.n = n
        if &#34;B&#34; in kwargs:
            self.B = kwargs[&#34;B&#34;]
            n = len(self.B)
            if n:
                self.n = n
        if &#34;X&#34; in kwargs:
            self.X = kwargs[&#34;X&#34;]
        if &#34;Y&#34; in kwargs:
            self.Y = kwargs[&#34;Y&#34;]

            
        self.Mb = Mb
        self.parent = parent
        self.child = child
        self.support = support
        
        # costom ee link
        self.ee_parent = ee_parent
        
        # temporary vars
        self._FK_C = None
        self._A = None
        self._a = None
        self._V = None  # system twist

        
        # Multiprocessing
        # dict of queues, which saves values and results
        self.queue_dict = {}  
        # dict of running processes
        self.process_dict = {}  
        
        # generalized vectors end external forces
        self.q = q
        self.qd = qd
        self.q2d = q2d
        self.q3d = q3d
        self.q4d = q4d
        self.WEE = WEE
        self.WDEE = WDEE
        self.W2DEE = W2DEE

        
    @property
    def config_representation(self) -&gt; str:
        return self._config_representation
    
    @config_representation.setter
    def config_representation(self, value: str) -&gt; None:
        if value not in {self.BODY_FIXED, self.SPATIAL}:
            raise ValueError(&#34;config_representation has to be &#39;body_fixed&#39; or &#39;spatial&#39;&#34;)
        self._config_representation = value
    
    @property
    def body_ref_config(self) -&gt; list:
        if self.config_representation == self.BODY_FIXED:
            return self.B
        elif self.config_representation == self.SPATIAL:
            return self.A
    
    @body_ref_config.setter
    def body_ref_config(self, value: List[MutableDenseMatrix]) -&gt; None:
        n = len(value)
        if n:
            self.n = n
        if self.config_representation == self.BODY_FIXED:
            self.B = value
        elif self.config_representation == self.SPATIAL:
            self.A = value
    
    @property
    def joint_screw_coord(self) -&gt; list:
        if self.config_representation == self.BODY_FIXED:
            return self.X
        elif self.config_representation == self.SPATIAL:
            return self.Y
    
    @joint_screw_coord.setter
    def joint_screw_coord(self, value: List[MutableDenseMatrix]) -&gt; None:
        if self.config_representation == self.BODY_FIXED:
            self.X = value
        elif self.config_representation == self.SPATIAL:
            self.Y = value
    
    def closed_form_kinematics_body_fixed(
        self, q:sympy.MutableDenseMatrix=None, qd: MutableDenseMatrix=None, 
        q2d: MutableDenseMatrix=None, simplify: bool=True, 
        cse: bool=False, parallel: bool=True) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Position, Velocity and Acceleration Kinematics using Body 
        fixed representation of the twists in closed form.

        The following expressions are saved in the class and can be 
        code generated afterwards:
        
            body_acceleration
            body_acceleration_ee
            body_jacobian_matrix
            body_jacobian_matrix_dot 
            body_jacobian_matrix_ee
            body_jacobian_matrix_ee_dot
            body_twist_ee
            forward_kinematics
            hybrid_acceleration
            hybrid_acceleration_ee
            hybrid_jacobian_matrix
            hybrid_jacobian_matrix_dot
            hybrid_jacobian_matrix_ee
            hybrid_jacobian_matrix_ee_dot
            hybrid_twist_ee

        Needs class parameters body_ref_config, joint_screw_coord and ee 
        to be defined.

        Args:
            q (sympy.Matrix, optional): 
                (n,1) Generalized position vector. Defaults to None.
            qd (sympy.Matrix, optional): 
                (n,1) Generalized velocity vector. Defaults to None.
            q2d (sympy.Matrix, optional): 
                (n,1) Generalized acceleration vector. Defaults to None.
            simplify (bool, optional): 
                Use simplify command on saved expressions. 
                Defaults to True.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.
            parallel (bool, optional): 
                Use parallel computation via multiprocessing. 
                Defaults to True.
        Raises:
            ValueError:
                Joint screw coordinates and/or reference configuration 
                of bodies not set.
                
        Returns:
            sympy.Matrix: Forward kinematics.
        &#34;&#34;&#34;
        if not q or not qd or not q2d:
            if not self.n:
                self.n = len(self.body_ref_config)
            if not self.q or not self.qd or not self.q2d:
                print(self.q, self.qd, self.q2d)
                q, qd, q2d = generalized_vectors(self.n,self._find_start_index())
            else:
                q, qd, q2d = self.q, self.qd, self.q2d
                
        self._save_vectors(q, qd, q2d, None, None, ..., ..., ...)
        self.n = len(q)
        
        # prepare ee link selection
        if self.ee_parent is None:
            self.ee_parent = [self.n]
        if type(self.ee) is not list: self.ee = [self.ee]
        if type(self.ee_parent) is not list: self.ee_parent = [self.ee_parent]
        assert(len(self.ee) == len(self.ee_parent))    
        self.n_ee = len(self.ee_parent)
        
        if parallel:
            self._closed_form_kinematics_body_fixed_parallel(
                q, qd, q2d, simplify, cse)
        else:
            self._closed_form_kinematics_body_fixed(
                q, qd, q2d, simplify, cse)
        return self.fkin

    def closed_form_inv_dyn_body_fixed(
        self, 
        q:sympy.MutableDenseMatrix=None, 
        qd: MutableDenseMatrix=None, 
        q2d: MutableDenseMatrix=None, 
        q3d: MutableDenseMatrix=None, 
        q4d: MutableDenseMatrix=None, 
        WEE: Union[MutableDenseMatrix,List[MutableDenseMatrix]]=..., 
        WDEE: Union[MutableDenseMatrix,List[MutableDenseMatrix]]=..., 
        W2DEE: Union[MutableDenseMatrix,List[MutableDenseMatrix]]=..., 
        simplify: bool=True, cse: bool=False, 
        parallel: bool=True) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Inverse dynamics using body fixed representation of the 
        twists in closed form. 

        The following expressions are saved in the class and can be 
        code generated afterwards:
            coriolis_centrifugal_matrix
            generalized_mass_inertia_matrix
            gravity_vector
            inverse_dynamics

        Args:
            q (sympy.Matrix, optional): 
                (n,1) Generalized position vector. Defaults to None.
            qd (sympy.Matrix, optional): 
                (n,1) Generalized velocity vector. Defaults to None.
            q2d (sympy.Matrix, optional): 
                (n,1) Generalized acceleration vector. Defaults to None.
            q3d (sympy.Matrix, optional): 
                (n,1) Generalized jerk vector. Defaults to None.
            q4d (sympy.Matrix, optional): 
                (n,1) Generalized jounce vector. Defaults to None.
            WEE (list | sympy.Matrix, optional): 
                (6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time varying 
                wrench on the EE link. 
                If there is more than one end-effector, you can use a 
                list containing all wrenches instead.
                Defaults to zeros(6, 1).
            WDEE (list | sympy.Matrix, optional): 
                (6,1) WDEE (t) = [dMx,dMy,dMz,dFx,dFy,dFz] is the derivative 
                of the time varying wrench on the EE link. 
                If there is more than one end-effector, you can use a 
                list containing all wrenches instead.
                Defaults to zeros(6, 1).
            W2DEE (list | sympy.Matrix, optional): 
                (6,1) W2DEE (t) = [ddMx,ddMy,ddMz,ddFx,ddFy,ddFz] is the 
                2nd derivative of the time varying wrench on the EE link. 
                If there is more than one end-effector, you can use a 
                list containing all wrenches instead.
                Defaults to zeros(6, 1).
            simplify (bool, optional): 
                Use simplify command on saved expressions. 
                Defaults to True.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.
            parallel (bool, optional): 
                Use parallel computation via multiprocessing. 
                Defaults to True.

        Raises:
            ValueError:
                Joint screw coordinates and/or reference configuration 
                of bodies not set.
        
        Returns:
            sympy.Matrix: Generalized forces
        &#34;&#34;&#34;
        if not q or not qd or not q2d:
            if not self.n:
                self.n = len(self.body_ref_config)
            if not self.q or not self.qd or not self.q2d:
                q, qd, q2d = generalized_vectors(self.n,self._find_start_index())
            else:
                q, qd, q2d, q3d, q4d = self.q, self.qd, self.q2d, self.q3d, self.q4d
        
        if WEE is Ellipsis:
            WEE = self.WEE
        if WDEE is Ellipsis:
            WDEE = self.WDEE
        if W2DEE is Ellipsis:
            W2DEE = self.W2DEE
        
        self._save_vectors(q, qd, q2d, q3d, q4d, WEE, WDEE, W2DEE)
        self.n = len(q)
        
        # prepare ee link selection
        if self.ee_parent is None:
            self.ee_parent = [self.n]
        if type(self.ee_parent) is not list: self.ee_parent = [self.ee_parent]
        self.n_ee = len(self.ee_parent)
        if self.n_ee &gt; 1:
            if type(WEE) is list and len(WEE) &gt; 1:
                assert(len(WEE) == len(self.ee_parent))
            if type(WDEE) is list and len(WDEE) &gt; 1:
                assert(len(WDEE) == len(self.ee_parent))
            if type(W2DEE) is list and len(W2DEE) &gt; 1:
                assert(len(W2DEE) == len(self.ee_parent)) 
        if type(WEE) is not list: WEE = [WEE]
        if type(WDEE) is not list: WDEE = [WDEE]
        if type(W2DEE) is not list: W2DEE = [W2DEE]
        
        if parallel:
            self._closed_form_inv_dyn_body_fixed_parallel(
                q, qd, q2d, q3d, q4d, WEE, WDEE, W2DEE, simplify, cse)
        else:
            self._closed_form_inv_dyn_body_fixed(
                q, qd, q2d, q3d, q4d, WEE, WDEE, W2DEE, simplify, cse)
        return self.Q

    def _closed_form_kinematics_body_fixed(
        self, q: MutableDenseMatrix, qd: MutableDenseMatrix, 
        q2d: MutableDenseMatrix, simplify: bool=True, 
        cse: bool=False) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Position, velocity and acceleration kinematics using 
        body fixed representation of the twists in closed form.

        The following expressions are saved in the class and can be 
        code generated afterwards:
            body_acceleration
            body_acceleration_ee
            body_jacobian_matrix
            body_jacobian_matrix_dot 
            body_jacobian_matrix_ee
            body_jacobian_matrix_ee_dot
            body_twist_ee
            forward_kinematics
            hybrid_acceleration
            hybrid_acceleration_ee
            hybrid_jacobian_matrix
            hybrid_jacobian_matrix_dot
            hybrid_jacobian_matrix_ee
            hybrid_jacobian_matrix_ee_dot
            hybrid_twist_ee

            Needs class parameters body_ref_config, joint_screw_coord 
            and ee to be defined.

        Args:
            q (sympy.Matrix): 
                (n,1) Generalized position vector.
            qd (sympy.Matrix): 
                (n,1) Generalized velocity vector.
            q2d (sympy.Matrix): 
                (n,1) Generalized acceleration vector.
            simplify (bool, optional): 
                Use simplify command on saved expressions. 
                Defaults to True.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.


        Returns:
            sympy.Matrix: Forward kinematics.
        &#34;&#34;&#34;
        print(&#34;Forward kinematics calculation&#34;)
        self.var_syms.update(q.free_symbols)
        self.var_syms.update(qd.free_symbols)
        self.var_syms.update(q2d.free_symbols)

        self.n = len(q)  # DOF

        # calc Forward kinematics
        if self.parent and self.support:
            FK_C, A = self._calc_A_matrix_tree(q)
        else:    
            FK_C, A = self._calc_A_matrix(q)
        
        fkin = [None]*self.n_ee
        for i in range(self.n_ee):
            fkin[i] = FK_C[self.ee_parent[i]-1]*self.ee[i]
            if simplify:
                fkin[i] = self.simplify(fkin[i], cse)
            elif cse:
                fkin[i] = self._cse_expression(fkin[i])    
        self.fkin = fkin if len(fkin)&gt;1 else fkin[0]
        
        if self.J is not None:
            J = self.J
            V = self._V
        else:
            # Block diagonal matrix X (6n x n) of the screw coordinate 
            # vector associated to all joints in the body frame (Constant)
            X = zeros(6*self.n, self.n)
            for i in range(self.n):
                X[6*i:6*i+6, i] = self.X[i]

            # System level Jacobian
            J = A*X
            if simplify:
                J = self.simplify(J, cse)
            elif cse:
                J = self._cse_expression(J)
            self.J = J

            # System twist (6n x 1)
            V = J*qd
            self._V = V

        R_i = [None]*self.n_ee
        R_BFn = [None]*self.n_ee
        Vb_BFn = [None]*self.n_ee
        Vh_BFn = [None]*self.n_ee
        Vb_ee = [None]*self.n_ee
        Vh_ee = [None]*self.n_ee
        Jh_ee = [None]*self.n_ee
        Jb_ee = [None]*self.n_ee
        Jh = [None]*self.n_ee
        Jb = [None]*self.n_ee
        for i in range(self.n_ee):
            # Different Jacobians
            R_i[i] = Matrix(fkin[i][:3, :3]).row_join(
                zeros(3, 1)).col_join(Matrix([0, 0, 0, 1]).T)
            if simplify:  # fastens later simplifications
                R_i[i] = self.simplify(R_i[i], cse)
            elif cse:
                R_i[i] = self._cse_expression(R_i[i])
            
            R_BFn[i] = Matrix(FK_C[self.ee_parent[i]-1][:3, :3]).row_join(
                zeros(3, 1)).col_join(Matrix([0, 0, 0, 1]).T)

            # Body fixed Jacobian of last moving body 
            # (This may not correspond to end-effector frame)
            Jb[i] = J[6*(self.ee_parent[i]-1):6*self.ee_parent[i], :] # used to be [-6:,:]
            if simplify:
                Jb[i] = self.simplify(Jb[i], cse)
            elif cse:
                Jb[i] = self._cse_expression(Jb[i])

            Vb_BFn[i] = Jb[i]*qd  # Body fixed twist of last moving body
            if simplify:
                Vb_BFn[i] = self.simplify(Vb_BFn[i], cse)
            elif cse:
                Vb_BFn[i] = self._cse_expression(Vb_BFn[i])
            Vh_BFn[i] = SE3AdjMatrix(R_BFn[i])*Vb_BFn[i]
            if simplify:
                Vh_BFn[i] = self.simplify(Vh_BFn[i], cse)
            elif cse:
                Vh_BFn[i] = self._cse_expression(Vh_BFn[i])
            
            # Body fixed twist of end-effector frame
            Vb_ee[i] = SE3AdjMatrix(SE3Inv(self.ee[i]))*Vb_BFn[i]
            if simplify:
                Vb_ee[i] = self.simplify(Vb_ee[i], cse)
            elif cse:
                Vb_ee[i] = self._cse_expression(Vb_ee[i])
            # Hybrid twist of end-effector frame
            Vh_ee[i] = SE3AdjMatrix(R_i[i])*Vb_ee[i]
            if simplify:
                Vh_ee[i] = self.simplify(Vh_ee[i], cse)
            elif cse:
                Vh_ee[i] = self._cse_expression(Vh_ee[i])

            # Body fixed Jacobian of end-effector frame
            Jb_ee[i] = SE3AdjMatrix(SE3Inv(self.ee[i]))*Jb[i]
            if simplify:
                Jb_ee[i] = self.simplify(Jb_ee[i], cse)
            elif cse:
                Jb_ee[i] = self._cse_expression(Jb_ee[i])

            # Hybrid Jacobian of end-effector frame
            Jh_ee[i] = SE3AdjMatrix(R_i[i])*Jb_ee[i]
            # Hybrid Jacobian of last moving body
            Jh[i] = SE3AdjMatrix(R_i[i])*Jb[i]  

            if simplify:
                Jh_ee[i] = self.simplify(Jh_ee[i], cse)
                Jh[i] = self.simplify(Jh[i], cse)
            elif cse:
                Jh_ee[i] = self._cse_expression(Jh_ee[i])
                Jh[i] = self._cse_expression(Jh[i])
            
        self.Vb_BFn = Vb_BFn if len(Vb_BFn)&gt;1 else Vb_BFn[0]
        self.Vh_BFn = Vh_BFn if len(Vh_BFn)&gt;1 else Vh_BFn[0]
        self.Vb_ee = Vb_ee if len(Vb_ee)&gt;1 else Vb_ee[0]
        self.Vh_ee = Vh_ee if len(Vh_ee)&gt;1 else Vh_ee[0]
        self.Jh_ee = Jh_ee if len(Jh_ee)&gt;1 else Jh_ee[0]
        self.Jb_ee = Jb_ee if len(Jb_ee)&gt;1 else Jb_ee[0]
        self.Jh = Jh if len(Jh)&gt;1 else Jh[0]
        self.Jb = Jb if len(Jb)&gt;1 else Jb[0]
        
        # Acceleration computations
        if self._a is not None:
            a = self._a
        else:
            # Block diagonal matrix a (6n x 6n)
            a = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                a[6*i:6*i+6, 6*i:6*i+6] = SE3adMatrix(self.X[i])*qd[i]
            if simplify:
                a = self.simplify(a, cse)
            elif cse:
                a = self._cse_expression(a)
            self._a = a

        # System acceleration (6n x 1)
        Jdot = -A*a*J  # Sys-level Jacobian time derivative
        if simplify:
            Jdot = self.simplify(Jdot, cse)
        elif cse:
            Jdot = self._cse_expression(Jdot)

        self.Jdot = Jdot

        Vbd = J*q2d - A*a*V

        Vbd_BFn = [None]*self.n_ee
        Vhd_BFn = [None]*self.n_ee
        Vbd_ee = [None]*self.n_ee
        Vhd_ee = [None]*self.n_ee
        Jb_dot = [None]*self.n_ee
        Jb_ee_dot = [None]*self.n_ee
        Jh_dot = [None]*self.n_ee
        Jh_ee_dot = [None]*self.n_ee
        for i in range(self.n_ee):
            # Hybrid acceleration of the last body
            Vbd_BFn[i] = Vbd[6*(self.ee_parent[i]-1):6*self.ee_parent[i], :] # used to be [-6:,:]
            if simplify:
                Vbd_BFn[i] = self.simplify(Vbd_BFn[i], cse)
            elif cse:
                Vbd_BFn[i] = self._cse_expression(Vbd_BFn[i])
            # Hybrid twist of end-effector frame 
            # TODO: check comments
            Vhd_BFn[i] = (SE3AdjMatrix(R_BFn[i])*Vbd_BFn[i] 
                    + SE3adMatrix(Matrix(Vh_BFn[i][:3, :])
                                        .col_join(Matrix([0, 0, 0])))
                    * SE3AdjMatrix(R_BFn[i])*Vb_BFn[i])  

            if simplify:
                Vhd_BFn[i] = self.simplify(Vhd_BFn[i], cse)
            elif cse:
                Vhd_BFn[i] = self._cse_expression(Vhd_BFn[i])

            # Body fixed twist of end-effector frame
            # Hybrid acceleration of the EE
            Vbd_ee[i] = SE3AdjMatrix(SE3Inv(self.ee[i]))*Vbd_BFn[i]
            if simplify:
                Vbd_ee[i] = self.simplify(Vbd_ee[i], cse)
            elif cse:
                Vbd_ee[i] = self._cse_expression(Vbd_ee[i])
            # Hybrid twist of end-effector frame
            Vhd_ee[i] = SE3AdjMatrix(R_i[i])*Vbd_ee[i] + SE3adMatrix(Matrix(
                Vh_ee[i][:3, :]).col_join(Matrix([0, 0, 0])))*\
                    SE3AdjMatrix(R_i[i])*Vb_ee[i]  
            if simplify:
                Vhd_ee[i] = self.simplify(Vhd_ee[i], cse)
            elif cse:
                Vhd_ee[i] = self._cse_expression(Vhd_ee[i])

            # Body Jacobian time derivative

            # For the last moving body
            Jb_dot[i] = Jdot[6*(self.ee_parent[i]-1):6*self.ee_parent[i], :] # used to be [-6:,:]

            # For the EE
            Jb_ee_dot[i] = SE3AdjMatrix(SE3Inv(self.ee[i]))*Jb_dot[i]
            if simplify:
                Jb_ee_dot[i] = self.simplify(Jb_ee_dot[i], cse)
            elif cse:
                Jb_ee_dot[i] = self._cse_expression(Jb_ee_dot[i])

            # Hybrid Jacobian time derivative
            # For the last moving body
            Jh_dot[i] = (SE3AdjMatrix(R_BFn[i])*Jb_dot[i] 
                    + SE3adMatrix(Matrix(Vh_BFn[i][:3, :]).col_join(Matrix([0, 0, 0])))
                    *SE3AdjMatrix(R_BFn[i])*Jb[i])
            if simplify:
                Jh_dot[i] = self.simplify(Jh_dot[i], cse)
            elif cse:
                Jh_dot[i] = self._cse_expression(Jh_dot[i])

            # For the EE
            Jh_ee_dot[i] = (SE3AdjMatrix(R_i[i])*Jb_ee_dot[i] 
                        + SE3adMatrix(Matrix(Vh_ee[i][:3, :]).col_join(Matrix([0, 0, 0])))
                        * SE3AdjMatrix(R_i[i])*Jb_ee[i])
            if simplify:
                Jh_ee_dot[i] = self.simplify(Jh_ee_dot[i], cse)
            elif cse:
                Jh_ee_dot[i] = self._cse_expression(Jh_ee_dot[i])
        
        self.Vbd_BFn = Vbd_BFn if len(Vbd_BFn)&gt;1 else Vbd_BFn[0]
        self.Vhd_BFn = Vhd_BFn if len(Vhd_BFn)&gt;1 else Vhd_BFn[0]
        self.Vbd_ee = Vbd_ee if len(Vbd_ee)&gt;1 else Vbd_ee[0]
        self.Vhd_ee = Vhd_ee if len(Vhd_ee)&gt;1 else Vhd_ee[0]
        self.Jb_dot = Jb_dot if len(Jb_dot)&gt;1 else Jb_dot[0]
        self.Jb_ee_dot = Jb_ee_dot if len(Jb_ee_dot)&gt;1 else Jb_ee_dot[0]
        self.Jh_dot = Jh_dot if len(Jh_dot)&gt;1 else Jh_dot[0]
        self.Jh_ee_dot = Jh_ee_dot if len(Jh_ee_dot)&gt;1 else Jh_ee_dot[0]

        for e in self._get_expressions():
            self.all_symbols.update(e.free_symbols)

        print(&#34;Done&#34;)
        return fkin

    def _closed_form_inv_dyn_body_fixed(self, q: MutableDenseMatrix, 
                                        qd: MutableDenseMatrix, 
                                        q2d: MutableDenseMatrix,
                                        q3d: MutableDenseMatrix=None, 
                                        q4d: MutableDenseMatrix=None, 
                                        WEE: List[MutableDenseMatrix]=[zeros(6, 1)], 
                                        WDEE: List[MutableDenseMatrix]=[zeros(6, 1)], 
                                        W2DEE: List[MutableDenseMatrix]=[zeros(6, 1)], 
                                        simplify: bool=True, 
                                        cse: bool=False) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Inverse dynamics using body fixed representation of the 
        twists in closed form. 

        The following expressions are saved in the class and can be code 
        generated afterwards:
            coriolis_centrifugal_matrix
            generalized_mass_inertia_matrix
            gravity_vector
            inverse_dynamics

        Args:
            q (sympy.Matrix): (n,1) Generalized position vector.
            qd (sympy.Matrix): (n,1 )Generalized velocity vector.
            q2d (sympy.Matrix): (n,1) Generalized acceleration vector.
            q3d (sympy.Matrix, optional): 
                (n,1) Generalized jerk vector. Defaults to None.
            q4d (sympy.Matrix, optional): 
                (n,1) Generalized jounce vector. Defaults to None.
            WEE (list of sympy.Matrix, optional): 
                (6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time varying 
                wrench on the EE link. 
                Defaults to [zeros(6, 1)].
            WDEE (list of sympy.Matrix, optional): 
                (6,1) WDEE (t) = [dMx,dMy,dMz,dFx,dFy,dFz] is the derivative 
                of the time varying wrench on the EE link. 
                Defaults to [zeros(6, 1)].
            W2DEE (list of sympy.Matrix, optional): 
                (6,1) W2DEE (t) = [ddMx,ddMy,ddMz,ddFx,ddFy,ddFz] is the 
                2nd derivative of the time varying wrench on the EE link. 
                Defaults to [zeros(6, 1)].
            simplify (bool, optional): Use simplify command 
                on saved expressions. Defaults to True.
            cse (bool, optional): Use common subexpression 
                elimination. Defaults to False.

        Returns:
            sympy.Matrix: Generalized forces
        &#34;&#34;&#34;
        print(&#34;Inverse dynamics calculation&#34;)

        self.var_syms.update(q.free_symbols)
        self.var_syms.update(qd.free_symbols)
        self.var_syms.update(q2d.free_symbols)
        if q3d: self.var_syms.update(q3d.free_symbols)
        if q4d: self.var_syms.update(q4d.free_symbols)
        for W in WEE:
            self.optional_var_syms.update(W.free_symbols)
        for WD in WDEE:
            self.optional_var_syms.update(WD.free_symbols)
        for W2D in W2DEE:
            self.optional_var_syms.update(W2D.free_symbols)

        self.n = len(q)

        # calc Forward kinematics
        if self.parent and self.support:
            FK_C, A = self._calc_A_matrix_tree(q)
        else:    
            FK_C, A = self._calc_A_matrix(q)
        
        if self.J is not None:
            J = self.J  # system level Jacobian
            V = self._V  # system twist
        else:
            # Block diagonal matrix X (6n x n) of the screw coordinate 
            # vector associated to all joints in the body frame (constant)
            X = zeros(6*self.n, self.n)
            for i in range(self.n):
                X[6*i:6*i+6, i] = self.X[i]

            # System level Jacobian
            J = A*X
            if simplify:
                J = self.simplify(J, cse)
            elif cse:
                J = self._cse_expression(J)
            self.J = J

            # System twist (6n x 1)
            V = J*qd
            self._V = V

        # Acceleration computations
        if self._a is not None:
            a = self._a
        else:
            # Block diagonal matrix a (6n x 6n)
            a = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                a[6*i:6*i+6, 6*i:6*i+6] = SE3adMatrix(self.X[i])*qd[i]
            self._a = a

        # System acceleration (6n x 1)
        Vd = J*q2d - A*a*V

        # Block Diagonal Mb (6n x 6n) Mass inertia matrix in body frame 
        # (constant)
        Mb = zeros(6*self.n, 6*self.n)
        for i in range(self.n):
            Mb[i*6:i*6+6, i*6:i*6+6] = self.Mb[i]

        # Block diagonal matrix b (6n x 6n) used in Coriolis matrix
        b = zeros(6*self.n, 6*self.n)
        for i in range(self.n):
            b[i*6:i*6+6, i*6:i*6+6] = SE3adMatrix(Matrix(V[6*i:6*i+6]))

        # Block diagonal matrix Cb (6n x 6n)
        Cb = -Mb*A*a - b.T * Mb

        # Lets setup the Equations of Motion

        # Mass inertia matrix in joint space (n x n)
        M = J.T*Mb*J
        if simplify:
            M = self.simplify(M, cse)
        elif cse:
            M = self._cse_expression(M)

        # Coriolis-Centrifugal matrix in joint space (n x n)
        C = J.T * Cb * J
        if simplify:
            C = self.simplify(C, cse)
        elif cse:
            C = self._cse_expression(C)

        # Gravity Term
        U = SE3AdjInvMatrix(FK_C[0])
        for k in range(1, self.n):
            U = U.col_join(SE3AdjInvMatrix(FK_C[k]))

        Vd_0 = zeros(6, 1)
        Vd_0[3:6, 0] = self.gravity_vector
        Qgrav = J.T*Mb*U*Vd_0
        if simplify:
            Qgrav = self.simplify(Qgrav, cse)
        elif cse:
            Qgrav = self._cse_expression(Qgrav)

        # External Wrench
        Wext = zeros(6*self.n, 1)
        # WEE (t) is the time varying wrench on the EE link.
        for i in range(self.n_ee):
            Wext[6*(self.ee_parent[i]-1):6*self.ee_parent[i], 0] = WEE[i if len(WEE) == self.n_ee else 0] # TODO: ee idx
        Qext = J.T * Wext

        # Generalized forces Q
        # Q = M*q2d + C*qd   # without gravity
        Q = M*q2d + C*qd + Qgrav + Qext

        if simplify:
            Q = self.simplify(Q, cse)
        elif cse:
            Q = self._cse_expression(Q)

        self.M = M
        self.C = C
        self.Q = Q
        self.Qgrav = Qgrav

        ##### First Order Derivatives of EOM #####
        if q3d is not None:        
            # First time derivative of Block diagonal matrix a (6n x 6n)
            ad = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                ad[i*6:i*6+6, i*6:i*6+6] = q2d[i] * SE3adMatrix(self.X[i])

            # Third order Forward Kinematics
            V2d = J*q3d - A*ad*V - 2*A*a*Vd - A*a*a*V
                        
            #  First time derivative of Block diagonal matrix b (6n x 6n) 
            # used in Coriolis matrix
            bd = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                bd[i*6:i*6+6, i*6:i*6+6] = SE3adMatrix(Matrix(Vd[i*6:i*6+6]))
            
            # First time derivative of Mass inertia matrix in joint space (n x n)
            Mbd = -Mb*A*a - (Mb*A*a).T
            Md = J.T * Mbd * J
            if simplify:
                Md = self.simplify(Md, cse)
            elif cse:
                Md = self._cse_expression(Md)
            
            # First time derivative of Coriolis-Centrifugal matrix in joint space (n x n)
            Cbd = Mb*A*a*A*a - Mb*A*a*a - Mb*A*ad - bd.T * Mb - Cb*A*a - a.T*A.T*Cb
            Cd = J.T*Cbd*J
            if simplify:
                Cd = self.simplify(Cd, cse)
            elif cse:
                Cd = self._cse_expression(Cd)
            
            # First time derivative of gravity force
            Qdgrav = J.T*Mbd*U*Vd_0
            if simplify:
                Qdgrav = self.simplify(Qdgrav, cse)
            elif cse:
                Qdgrav = self._cse_expression(Qdgrav)
            
            # First time derivative of External Wrench
            Wdext = zeros(6*self.n,1)
            for i in range(self.n_ee):
                Wdext[6*(self.ee_parent[i]-1):6*self.ee_parent[i], 0] = WDEE[i if len(WDEE) == self.n_ee else 0]
            Qdext = J.T*(Wdext - (A*a).T * Wext)
            
            # Qd = M*q3d + (Md + C)*q2d + Cd*qd  # without gravity 
            Qd = M*q3d + (Md + C)*q2d + Cd*qd + Qdgrav + Qdext # with gravity
            if simplify:
                Qd = self.simplify(Qd, cse)
            elif cse:
                Qd = self._cse_expression(Qd)
            
            self.Md = Md
            self.Cd = Cd
            self.Qdgrav = Qdgrav
            self.Qd = Qd

        ##### Second Order Derivatives of EOM #####
        if q3d is not None and q4d is not None:        
            # Second time derivative of Block diagonal matrix a (6n x 6n)
            a2d = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                a2d[i*6:i*6+6, i*6:i*6+6] = SE3adMatrix(self.X[i]) * q3d[i]
                
            # Second time derivative of Block diagonal matrix b (6n x 6n) 
            # used in Coriolis matrix
            b2d = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                b2d[i*6:i*6+6, i*6:i*6+6] = SE3adMatrix(Matrix(V2d[i*6:i*6+6]))
                
            # Second time derivative of Mass inertia matrix in joint space (n x n)
            Mb2d = (- Mb*A*ad - (Mb*A*ad).T + 2*Mb*A*a*A*a + 2*(Mb*A*a*A*a).T 
                    + 2*a.T*A.T*Mb*A*a - Mb*A*a*a - (Mb*A*a*a).T)
            M2d = J.T*Mb2d*J
            if simplify:
                M2d = self.simplify(M2d, cse)
            elif cse:
                M2d = self._cse_expression(M2d)

            # Second time derivative of Coriolis-Centrifugal matrix in joint space (n x n)
            Cddot = (- Mb*A*a2d - 3*Mb*A*a*ad - Mb*A*a*a*a - b2d.T*Mb 
                     + Mb*A*ad*A*a + Mb*A*a*a*A*a + 2*Mb*A*a*A*ad 
                     + 2*Mb*A*a*A*a*a - 2*Mb*A*a*A*a*A*a)
            Cb2d = (Cddot - (Cbd + a.T*A.T*Cb)*A*a - a.T*A.T*(Cbd + Cb*A*a) 
                    - Cb*A*ad - ad.T*A.T*Cb - Cb*A*a*a - a.T*a.T*A.T*Cb 
                    - Cbd*A*a - a.T*A.T*Cbd)
            C2d = J.T*Cb2d*J
            if simplify:
                C2d = self.simplify(C2d, cse)
            elif cse:
                C2d = self._cse_expression(C2d)
            
            # Second time derivative of gravity force
            Q2dgrav = J.T*Mb2d*U*Vd_0
            if simplify:
                Q2dgrav = self.simplify(Q2dgrav, cse)
            elif cse:
                Q2dgrav = self._cse_expression(Q2dgrav)

            # Second time derivative of External Wrench
            W2dext = zeros(6*self.n,1)
            for i in range(self.n_ee):
                W2dext[6*(self.ee_parent[i]-1):6*self.ee_parent[i], 0] = W2DEE[i if len(W2DEE) == self.n_ee else 0]
            Q2dext = J.T*(W2dext - 2*(A*a).T*Wdext + (2*(A*a*A*a).T - (A*ad).T - (A*a*a).T)*Wext)
            
            # Second time derivative of generalized forces
            # without gravity:
            # Q2d = M*q4d + (2*Md + C)*q3d + (M2d + 2*Cd)*q2d + C2d*qd   
            # with gravity and external forces:
            Q2d = M*q4d + (2*Md + C)*q3d + (M2d + 2*Cd)*q2d + C2d*qd + Q2dgrav + Q2dext
            if simplify:
                Q2d = self.simplify(Q2d, cse)
            elif cse:
                Q2d = self._cse_expression(Q2d)
            
            self.M2d = M2d
            self.C2d = C2d
            self.Q2dgrav = Q2dgrav
            self.Q2d = Q2d

        # save used symbols
        for e in self._get_expressions():
            self.all_symbols.update(e.free_symbols)

        print(&#34;Done&#34;)
        return Q

    def _closed_form_kinematics_body_fixed_parallel(
        self, q: MutableDenseMatrix, qd: MutableDenseMatrix, 
        q2d: MutableDenseMatrix, simplify: bool=True, 
        cse: bool=False) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Position, velocity and acceleration kinematics using 
        body fixed representation of the twists in closed form.

        The following expressions are saved in the class and can be 
        code generated afterwards:
            body_acceleration
            body_acceleration_ee
            body_jacobian_matrix
            body_jacobian_matrix_dot 
            body_jacobian_matrix_ee
            body_jacobian_matrix_ee_dot
            body_twist_ee
            forward_kinematics
            hybrid_acceleration
            hybrid_acceleration_ee
            hybrid_jacobian_matrix
            hybrid_jacobian_matrix_dot
            hybrid_jacobian_matrix_ee
            hybrid_jacobian_matrix_ee_dot
            hybrid_twist_ee

        Args:
            q (sympy.Matrix): 
                (n,1) Generalized position vector.
            qd (sympy.Matrix): 
                (n,1) Generalized velocity vector.
            q2d (sympy.Matrix): 
                (n,1) Generalized acceleration vector.
            simplify (bool, optional): 
                Use simplify command on saved expressions. 
                Defaults to True.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.

        Returns:
            sympy.Matrix: Forward kinematics.
        &#34;&#34;&#34;
        # This method does the same as _closed_form_kinematics_body_fixed.
        # Parallel computation is implemented by writing most values 
        # in queues, organized in a dict.
        # This ensures the correct order for the execution.
        # To understand the calculations it is recommended to read the 
        # code in _closed_form_kinematics_body_fixed since it is more 
        # readable and has the same structure.

        print(&#34;Forward kinematics calculation&#34;)
        self.var_syms.update(q.free_symbols)
        self.var_syms.update(qd.free_symbols)
        self.var_syms.update(q2d.free_symbols)

        self.n = len(q)
        self.queue_dict[&#34;subex_dict&#34;] = Queue()

        # calc Forward kinematics
        if self.parent and self.support:
            FK_C, A = self._calc_A_matrix_tree(q)
        else:    
            FK_C, A = self._calc_A_matrix(q)
        
        for i in range(self.n_ee):
            self._set_value(f&#34;fkin{i}&#34;, FK_C[self.ee_parent[i]-1]*self.ee[i])
            if simplify:
                self._start_simplification_process(f&#34;fkin{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;fkin{i}&#34;)

        if self.J is not None:
            self._set_value(&#34;J&#34;, self.J)
            self._set_value(&#34;V&#34;, self._V)
        else:
            # Block diagonal matrix X (6n x n) of the screw coordinate 
            # vector associated to all joints in the body frame (Constant)
            X = zeros(6*self.n, self.n)
            for i in range(self.n):
                X[6*i:6*i+6, i] = self.X[i]

            # System level Jacobian
            self._set_value(&#34;J&#34;, A*X)
            if simplify:
                self._start_simplification_process(&#34;J&#34;, cse)
            elif cse:
                self._start_cse_process(&#34;J&#34;)
            # System twist (6n x 1)
            self._set_value_as_process(&#34;V&#34;, lambda: self._get_value(&#34;J&#34;)*qd)

        for i in range(self.n_ee):
            # Different Jacobians
            self._set_value_as_process(
                f&#34;R_i{i}&#34;, 
                lambda: 
                    Matrix(self._get_value(f&#34;fkin{i}&#34;)[:3, :3])
                    .row_join(zeros(3, 1))
                    .col_join(Matrix([0, 0, 0, 1]).T)
                )

            if simplify:  # fastens later simplifications
                self._start_simplification_process(f&#34;R_i{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;R_i{i}&#34;)

            self._set_value(f&#34;R_BFn{i}&#34;, Matrix(FK_C[self.ee_parent[i]-1][:3, :3]).row_join(
                zeros(3, 1)).col_join(Matrix([0, 0, 0, 1]).T)) 

            # Body fixed Jacobian of last moving body 
            # (This may not correspond to end-effector frame)
            self._set_value_as_process(
                f&#34;Jb{i}&#34;, 
                lambda: self._get_value(&#34;J&#34;)[6*(self.ee_parent[i]-1):6*self.ee_parent[i], :])
            if simplify:
                self._start_simplification_process(f&#34;Jb{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Jb{i}&#34;)

            self._set_value_as_process(f&#34;Vb_BFn{i}&#34;, lambda: self._get_value(f&#34;Jb{i}&#34;)*qd)
            # Body fixed twist of last moving body
            if simplify:
                self._start_simplification_process(f&#34;Vb_BFn{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Vb_BFn{i}&#34;)

            self._set_value_as_process(f&#34;Vh_BFn{i}&#34;, lambda: SE3AdjMatrix(
                self._get_value(f&#34;R_BFn{i}&#34;))*self._get_value(f&#34;Vb_BFn{i}&#34;))
            if simplify:
                self._start_simplification_process(f&#34;Vh_BFn{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Vh_BFn{i}&#34;)

            # Body fixed twist of end-effector frame
            self._set_value_as_process(f&#34;Vb_ee{i}&#34;, lambda: SE3AdjMatrix(
                SE3Inv(self.ee[i]))*self._get_value(f&#34;Vb_BFn{i}&#34;))
            if simplify:
                self._start_simplification_process(f&#34;Vb_ee{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Vb_ee{i}&#34;)
            # Hybrid twist of end-effector frame
            self._set_value_as_process(f&#34;Vh_ee{i}&#34;, lambda: SE3AdjMatrix(
                self._get_value(f&#34;R_i{i}&#34;))*self._get_value(f&#34;Vb_ee{i}&#34;))
            if simplify:
                self._start_simplification_process(f&#34;Vh_ee{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Vh_ee{i}&#34;)

            # Body fixed Jacobian of end-effector frame
            self._set_value_as_process(f&#34;Jb_ee{i}&#34;, lambda: SE3AdjMatrix(
                SE3Inv(self.ee[i]))*self._get_value(f&#34;Jb{i}&#34;))
            if simplify:
                self._start_simplification_process(f&#34;Jb_ee{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Jb_ee{i}&#34;)

            # Hybrid Jacobian of end-effector frame
            self._set_value_as_process(f&#34;Jh_ee{i}&#34;, lambda: SE3AdjMatrix(
                self._get_value(f&#34;R_i{i}&#34;))*self._get_value(f&#34;Jb_ee{i}&#34;))
            # Hybrid Jacobian of last moving body
            self._set_value_as_process(f&#34;Jh{i}&#34;, lambda: SE3AdjMatrix(
                self._get_value(f&#34;R_i{i}&#34;))*self._get_value(f&#34;Jb{i}&#34;))

            if simplify:
                self._start_simplification_process(f&#34;Jh_ee{i}&#34;, cse)
                self._start_simplification_process(f&#34;Jh{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Jh_ee{i}&#34;)
                self._start_cse_process(f&#34;Jh{i}&#34;)

        # Acceleration computations
        if self._a is not None:
            self._set_value(&#34;a&#34;, self._a)
        else:
            # Block diagonal matrix a (6n x 6n)
            a = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                a[6*i:6*i+6, 6*i:6*i+6] = SE3adMatrix(self.X[i])*qd[i]
            self._set_value(&#34;a&#34;, a)
            if simplify:
                self._start_simplification_process(&#34;a&#34;, cse)
            elif cse:
                self._start_cse_process(&#34;a&#34;)

        # System acceleration (6n x 1)
        # System-level Jacobian time derivative
        self._set_value_as_process(
            &#34;Jdot&#34;, lambda: -A*self._get_value(&#34;a&#34;)*self._get_value(&#34;J&#34;))
        if simplify:
            self._start_simplification_process(&#34;Jdot&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Jdot&#34;)

        self._set_value_as_process(&#34;Vbd&#34;, lambda: self._get_value(
            &#34;J&#34;)*q2d - A*self._get_value(&#34;a&#34;)*self._get_value(&#34;V&#34;))

        for i in range(self.n_ee):
            # Hybrid acceleration of the last body
            self._set_value_as_process(
                f&#34;Vbd_BFn{i}&#34;, lambda: self._get_value(&#34;Vbd&#34;)[6*(self.ee_parent[i]-1):6*self.ee_parent[i], :])

            if simplify:
                self._start_simplification_process(f&#34;Vbd_BFn{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Vbd_BFn{i}&#34;)

            # Hybrid twist of end-effector frame
            self._set_value_as_process(
                f&#34;Vhd_BFn{i}&#34;, 
                lambda: 
                    SE3AdjMatrix(self._get_value(f&#34;R_BFn{i}&#34;))
                    * self._get_value(f&#34;Vbd_BFn{i}&#34;) 
                    + SE3adMatrix(Matrix(self._get_value(f&#34;Vh_BFn{i}&#34;)[:3, :])
                                    .col_join(Matrix([0, 0, 0])))
                    * SE3AdjMatrix(self._get_value(f&#34;R_BFn{i}&#34;))
                    * self._get_value(f&#34;Vb_BFn{i}&#34;)
                )

            if simplify:
                self._start_simplification_process(f&#34;Vhd_BFn{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Vhd_BFn{i}&#34;)

            # Body fixed twist of end-effector frame
            # Hybrid acceleration of the EE
            self._set_value_as_process(f&#34;Vbd_ee{i}&#34;, lambda: SE3AdjMatrix(
                SE3Inv(self.ee[i]))*self._get_value(f&#34;Vbd_BFn{i}&#34;))
            if simplify:
                self._start_simplification_process(f&#34;Vbd_ee{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Vbd_ee{i}&#34;)
            # Hybrid twist of end-effector frame
            self._set_value_as_process(
                f&#34;Vhd_ee{i}&#34;, 
                lambda: 
                    SE3AdjMatrix(self._get_value(f&#34;R_i{i}&#34;)) 
                    * self._get_value(f&#34;Vbd_ee{i}&#34;) 
                    + SE3adMatrix(Matrix(self._get_value(f&#34;Vh_ee{i}&#34;)[:3, :])
                                    .col_join(Matrix([0, 0, 0])))
                    * SE3AdjMatrix(self._get_value(f&#34;R_i{i}&#34;))
                    * self._get_value(f&#34;Vb_ee{i}&#34;)
                )  # Hybrid twist of end-effector frame

            if simplify:
                self._start_simplification_process(f&#34;Vhd_ee{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Vhd_ee{i}&#34;)

            # Body Jacobian time derivative

            # For the last moving body
            self._set_value_as_process(
                f&#34;Jb_dot{i}&#34;, lambda: self._get_value(&#34;Jdot&#34;)[6*(self.ee_parent[i]-1):6*self.ee_parent[i], :])

            # For the EE
            self._set_value_as_process(f&#34;Jb_ee_dot{i}&#34;, lambda: SE3AdjMatrix(
                SE3Inv(self.ee[i]))*self._get_value(f&#34;Jb_dot{i}&#34;))
            if simplify:
                self._start_simplification_process(f&#34;Jb_ee_dot{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Jb_ee_dot{i}&#34;)

            # Hybrid Jacobian time derivative
            # For the last moving body
            self._set_value_as_process(
                f&#34;Jh_dot{i}&#34;, 
                lambda: 
                    SE3AdjMatrix(self._get_value(f&#34;R_BFn{i}&#34;))
                    * self._get_value(f&#34;Jb_dot{i}&#34;) 
                    + SE3adMatrix(Matrix(self._get_value(f&#34;Vh_BFn{i}&#34;)[:3, :])
                                    .col_join(Matrix([0, 0, 0])))
                    * SE3AdjMatrix(self._get_value(f&#34;R_BFn{i}&#34;))
                    * self._get_value(f&#34;Jb{i}&#34;)
                )
            if simplify:
                self._start_simplification_process(f&#34;Jh_dot{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Jh_dot{i}&#34;)

            # For the EE
            self._set_value_as_process(
                f&#34;Jh_ee_dot{i}&#34;, 
                lambda: 
                    SE3AdjMatrix(self._get_value(f&#34;R_i{i}&#34;))
                    * self._get_value(f&#34;Jb_ee_dot{i}&#34;) 
                    + SE3adMatrix(Matrix(self._get_value(f&#34;Vh_ee{i}&#34;)[:3, :])
                                    .col_join(Matrix([0, 0, 0])))
                    * SE3AdjMatrix(self._get_value(f&#34;R_i{i}&#34;))
                    * self._get_value(f&#34;Jb_ee{i}&#34;)
                )
            if simplify:
                self._start_simplification_process(f&#34;Jh_ee_dot{i}&#34;, cse)
            elif cse:
                self._start_cse_process(f&#34;Jh_ee_dot{i}&#34;)
                
        self._a = self._get_value(&#34;a&#34;)
        self._V = self._get_value(&#34;V&#34;)

        # variables for Code Generation:
        self.J = self._get_value(&#34;J&#34;)
        self.Jdot = self._get_value(&#34;Jdot&#34;)
        self.fkin = [self._get_value(f&#34;fkin{i}&#34;) for i in range(self.n_ee)]
        self.Jb = [self._get_value(f&#34;Jb{i}&#34;) for i in range(self.n_ee)]
        self.Jh = [self._get_value(f&#34;Jh{i}&#34;) for i in range(self.n_ee)]
        self.Vb_ee = [self._get_value(f&#34;Vb_ee{i}&#34;) for i in range(self.n_ee)]
        self.Vh_ee = [self._get_value(f&#34;Vh_ee{i}&#34;) for i in range(self.n_ee)]
        self.Jb_ee = [self._get_value(f&#34;Jb_ee{i}&#34;) for i in range(self.n_ee)]
        self.Jh_ee = [self._get_value(f&#34;Jh_ee{i}&#34;) for i in range(self.n_ee)]
        self.Vh_BFn = [self._get_value(f&#34;Vh_BFn{i}&#34;) for i in range(self.n_ee)]
        self.Vb_BFn = [self._get_value(f&#34;Vb_BFn{i}&#34;) for i in range(self.n_ee)]
        self.Vhd_BFn = [self._get_value(f&#34;Vhd_BFn{i}&#34;) for i in range(self.n_ee)]
        self.Vbd_BFn = [self._get_value(f&#34;Vbd_BFn{i}&#34;) for i in range(self.n_ee)]
        self.Vhd_ee = [self._get_value(f&#34;Vhd_ee{i}&#34;) for i in range(self.n_ee)]
        self.Vbd_ee = [self._get_value(f&#34;Vbd_ee{i}&#34;) for i in range(self.n_ee)]
        self.Jh_dot = [self._get_value(f&#34;Jh_dot{i}&#34;) for i in range(self.n_ee)]
        self.Jb_dot = [self._get_value(f&#34;Jb_dot{i}&#34;) for i in range(self.n_ee)]
        self.Jh_ee_dot = [self._get_value(f&#34;Jh_ee_dot{i}&#34;) for i in range(self.n_ee)]
        self.Jb_ee_dot = [self._get_value(f&#34;Jb_ee_dot{i}&#34;) for i in range(self.n_ee)]

        if self.n_ee == 1:
            self.fkin = self.fkin[0] 
            self.Jb = self.Jb[0] 
            self.Jh = self.Jh[0] 
            self.Vb_ee = self.Vb_ee[0] 
            self.Vh_ee = self.Vh_ee[0] 
            self.Jb_ee = self.Jb_ee[0] 
            self.Jh_ee = self.Jh_ee[0] 
            self.Vh_BFn = self.Vh_BFn[0] 
            self.Vb_BFn = self.Vb_BFn[0] 
            self.Vhd_BFn = self.Vhd_BFn[0] 
            self.Vbd_BFn = self.Vbd_BFn[0] 
            self.Vhd_ee = self.Vhd_ee[0] 
            self.Vbd_ee = self.Vbd_ee[0] 
            self.Jh_dot = self.Jh_dot[0] 
            self.Jb_dot = self.Jb_dot[0] 
            self.Jh_ee_dot = self.Jh_ee_dot[0] 
            self.Jb_ee_dot = self.Jb_ee_dot[0] 
        
        try:
            while True:
                self.subex_dict.update(
                    self.queue_dict[&#34;subex_dict&#34;].get(timeout=0.05))
        except queue.Empty:
            pass

        # empty Queues
        for i in self.queue_dict:
            self._flush_queue(self.queue_dict[i])
        self.queue_dict = {}

        # join Processes
        for i in self.process_dict:
            self.process_dict[i].join()
        self.process_dict = {}

        # save used symbols
        for e in self._get_expressions():
            self.all_symbols.update(e.free_symbols)

        print(&#34;Done&#34;)
        return self.fkin

    def _closed_form_inv_dyn_body_fixed_parallel(
        self, 
        q: MutableDenseMatrix, 
        qd: MutableDenseMatrix, 
        q2d: MutableDenseMatrix, 
        q3d: MutableDenseMatrix, 
        q4d: MutableDenseMatrix, 
        WEE: List[MutableDenseMatrix]=[zeros(6, 1)], 
        WDEE: List[MutableDenseMatrix]=[zeros(6, 1)], 
        W2DEE: List[MutableDenseMatrix]=[zeros(6, 1)], 
        simplify: bool=True, cse: bool=False) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Inverse dynamics using body fixed representation of the 
        twists in closed form. 

        The following expressions are saved in the class and can be 
        code generated afterwards:
            coriolis_centrifugal_matrix
            generalized_mass_inertia_matrix
            gravity_vector
            inverse_dynamics

        Args:
            q (sympy.Matrix): 
                (n,1) Generalized position vector.
            qd (sympy.Matrix): 
                (n,1 )Generalized velocity vector.
            q2d (sympy.Matrix): 
                (n,1) Generalized acceleration vector.
            q3d (sympy.Matrix, optional): 
                (n,1) Generalized jerk vector. Defaults to None.
            q4d (sympy.Matrix, optional): 
                (n,1) Generalized jounce vector. Defaults to None.
            WEE (list of sympy.Matrix, optional): 
                (6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time varying 
                wrench on the EE link. 
                Defaults to [zeros(6, 1)].
            WDEE (list of sympy.Matrix, optional): 
                (6,1) WDEE (t) = [dMx,dMy,dMz,dFx,dFy,dFz] is the derivative 
                of the time varying wrench on the EE link. 
                Defaults to [zeros(6, 1)].
            W2DEE (list of sympy.Matrix, optional): 
                (6,1) W2DEE (t) = [ddMx,ddMy,ddMz,ddFx,ddFy,ddFz] is the 
                2nd derivative of the time varying wrench on the EE link. 
                Defaults to [zeros(6, 1)].
            simplify (bool, optional): 
                Use simplify command on saved expressions. 
                Defaults to True.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.

        Returns:
            sympy.Matrix: Generalized Forces
        &#34;&#34;&#34;
        # This method does the same as _closed_form_inv_dyn_body_fixed.
        # Parallel computation is implemented by writing most values 
        # in queues, organized in a dict.
        # This ensures the correct order for the execution.
        # To understand the calculations it is recommended to read the 
        # code in _closed_form_inv_dyn_body_fixed since it is more 
        # readable and has the same structure.

        print(&#34;Inverse dynamics calculation&#34;)

        self.var_syms.update(q.free_symbols)
        self.var_syms.update(qd.free_symbols)
        self.var_syms.update(q2d.free_symbols)
        if q3d: self.var_syms.update(q3d.free_symbols)
        if q4d: self.var_syms.update(q4d.free_symbols)
        for W in WEE:
            self.optional_var_syms.update(W.free_symbols)
        for WD in WDEE:
            self.optional_var_syms.update(WD.free_symbols)
        for W2D in W2DEE:
            self.optional_var_syms.update(W2D.free_symbols)
        
        self.n = len(q)
        self.queue_dict[&#34;subex_dict&#34;] = Queue()

        # calc Forward kinematics
        if self.parent and self.support:
            FK_C, A = self._calc_A_matrix_tree(q)
        else:    
            FK_C, A = self._calc_A_matrix(q)
        
        if self.J is not None:
            self._set_value(&#34;J&#34;, self.J)
            self._set_value(&#34;V&#34;, self._V)
        else:
            # Block diagonal matrix X (6n x n) of the screw coordinate 
            # vector associated to all joints in the body frame (Constant)
            X = zeros(6*self.n, self.n)
            for i in range(self.n):
                X[6*i:6*i+6, i] = self.X[i]

            # System level Jacobian
            self._set_value(&#34;J&#34;, A*X)
            if simplify:
                self._start_simplification_process(&#34;J&#34;, cse)
            elif cse:
                self._start_cse_process(&#34;J&#34;)

            # System twist (6n x 1)
            self._set_value_as_process(&#34;V&#34;, lambda: self._get_value(&#34;J&#34;)*qd)

        # Acceleration computations

        if self._a is not None:
            a = self._a
        else:
            # Block diagonal matrix a (6n x 6n)
            a = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                a[6*i:6*i+6, 6*i:6*i+6] = SE3adMatrix(self.X[i])*qd[i]
            self._a = a

        # System acceleration (6n x 1)
        # Vd = J*q2d - A*a*V
        self._set_value_as_process(&#34;Vd&#34;, lambda: self._get_value(
            &#34;J&#34;)*q2d - A*a*self._get_value(&#34;V&#34;))

        # Block Diagonal Mb (6n x 6n) Mass inertia matrix in body frame 
        # (Constant)
        Mb = zeros(6*self.n, 6*self.n)
        for i in range(self.n):
            Mb[i*6:i*6+6, i*6:i*6+6] = self.Mb[i]

        # Block diagonal matrix b (6n x 6n) used in Coriolis matrix
        def _b():
            nonlocal self
            b = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                b[i*6:i*6+6, i*6:i*6 + 6] = SE3adMatrix(
                    Matrix(self._get_value(&#34;V&#34;)[6*i:6*i+6]))
            return b
        self._set_value_as_process(&#34;b&#34;, _b)

        # Block diagonal matrix Cb (6n x 6n)
        self._set_value_as_process(
            &#34;Cb&#34;, lambda: -Mb*A*a - self._get_value(&#34;b&#34;).T * Mb)

        # Lets setup the Equations of Motion

        # Mass inertia matrix in joint space (n x n)
        self._set_value_as_process(
            &#34;M&#34;, lambda: self._get_value(&#34;J&#34;).T*Mb*self._get_value(&#34;J&#34;))
        if simplify:
            self._start_simplification_process(&#34;M&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;M&#34;)

        # Coriolis-Centrifugal matrix in joint space (n x n)
        self._set_value_as_process(&#34;C&#34;, lambda: self._get_value(
            &#34;J&#34;).T*self._get_value(&#34;Cb&#34;)*self._get_value(&#34;J&#34;))
        if simplify:
            self._start_simplification_process(&#34;C&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;C&#34;)

        # Gravity Term
        U = SE3AdjInvMatrix(FK_C[0])
        for k in range(1, self.n):
            U = U.col_join(SE3AdjInvMatrix(FK_C[k]))

        Vd_0 = zeros(6, 1)
        Vd_0[3:6, 0] = self.gravity_vector
        self._set_value_as_process(
            &#34;Qgrav&#34;, lambda: self._get_value(&#34;J&#34;).T*Mb*U*Vd_0)
        if simplify:
            self._start_simplification_process(&#34;Qgrav&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Qgrav&#34;)

        # External Wrench
        Wext = zeros(6*self.n, 1)
        # WEE (t) is the time varying wrench on the EE link.
        for i in range(self.n_ee):
                Wext[6*(self.ee_parent[i]-1):6*self.ee_parent[i], 0] = WEE[i if len(WEE) == self.n_ee else 0]
        self._set_value_as_process(
            &#34;Qext&#34;, lambda: self._get_value(&#34;J&#34;).T * Wext)

        # Generalized forces Q
        self._set_value_as_process(
            &#34;Q&#34;, 
            lambda: 
                self._get_value(&#34;M&#34;) * q2d 
                + self._get_value(&#34;C&#34;) * qd 
                + self._get_value(&#34;Qgrav&#34;) 
                + self._get_value(&#34;Qext&#34;)
            )

        if simplify:
            self._start_simplification_process(&#34;Q&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Q&#34;)

        ##### First Order Derivatives of EOM #####
        if q3d is not None:
            # First time derivative of Block diagonal matrix a (6n x 6n)
            ad = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                ad[i*6:i*6+6, i*6:i*6+6] = q2d[i] * SE3adMatrix(self.X[i])

            # Third order Forward Kinematics
            self._set_value_as_process(
                &#34;V2d&#34;, 
                lambda: self._get_value(&#34;J&#34;)*q3d - A*ad*self._get_value(&#34;V&#34;)
                - 2*A*a*self._get_value(&#34;Vd&#34;) - A*a*a*self._get_value(&#34;V&#34;))
                        
            #  First time derivative of Block diagonal matrix b (6n x 6n) 
            # used in Coriolis matrix
            def _bd():
                nonlocal self
                bd = zeros(6*self.n, 6*self.n)
                for i in range(self.n):
                    bd[i*6:i*6+6, i*6:i*6+6] = SE3adMatrix(Matrix(self._get_value(&#34;Vd&#34;)[i*6:i*6+6]))
                return bd
            self._set_value_as_process(&#34;bd&#34;, _bd)
            
            # First time derivative of Mass inertia matrix in joint space (n x n)
            Mbd = -Mb*A*a - (Mb*A*a).T
            self._set_value_as_process(
                &#34;Md&#34;,
                lambda: self._get_value(&#34;J&#34;).T * Mbd * self._get_value(&#34;J&#34;))
            if simplify:
                self._start_simplification_process(&#34;Md&#34;,cse)
            elif cse:
                self._start_cse_process(&#34;Md&#34;)
            
            # First time derivative of Coriolis-Centrifugal matrix in joint space (n x n)
            self._set_value_as_process(
                &#34;Cbd&#34;,
                lambda: Mb*A*a*A*a - Mb*A*a*a - Mb*A*ad - self._get_value(&#34;bd&#34;).T * Mb 
                        - self._get_value(&#34;Cb&#34;)*A*a - a.T*A.T*self._get_value(&#34;Cb&#34;))
            self._set_value_as_process(
                &#34;Cd&#34;, 
                lambda: self._get_value(&#34;J&#34;).T*self._get_value(&#34;Cbd&#34;)*self._get_value(&#34;J&#34;))
            if simplify:
                self._start_simplification_process(&#34;Cd&#34;,cse)
            elif cse:
                self._start_cse_process(&#34;Cd&#34;)
            
            # First time derivative of gravity force
            self._set_value_as_process(
                &#34;Qdgrav&#34;,
                lambda: self._get_value(&#34;J&#34;).T*Mbd*U*Vd_0)
            if simplify:
                self._start_simplification_process(&#34;Qdgrav&#34;,cse)
            elif cse:
                self._start_cse_process(&#34;Qdgrav&#34;)
            
            # First time derivative of External Wrench
            Wdext = zeros(6*self.n,1)
            for i in range(self.n_ee):
                Wdext[6*(self.ee_parent[i]-1):6*self.ee_parent[i], 0] = WDEE[i if len(WDEE) == self.n_ee else 0]
            self._set_value_as_process(
                &#34;Qdext&#34;,
                lambda: self._get_value(&#34;J&#34;).T*(Wdext - (A*a).T * Wext))
            
            self._set_value_as_process(
                &#34;Qd&#34;,
                lambda: self._get_value(&#34;M&#34;)*q3d 
                        + (self._get_value(&#34;Md&#34;) + self._get_value(&#34;C&#34;))*q2d 
                        + self._get_value(&#34;Cd&#34;)*qd + self._get_value(&#34;Qdgrav&#34;) 
                        + self._get_value(&#34;Qdext&#34;)
            )
            if simplify:
                self._start_simplification_process(&#34;Qd&#34;,cse)
            elif cse:
                self._start_cse_process(&#34;Qd&#34;)
            
        ##### Second Order Derivatives of EOM #####
        if q3d is not None and q4d is not None:        
            # Second time derivative of Block diagonal matrix a (6n x 6n)
            a2d = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                a2d[i*6:i*6+6, i*6:i*6+6] = SE3adMatrix(self.X[i]) * q3d[i]
                
            # Second time derivative of Block diagonal matrix b (6n x 6n) 
            # used in Coriolis matrix
            def _b2d():
                nonlocal self
                b2d = zeros(6*self.n, 6*self.n)
                for i in range(self.n):
                    b2d[i*6:i*6+6, i*6:i*6+6] = SE3adMatrix(
                        Matrix(self._get_value(&#34;V2d&#34;)[i*6:i*6+6]))
                return b2d
            self._set_value_as_process(&#34;b2d&#34;, _b2d)
                
            # Second time derivative of Mass inertia matrix in joint space (n x n)
            Mb2d = (- Mb*A*ad - (Mb*A*ad).T + 2*Mb*A*a*A*a + 2*(Mb*A*a*A*a).T 
                    + 2*a.T*A.T*Mb*A*a - Mb*A*a*a - (Mb*A*a*a).T)
            self._set_value_as_process(
                &#34;M2d&#34;,
                lambda: self._get_value(&#34;J&#34;).T*Mb2d*self._get_value(&#34;J&#34;))
            if simplify:
                self._start_simplification_process(&#34;M2d&#34;,cse)
            elif cse:
                self._start_cse_process(&#34;M2d&#34;)

            # Second time derivative of Coriolis-Centrifugal matrix in joint space (n x n)
            self._set_value_as_process(
                &#34;Cddot&#34;,
                lambda: - Mb*A*a2d - 3*Mb*A*a*ad - Mb*A*a*a*a 
                        - self._get_value(&#34;b2d&#34;).T*Mb 
                        + Mb*A*ad*A*a + Mb*A*a*a*A*a + 2*Mb*A*a*A*ad 
                        + 2*Mb*A*a*A*a*a - 2*Mb*A*a*A*a*A*a
            )
            self._set_value_as_process(
                &#34;Cb2d&#34;,
                lambda: self._get_value(&#34;Cddot&#34;) 
                        - (self._get_value(&#34;Cbd&#34;) + a.T*A.T*self._get_value(&#34;Cb&#34;))*A*a 
                        - a.T*A.T*(self._get_value(&#34;Cbd&#34;) + self._get_value(&#34;Cb&#34;)*A*a) 
                        - self._get_value(&#34;Cb&#34;)*A*ad - ad.T*A.T*self._get_value(&#34;Cb&#34;) 
                        - self._get_value(&#34;Cb&#34;)*A*a*a - a.T*a.T*A.T*self._get_value(&#34;Cb&#34;) 
                        - self._get_value(&#34;Cbd&#34;)*A*a - a.T*A.T*self._get_value(&#34;Cbd&#34;)
            )
            self._set_value_as_process(
                &#34;C2d&#34;,
                lambda: self._get_value(&#34;J&#34;).T*self._get_value(&#34;Cb2d&#34;)*self._get_value(&#34;J&#34;)
            )
            if simplify:
                self._start_simplification_process(&#34;C2d&#34;, cse)
            elif cse:
                self._start_cse_process(&#34;C2d&#34;)
            
            # Second time derivative of gravity force
            self._set_value_as_process(
                &#34;Q2dgrav&#34;,
                lambda: self._get_value(&#34;J&#34;).T*Mb2d*U*Vd_0
            )
            if simplify:
                self._start_simplification_process(&#34;Q2dgrav&#34;,cse)
            elif cse:
                self._start_cse_process(&#34;Q2dgrav&#34;)

            # Second time derivative of External Wrench
            W2dext = zeros(6*self.n,1)
            for i in range(self.n_ee):
                W2dext[6*(self.ee_parent[i]-1):6*self.ee_parent[i], 0] = W2DEE[i if len(W2DEE) == self.n_ee else 0]
            self._set_value_as_process(
                &#34;Q2dext&#34;,
                lambda: self._get_value(&#34;J&#34;).T
                        * (W2dext - 2*(A*a).T*Wdext + (2*(A*a*A*a).T - (A*ad).T - (A*a*a).T)*Wext) 
            )
            
            # Second time derivative of generalized forces
            # with gravity and external forces:
            self._set_value_as_process(
                &#34;Q2d&#34;,
                lambda: self._get_value(&#34;M&#34;)*q4d 
                        + (2*self._get_value(&#34;Md&#34;) + self._get_value(&#34;C&#34;))*q3d 
                        + (self._get_value(&#34;M2d&#34;) + 2*self._get_value(&#34;Cd&#34;))*q2d 
                        + self._get_value(&#34;C2d&#34;)*qd 
                        + self._get_value(&#34;Q2dgrav&#34;) 
                        + self._get_value(&#34;Q2dext&#34;) 
            )
            if simplify:
                self._start_simplification_process(&#34;Q2d&#34;,cse)
            elif cse:
                self._start_cse_process(&#34;Q2d&#34;)
                Q2d = self._cse_expression(Q2d)
            

        self._V = self._get_value(&#34;V&#34;)
        self.J = self._get_value(&#34;J&#34;)
        self.M = self._get_value(&#34;M&#34;)
        self.C = self._get_value(&#34;C&#34;)
        self.Qgrav = self._get_value(&#34;Qgrav&#34;)
        self.Q = self._get_value(&#34;Q&#34;)
        if q3d is not None:
            self.Md = self._get_value(&#34;Md&#34;)
            self.Cd = self._get_value(&#34;Cd&#34;)
            self.Qdgrav = self._get_value(&#34;Qdgrav&#34;)
            self.Qd = self._get_value(&#34;Qd&#34;)
        if q3d is not None and q4d is not None:
            self.M2d = self._get_value(&#34;M2d&#34;)
            self.C2d = self._get_value(&#34;C2d&#34;)
            self.Q2dgrav = self._get_value(&#34;Q2dgrav&#34;)
            self.Q2d = self._get_value(&#34;Q2d&#34;)

        try:
            while True:
                self.subex_dict.update(
                    self.queue_dict[&#34;subex_dict&#34;].get(timeout=0.05))
        except queue.Empty:
            pass

        # empty Queues
        for i in self.queue_dict:
            self._flush_queue(self.queue_dict[i])
        self.queue_dict = {}

        # join Processes
        for i in self.process_dict:
            self.process_dict[i].join()
        self.process_dict = {}

        # save used symbols
        for e in self._get_expressions():
            self.all_symbols.update(e.free_symbols)

        print(&#34;Done&#34;)
        return self.Q

    def partial_factor(self, exp: sympy.Expr) -&gt; sympy.Expr:
        &#34;&#34;&#34;Partial factor simplification for sympy expression.

        Args:
            exp (sympy.Expr): sympy expression.

        Returns:
            sympy.Expr: modified sympy expression.
        &#34;&#34;&#34;
        # split up matrices
        if (type(exp) == sympy.matrices.immutable.ImmutableDenseMatrix
            or type(exp) == sympy.matrices.dense.MutableDenseMatrix):
            new_expr = zeros(*exp.shape)
            for i in range(exp.shape[0]):
                for j in range(exp.shape[1]):
                    new_expr[i,j] = self.partial_factor(exp[i,j])
            return new_expr
            
        # seach for factors
        factor_map = defaultdict(set)
        const, additive_terms = exp.as_coeff_add()
        for term1, term2 in combinations(additive_terms, 2):
            common_terms = (
                set(term1.as_coeff_mul()[-1])
                &amp; set(term2.as_coeff_mul()[-1])
            )
            if common_terms:
                common_factor = sympy.Mul(*common_terms)
                factor_map[common_factor] |= {term1, term2}
        
        # sort by number of operations represented by the terms
        factor_list = sorted(
            factor_map.items(),
            key = lambda i: (i[0].count_ops() + 1) * len(i[1])
        )[::-1]

        # rebuild expression
        used = set()
        new_expr = nsimplify(0)
        for item in factor_list:
            factor = item[0]
            appearances = item[-1]
            terms = 0
            for instance in appearances:
                if instance not in used:
                    terms += instance.as_coefficient(factor)
                    used.add(instance)
            new_expr += factor * terms
        for term in set(additive_terms) - used:
            new_expr += term
        return new_expr + const

    def simplify(self, exp: sympy.Expr, cse: bool=False) -&gt; sympy.Expr:
        &#34;&#34;&#34;Faster simplify implementation for sympy expressions.
        Expressions can be different simplified as with sympy.simplify.

        Args:
            exp (sympy expression): 
                Expression to simplify.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.

        Returns:
            sympy expression: Simplified expression.
        &#34;&#34;&#34;
        if cse:
            exp = self._cse_expression(exp)
        if (type(exp) == sympy.matrices.immutable.ImmutableDenseMatrix
                or type(exp) == sympy.matrices.dense.MutableDenseMatrix):
            # fasten simplification of symmetric matrices
            if exp.is_square:
                # test if matrix is symmetric
                # numeric test is faster than is_symmetric method  for 
                # long expressions
                
                # create matrix with randon values
                num = lambdify(list(exp.free_symbols), exp, &#34;numpy&#34;)(
                    *(random.random() for i in exp.free_symbols))
                # if (random) matrix is symmetric, we have to simplify 
                # less values
                if numpy.allclose(num, num.T):
                    shape = exp.shape
                    m_exp = exp.as_mutable()
                    # simplify values only once in symmetric matrices
                    for i in range(shape[0]):
                        for j in range(i):
                            m_exp[i, j] = self.simplify(exp[i, j])
                            if i != j:
                                m_exp[j, i] = exp[j, i]
                    return Matrix(m_exp)
        if type(exp) == sympy.matrices.dense.MutableDenseMatrix:
            exp = exp.as_immutable()
        exp = fu(exp)  # fast function to simplify sin and cos expressions
        exp = cancel(exp)
        exp = factor(exp)
        exp = powsimp(exp)
        exp = self.partial_factor(exp)
        exp = exp.doit()
        return exp

    def _create_topology_lists(self,robot: URDF) -&gt; None:
        &#34;&#34;&#34;Generate parent, support and child list from URDF.

        Args:
            robot (URDF): URDF of robot.
        &#34;&#34;&#34;
        # names of all links in urdf
        link_names = [link.name for link in robot.links] 
        parent_names = [] # names of parent links corresponding link_names
        connection_type = [] # 0 for fixed, None for base, 1 else
        body_index = [] # index of link; -1 for fixed links
        parent = [] # parent array
        child = [] # child array
        support = [] # support array
        # find parent link names and search for fixed joints
        for name in link_names:
            for joint in robot.joints:
                if joint.child == name:
                    parent_names.append(joint.parent)
                    body_index.append(None) # specify later
                    if joint.joint_type == &#34;fixed&#34;:
                        connection_type.append(0)
                    else:
                        connection_type.append(1)
                    break
            else: # base link
                parent_names.append(None)
                connection_type.append(None)
                body_index.append(0)

        # generate body indices concatenating fixed bodies
        while None in body_index:
            i1 = body_index.index(None) # i of current link
            # update until parent is already specified
            while body_index[link_names.index(parent_names[i1])] is None:
                i1 = link_names.index(parent_names[i1])
            # fixed links get index -1
            if connection_type[i1] == 0:
                body_index[i1] = -1
                continue
            i2 = link_names.index(parent_names[i1]) # i of parent link
            while body_index[i2] == -1: # find forst non fixed parent
                i2 = link_names.index(parent_names[i2])
            index = body_index[i2]+1 # body index
            while index in body_index: # find first unused index
                index+=1
            body_index[i1] = index
            
        parent = [None for _ in range(max(body_index))] 
        child = [[] for _ in range(max(body_index))]
        support = [[] for _ in range(max(body_index))]

        # fill parent, child and support array
        for i in range(len(body_index)):
            idx = body_index[i] # get index of current body
            if idx &lt;= 0: # ignore base and fixed bodys
                continue
            i1 = link_names.index(parent_names[i]) # parent index
            while body_index[i1] == -1: # find first non fixed parent
                i1 = link_names.index(parent_names[i1])
            parent[idx-1] = body_index[i1] # save parent index
            if body_index[i1] &gt; 0: # ignore base
                child[body_index[i1]-1].append(idx) # save child to parent
            i2 = i
            while body_index[i2] != 0: # save all indices in support path
                if  body_index[i2] &gt; 0: # ignore fixed links
                    support[idx-1].append(body_index[i2])
                i2 = link_names.index(parent_names[i2])
            support[idx-1].reverse()
        self.support = support
        self.child = child
        self.parent = parent
            
    def _nsimplify(
        self,num: float, *args, max_denominator: int=0, **kwargs
        ) -&gt; Union[sympy.Expr, float]:
        &#34;&#34;&#34;Find a simple sympy representation for a number like 1/2 
        instead of 0.5. This function extends sympy.nsimplify with a 
        parameter to specify a maximum denominator to avoid simplifications
        like 13/157.  

        Args:
            num (float): number to simplify.
            max_denominator (int, optional): 
                maximum denominator to use. Use 0 to deactivate. 
                Defaults to 0.

        Returns:
            Union[sympy.Expr, float]: simplified number.
        &#34;&#34;&#34;
        ex = nsimplify(num,*args,**kwargs)
        if not max_denominator:
            return ex
        if ex.is_rational:
            try:
                d = ex.denominator
                if d &gt; max_denominator:
                    return num
            except ValueError:
                return ex
        elif type(ex) in {sympy.core.add.Add, sympy.core.power.Pow}:
            return num
        for i in regex.findall(&#34;(?&lt;=Rational\(\d*, )\d*&#34;, sympy.srepr(ex)):
            if abs(int(i)) &gt; max_denominator:
                return num
        return ex
        
    def load_from_urdf(self, path: str, symbolic: bool=True, 
                       cse: bool=False, simplify_numbers: bool=True,  
                       tolerance: float=0.0001, max_denominator: int=9) -&gt; None:
        &#34;&#34;&#34;Load robot from urdf.

        Args:
            path (str): path to URDF.
            symbolic (bool, optional): 
                generate symbols for numeric values. 
                Defaults to True.
            cse (bool, optional): 
                use common subexpression elimination. Defaults to False.
            simplify_numbers (bool, optional): 
                Use eg. pi/2 instead of 1.5708. Defaults to True.
            tolerance (float, optional): 
                tolerance for simplify_numbers. Defaults to 0.0001.
            max_denominator (int, optional): 
                Maximum denominator to use for simplify numbers to avoid
                values like 13/153. Use 0 to deactivate. Defaults to 9.

        Raises:
            NotImplementedError: supports only the joint types 
                &#34;revolute&#34;, &#34;continuous&#34; and &#34;prismatic&#34;.
        &#34;&#34;&#34;        
        with open(path, &#34;r&#34;) as f:
            robot = URDF.from_xml_string(f.read())
        self.B = []
        self.X = []
        self._create_topology_lists(robot) # TODO: check!
        fixed_origin = None
        fixed_links = []
        DOF = 0
        xyz_rpy_syms = []
        for joint in robot.joints:
            if joint.joint_type in [&#34;revolute&#34;, &#34;continuous&#34;, &#34;prismatic&#34;]:
                DOF += 1
            elif joint.joint_type in [&#34;fixed&#34;]:
                pass
            else:
                raise NotImplementedError(
                    &#34;Joint type &#39;&#34; + joint.joint_type+&#34;&#39; not implemented yet!&#34;)

        ji = 0  # joint index of used joints
        jia = 0  # joint index of all joints (fixed included)
        joint_origins = []
        for joint in robot.joints:
            name = joint.name
            origin = xyz_rpy_to_matrix(joint.origin.xyz+joint.origin.rpy)
            if symbolic:
                xyz_rpy = Matrix(joint.origin.xyz+joint.origin.rpy)
                xyz_rpy_syms.append(symbols(
                    &#34; &#34;.join([name+&#34;_%s&#34; % s for s in [&#34;x&#34;, &#34;y&#34;, &#34;z&#34;, &#34;roll&#34;, &#34;pitch&#34;, &#34;yar&#34;]])))
                xyzrpylist = []
                if simplify_numbers:
                    for i in range(6):
                        if (self._nsimplify(xyz_rpy[i], 
                                           tolerance=tolerance, 
                                           max_denominator=max_denominator) 
                            in [0, -1, 1, pi, -pi, pi/2, -pi/2, 3*pi/2, -3*pi/2]
                            ):
                            xyzrpylist.append(
                                self._nsimplify(xyz_rpy[i], tolerance=tolerance,
                                                max_denominator=max_denominator))
                        else:
                            xyzrpylist.append(xyz_rpy_syms[jia][i])
                            self.assignment_dict[xyz_rpy_syms[jia]
                                                 [i]] = xyz_rpy[i]
                else:
                    for i in range(6):
                        if xyz_rpy[i] == 0:
                            xyzrpylist.append(0)
                        elif xyz_rpy[i] == 1:
                            xyzrpylist.append(1)
                        elif xyz_rpy[i] == -1:
                            xyzrpylist.append(-1)
                        else:
                            xyzrpylist.append(xyz_rpy_syms[jia][i])
                            self.assignment_dict[xyz_rpy_syms[jia]
                                                 [i]] = xyz_rpy[i]
                origin = xyz_rpy_to_matrix(xyzrpylist)
                if cse:
                    origin = self._cse_expression(origin)
            elif simplify_numbers:
                for i in range(4):
                    for j in range(4):
                        origin[i, j] = self._nsimplify(
                            origin[i, j], [pi], tolerance=tolerance,
                            max_denominator=max_denominator)
            joint_origins.append(origin)
            if joint.joint_type in [&#34;revolute&#34;, &#34;continuous&#34;, &#34;prismatic&#34;]:
                axis = Matrix(joint.axis)
                if simplify_numbers:
                    for i in range(3):
                        axis[i] = self._nsimplify(axis[i], [pi], tolerance=tolerance,
                                            max_denominator=max_denominator)
                if fixed_origin:
                    origin *= fixed_origin
                    fixed_origin = None
                self.B.append(Matrix(origin))

                if joint.joint_type in [&#34;revolute&#34;, &#34;continuous&#34;]:
                    self.X.append(Matrix(axis).col_join(Matrix([0, 0, 0])))
                else:
                    self.X.append(Matrix(Matrix([0, 0, 0])).col_join(axis))
                ji += 1
            elif joint.joint_type == &#34;fixed&#34;:
                if fixed_origin:
                    fixed_origin *= origin
                else:
                    fixed_origin = origin
                fixed_links.append((joint.parent, joint.child))
            jia += 1

        self.Mb = []
        i = 0
        first_non_fixed = 1
        for link in robot.links:
            name = link.name
            # ignore base link
            if i &lt; first_non_fixed:
                if name in [x[1] for x in fixed_links]:
                    first_non_fixed += 1
                i += 1
                continue
            inertia = Matrix(link.inertial.inertia.to_matrix())
            mass = link.inertial.mass
            inertiaorigin = xyz_rpy_to_matrix(link.inertial.origin.xyz+link.inertial.origin.rpy)
            if symbolic:
                I_syms = symbols(&#34;Ixx_%s Ixy_%s Ixz_%s Iyy_%s Iyz_%s Izz_%s&#34; % (
                    name, name, name, name, name, name))
                c_syms = symbols(&#34;cx_%s cy_%s cz_%s&#34; % (name, name, name))
                I = inertia_matrix(*I_syms)
                m = symbols(&#34;m_%s&#34; % name)
                cg = Matrix([*c_syms])
            else:
                if simplify_numbers:
                    for i in range(4):
                        for j in range(4):
                            inertiaorigin[i, j] = self._nsimplify(
                                inertiaorigin[i, j], [pi], tolerance=tolerance,
                                max_denominator=max_denominator)
                    for i in range(3):
                        for j in range(3):
                            inertia[i, j] = self._nsimplify(
                                inertia[i, j], [pi], tolerance=tolerance,
                                max_denominator=max_denominator)
                I = Matrix(inertia)
                m = mass
                cg = Matrix(inertiaorigin[0:3, 3])
            M = mass_matrix_mixed_data(m, I, cg)
            if name in [x[1] for x in fixed_links]:
                j = i
                # transform Mass matrix
                while robot.links[j].name in [x[1] for x in fixed_links]:
                    M = SE3AdjInvMatrix(
                        joint_origins[j-1]).T * M * SE3AdjInvMatrix(joint_origins[j-1])
                    j -= 1
                self.Mb[-1] += M
                i += 1
                continue
            self.Mb.append(M)
            i += 1
        return

    def dh_to_screw_coord(self, DH_param_table: MutableDenseMatrix) -&gt; None:
        &#34;&#34;&#34;Build screw coordinate paramters (joint axis frames and 
        body reference frames) from a given modified Denavit-Hartenberg 
        (DH) parameter table.
        Joint screw coordinates and reference configurations of bodies 
        are directly applied to class.

        Args:
            DH_param_table (array_like): 
                Table with modified DH parameters (n,5) 
                -&gt; (gamma,alpha,d,theta,r)
        &#34;&#34;&#34;
        number_of_frames = DH_param_table.shape[0]
        self.B = []
        self.X = []
        for i in range(number_of_frames):
            # Reference configurations of bodies (i.e. of body-fixed 
            # reference frames) w.r.t their previous bodies
            # gamma, alpha, d, theta,r
            frame = DH_param_table[i, :]
            gamma = frame[0]
            alpha = frame[1]
            d = frame[2]
            theta = frame[3]
            r = frame[4]
            self.B.append(SO3Exp(Matrix([1, 0, 0]), alpha)
                          .row_join(Matrix([d, 0, 0]))
                          .col_join(Matrix([0, 0, 0, 1]).T)
                          * SO3Exp(Matrix([0, 0, 1]), theta)
                          .row_join(Matrix([0, 0, r]))
                          .col_join(Matrix([0, 0, 0, 1]).T)
                          )

            #  Joint screw coordinates in body-fixed representation
            if gamma == 0:
                self.X.append(Matrix([0, 0, 1, 0, 0, 0]))
            else:
                self.X.append(Matrix([0, 0, 0, 0, 0, 1]))

    def _set_value_as_process(self, name: str, target: Callable) -&gt; None:
        &#34;&#34;&#34;Set return value of target as value to queue in 
        self.queue_dict with identifier name.

        Args:
            name (str): Identifier.
            target (function): function, which returns value. 
        &#34;&#34;&#34;
        if name not in self.queue_dict:
            self.queue_dict[name] = Queue()
        if name in self.process_dict:
            print(&#34;already there&#34;)
        self.process_dict[name] = Process(
            target=lambda: self._set_value(name, target()), args=(), name=name)
        self.process_dict[name].start()

    def _set_value(self, name: str, var: Any) -&gt; None:
        &#34;&#34;&#34;Set value to queue in self.queue_dict.

        Args:
            name (str): Identifier.
            var (any): Value to save.
        &#34;&#34;&#34;
        if name not in self.queue_dict:
            self.queue_dict[name] = Queue()
        self.queue_dict[name].put(var)

    def _start_simplification_process(
        self, name: str, cse: bool=False) -&gt; None:
        &#34;&#34;&#34;Start Process, which simplifies and overwrites value in 
        queue from self.queue_dict.

        Args:
            name (str): Identifier
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.
        &#34;&#34;&#34;
        if name not in self.queue_dict:
            self.queue_dict[name] = Queue()
        self.process_dict[name+&#34;_simplify&#34;] = Process(
            target=self._simplify_parallel, 
            args=(name, cse,), 
            name=name+&#34;_simplify&#34;)
        self.process_dict[name+&#34;_simplify&#34;].start()

    def _start_cse_process(self, name: str) -&gt; None:
        &#34;&#34;&#34;Start Process, which generates cse expression and overwrites value in 
        queue from self.queue_dict.

        Args:
            name (str): Identifier
        &#34;&#34;&#34;
        if name not in self.queue_dict:
            self.queue_dict[name] = Queue()
        self.process_dict[name+&#34;_cse&#34;] = Process(
            target=self._cse_parallel, 
            args=(name,), 
            name=name+&#34;_cse&#34;)
        self.process_dict[name+&#34;_cse&#34;].start()

    def _get_value(self, name: str) -&gt; Any:
        &#34;&#34;&#34;Get value from queue in self.queue_dict and put it in again.

        Args:
            name (str): Identifier.

        Returns:
            any: Value
        &#34;&#34;&#34;
        value = self.queue_dict[name].get()
        self.queue_dict[name].put(value)
        return value

    def _simplify_parallel(self, name: str, cse: bool=False) -&gt; None:
        &#34;&#34;&#34;Take value from self.queue_dict, simplify it and put it in 
        again.

        Args:
            name (str): Identifier
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.
        &#34;&#34;&#34;
        value = self.simplify(self.queue_dict[name].get(), cse)
        self.queue_dict[name].put(value)
        
    def _cse_parallel(self, name: str) -&gt; None:
        &#34;&#34;&#34;Take value from self.queue_dict, generate cse_expressions and 
        put it in again.

        Args:
            name (str): Identifier
        &#34;&#34;&#34;
        value = self._cse_expression(self.queue_dict[name].get())
        self.queue_dict[name].put(value)

    def _flush_queue(self, q: Queue) -&gt; None:
        &#34;&#34;&#34;Flush all items in queue

        Args:
            q (Queue): Queue to flush
        &#34;&#34;&#34;
        try:
            while True:
                q.get(block=False)
        except queue.Empty:
            pass

    def _individual_numbered_symbols(
        self, exclude: list=[], i: List[int]=[0]) -&gt; Generator[sympy.Symbol, None, None]:
        &#34;&#34;&#34;create individual symbol names for subexpressions using 
        multiprocessing.

        Args:
            exclude (list, optional): 
                List of names, which should not be used. Defaults to [].
            i (list, optional): 
                List with starting value -1 as first value. Is used as 
                counter and should not be set. Defaults to [0].

        Returns:
            sympy.numbered_symbols:  Symbols
        &#34;&#34;&#34;
        i[0] += 1
        prefix=&#34;sub%s_%s_&#34; % (
            &#34;_&#34;.join([str(j) for j in multiprocessing.current_process()._identity]), 
            i[0]
            )
        prefix = prefix.replace(&#34;sub_&#34;,&#34;sub0_&#34;)
        return numbered_symbols(
            prefix=prefix, 
            exclude=exclude)

    def _cse_expression(self, exp: sympy.Expr) -&gt; sympy.Expr:
        &#34;&#34;&#34;Use common subexpression elimination to shorten expression.
        The used subexpressions are saved to the class internal 
        subex_dict.

        Args:
            exp (Sympy expression): Expression to shorten using cse.

        Returns:
            Sympy expression: Shortened expression.
        &#34;&#34;&#34;
        # cse expression
        r, e = sympy.cse([exp, exp], self._individual_numbered_symbols(
            exclude=self.all_symbols), order=&#34;canonical&#34;, ignore=self.var_syms)
        # add subexpressions to dict
        for (sym, val) in r:
            self.subex_dict[sym] = val
            # for multiprocessing save in queue
            try:
                self.queue_dict[&#34;subex_dict&#34;].put(self.subex_dict)
            except:
                pass
            # update used symbols
            self.all_symbols.update({sym})
        return e[0]

    def _get_expressions(self) -&gt; List[sympy.Expr]:
        &#34;&#34;&#34;Get list of all generated expressions.

        Returns:
            list: generated expressions.
        &#34;&#34;&#34;
        expression_dict = self.get_expressions_dict()
        expressions = [expression_dict[i] for i in expression_dict]
        return expressions

    def _calc_A_matrix(
        self, q: MutableDenseMatrix
        ) -&gt; Tuple[List[MutableDenseMatrix], MutableDenseMatrix]:
        &#34;&#34;&#34;Calculate forward kinematics and the block diagonal matrix 
        A (6n x 6n) of the Adjoint of body frame for serial robots.

        Args:
            q (sympy.MutableDenseMatrix): 
                Generalized position vector.

        Raises:
            ValueError: 
                Joint screw coordinates or body reference configuration 
                not found.

        Returns:
            Tuple[List[MutableDenseMatrix], MutableDenseMatrix]: (FK, A)
        &#34;&#34;&#34;
        # calc Forward kinematics
        if self._FK_C is not None:
            FK_C = self._FK_C
        elif self.A:
            # print(&#34;Using absolute configuration (A) of the body frames&#34;)
            FK_f = [SE3Exp(self.Y[0], q[0])]
            FK_C = [FK_f[0]*self.A[0]]
            for i in range(1, self.n):
                FK_f.append(FK_f[i-1]*SE3Exp(self.Y[i], q[i]))
                FK_C.append(FK_f[i]*self.A[i])
            self._FK_C = FK_C
            if not self.X:
                # Joint screw coordinates in body-fixed representation 
                # computed from screw coordinates in IFR
                self.X = [SE3AdjInvMatrix(
                    self.A[i])*self.Y[i] for i in range(self.n)]

        elif self.B:
            # print(&#39;Using relative configuration (B) of the body frames&#39;)
            FK_C = [self.B[0]*SE3Exp(self.X[0], q[0])]
            for i in range(1, self.n):
                FK_C.append(FK_C[i-1]*self.B[i]*SE3Exp(self.X[i], q[i]))
            self._FK_C = FK_C
        else:
            # &#39;Absolute (A) or Relative (B) configuration of the bodies should be provided in class!&#39;
            raise ValueError(&#34;Joint screw coordinates and/or reference configuration of bodies not set.&#34;)

        # Block diagonal matrix A (6n x 6n) of the Adjoint of body frame
        if self._A is not None:
            A = self._A
        else:
            A = Matrix(Identity(6*self.n))
            for i in range(self.n):
                for j in range(i):
                    Crel = SE3Inv(FK_C[i])*FK_C[j]
                    AdCrel = SE3AdjMatrix(Crel)
                    r = 6*(i)
                    c = 6*(j)
                    A[r:r+6, c:c+6] = AdCrel
            self._A = A
        return FK_C, A

    def _calc_A_matrix_tree(self, q: MutableDenseMatrix):
        &#34;&#34;&#34;Calculate forward kinematics and the block diagonal matrix 
        A (6n x 6n) of the Adjoint of body frame for tree like robot 
        structures.

        Args:
            q (sympy.MutableDenseMatrix): 
                Generalized position vector.

        Raises:
            ValueError: 
                Joint screw coordinates or body reference configuration 
                not found.

        Returns:
            Tuple[List[MutableDenseMatrix], MutableDenseMatrix]: (FK, A)
        &#34;&#34;&#34;
        if self._FK_C is not None:
            FK_C = self._FK_C
        elif self.A:
            # print(&#34;Using absolute configuration (A) of the body frames&#34;)
            FK_f = []
            FK_C = []
            for i in range(self.n):
                if self.parent[i] == 0: # bodies with no predecessor
                    # Initialization for the first body
                    FK_f.append(SE3Exp(self.Y[i], q[i]))
                    FK_C.append(FK_f[i]*self.A[i])
                else:
                    FK_f.append(FK_f[self.parent[i]-1]*SE3Exp(self.Y[i], q[i]))
                    FK_C.append(FK_f[i]*self.A[i])      
            self._FK_C = FK_C
            if not self.X:
                # Joint screw coordinates in body-fixed representation 
                # computed from screw coordinates in IFR
                self.X = [SE3AdjInvMatrix(
                    self.A[i])*self.Y[i] for i in range(self.n)]

        elif self.B:
            # print(&#39;Using relative configuration (B) of the body frames&#39;)
            FK_C = []
            for i in range(self.n):
                if self.parent[i] == 0: # bodies with no predecessor
                    # Initialization for the first body
                    FK_C.append(self.B[i]*SE3Exp(self.X[i], q[i]))
                else:
                    FK_C.append(FK_C[self.parent[i]-1]*self.B[i]*SE3Exp(self.X[i], q[i]))
        else:
            # &#39;Absolute (A) or Relative (B) configuration of the bodies should be provided in class!&#39;
            raise ValueError(&#34;Joint screw coordinates and/or reference configuration of bodies not set.&#34;)

        # Block diagonal matrix A (6n x 6n) of the Adjoint of body frame
        if self._A is not None:
            A = self._A
        else:
            A = Matrix(Identity(6*self.n))
            for i in range(self.n):        
                if True:
                # if self.parent[i] != 0:
                    for k in self.support[i]:
                        j = k-1
                        Crel = SE3Inv(FK_C[i])*FK_C[j]
                        AdCrel = SE3AdjMatrix(Crel)
                        r = 6*(i)
                        c = 6*(j)
                        A[r:r+6, c:c+6] = AdCrel
            self._A = A
        return FK_C, A
    
    def _find_start_index(self) -&gt; int:
        &#34;&#34;&#34;Guess if 0 or 1 is the first index in the robot by analysing 
        used variable names.

        Returns:
            int: index.
        &#34;&#34;&#34;
        # search all symbols
        syms = set()
        for i in self.Mb:
            syms.update(i.free_symbols)
        for i in self.body_ref_config:
            syms.update(i.free_symbols)
        for i in self.joint_screw_coord:
            syms.update(i.free_symbols)
        # search all indices in symbols
        indices = []
        for i in syms:
            indices.extend(regex.findall(&#34;\d+&#34;,str(i)))
        #find smalles used index
        if indices:
            if min([int(i) for i in indices]) == 0:
                return 0
            if max([int(i) for i in indices]) == self.n -1:
                return 0
        return 1

    def _save_vectors(self, q: MutableDenseMatrix, qd: MutableDenseMatrix, 
                      q2d: MutableDenseMatrix, q3d: MutableDenseMatrix, 
                      q4d: MutableDenseMatrix, WEE: MutableDenseMatrix, 
                      WDEE: MutableDenseMatrix, W2DEE: MutableDenseMatrix) -&gt; None:
        &#34;&#34;&#34;Save generalized vectors als class parameter.

        Args:
            q (sympy.Matrix): 
                (n,1) Generalized position vector.
            qd (sympy.Matrix): 
                (n,1) Generalized velocity vector.
            q2d (sympy.Matrix): 
                (n,1) Generalized acceleration vector.
            q3d (sympy.Matrix): 
                (n,1) Generalized jerk vector.
            q4d (sympy.Matrix): 
                (n,1) Generalized jounce vector.
            WEE (sympy.Matrix): 
                (6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time varying 
                wrench on the EE link. 
            WDEE (sympy.Matrix): 
                (6,1) WDEE (t) = [dMx,dMy,dMz,dFx,dFy,dFz] is the derivative 
                of the time varying wrench on the EE link. 
            W2DEE (sympy.Matrix): 
                (6,1) W2DEE (t) = [ddMx,ddMy,ddMz,ddFx,ddFy,ddFz] is the 
                2nd derivative of the time varying wrench on the EE link. 
        &#34;&#34;&#34;
        if not self.q: self.q = q 
        if not self.qd: self.qd = qd 
        if not self.q2d: self.q2d = q2d 
        if not self.q3d: self.q3d = q3d 
        if not self.q4d: self.q4d = q4d
        if self.WEE == zeros(6,1) and WEE is not Ellipsis: self.WEE = WEE
        if self.WDEE == zeros(6,1) and WDEE is not Ellipsis: self.WDEE = WDEE
        if self.W2DEE == zeros(6,1) and W2DEE is not Ellipsis: self.W2DEE = W2DEE
        
    def _time_derivative(self, expression: sympy.Expr, level: int=1) -&gt; sympy.Expr:
        &#34;&#34;&#34;Generate time derivative of expression by substituting 
        generalized vectors with time dependent functions,
        let sympy calculate the time derivative, and resubstitute the 
        generalized vectors.

        Used for unit testing.
        
        Warning: This does not support external wrenches yet.

        Args:
            expression (sympy.Expr): 
                expression dependent on generalized vectors.
            level (int, optional): 
                Order of derivative to evaluate. Defaults to 1.

        Returns:
            sympy.Expr: Derived expression.
        &#34;&#34;&#34;
        # generate dynamic symbols as substitutes
        startindex = 1
        if self.n &gt; 1:
            subq = Matrix(sympy.physics.mechanics.dynamicsymbols(
                &#34; &#34;.join(f&#34;subq{i}&#34; for i in range(startindex,startindex+self.n))))
            subqd =  subq.diff()
            subq2d = subqd.diff() 
            subq3d = subq2d.diff() 
            subq4d = subq3d.diff() 
        else:
            subq = Matrix([sympy.physics.mechanics.dynamicsymbols(
                &#34; &#34;.join(f&#34;subq{i}&#34; for i in range(startindex,startindex+self.n)))])
            subqd =  subq.diff()
            subq2d = subqd.diff() 
            subq3d = subq2d.diff() 
            subq4d = subq3d.diff()
        # substitute
        expression = (expression.subs(zip(self.q,subq))
                                .subs(zip(self.qd,subqd))
                                .subs(zip(self.q2d,subq2d))
                                .subs(zip(self.q3d,subq3d))
                                .subs(zip(self.q4d,subq4d)))
        # derivative
        for _ in range(level):
            expression = expression.diff(&#34;t&#34;)
        # resubstitute
        expression = (expression.subs(zip(subq4d,self.q4d))
                                .subs(zip(subq3d,self.q3d))
                                .subs(zip(subq2d,self.q2d))
                                .subs(zip(subqd,self.qd))
                                .subs(zip(subq,self.q))
                                )
        return expression</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>skidy.kinematics_generator._AbstractCodeGeneration</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="skidy.kinematics_generator.SymbolicKinDyn.BODY_FIXED"><code class="name">var <span class="ident">BODY_FIXED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="skidy.kinematics_generator.SymbolicKinDyn.SPATIAL"><code class="name">var <span class="ident">SPATIAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="skidy.kinematics_generator.SymbolicKinDyn.body_ref_config"><code class="name">var <span class="ident">body_ref_config</span> :list</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def body_ref_config(self) -&gt; list:
    if self.config_representation == self.BODY_FIXED:
        return self.B
    elif self.config_representation == self.SPATIAL:
        return self.A</code></pre>
</details>
</dd>
<dt id="skidy.kinematics_generator.SymbolicKinDyn.config_representation"><code class="name">var <span class="ident">config_representation</span> :str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def config_representation(self) -&gt; str:
    return self._config_representation</code></pre>
</details>
</dd>
<dt id="skidy.kinematics_generator.SymbolicKinDyn.joint_screw_coord"><code class="name">var <span class="ident">joint_screw_coord</span> :list</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def joint_screw_coord(self) -&gt; list:
    if self.config_representation == self.BODY_FIXED:
        return self.X
    elif self.config_representation == self.SPATIAL:
        return self.Y</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="skidy.kinematics_generator.SymbolicKinDyn.closed_form_inv_dyn_body_fixed"><code class="name flex">
<span>def <span class="ident">closed_form_inv_dyn_body_fixed</span></span>(<span>self, q:sympy.matrices.dense.MutableDenseMatrix=None, qd:sympy.matrices.dense.MutableDenseMatrix=None, q2d:sympy.matrices.dense.MutableDenseMatrix=None, q3d:sympy.matrices.dense.MutableDenseMatrix=None, q4d:sympy.matrices.dense.MutableDenseMatrix=None, WEE:Union[sympy.matrices.dense.MutableDenseMatrix,List[sympy.matrices.dense.MutableDenseMatrix]]=Ellipsis, WDEE:Union[sympy.matrices.dense.MutableDenseMatrix,List[sympy.matrices.dense.MutableDenseMatrix]]=Ellipsis, W2DEE:Union[sympy.matrices.dense.MutableDenseMatrix,List[sympy.matrices.dense.MutableDenseMatrix]]=Ellipsis, simplify:bool=True, cse:bool=False, parallel:bool=True) >sympy.matrices.dense.MutableDenseMatrix</span>
</code></dt>
<dd>
<div class="desc"><p>Inverse dynamics using body fixed representation of the
twists in closed form. </p>
<p>The following expressions are saved in the class and can be
code generated afterwards:
coriolis_centrifugal_matrix
generalized_mass_inertia_matrix
gravity_vector
inverse_dynamics</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>q</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(n,1) Generalized position vector. Defaults to None.</dd>
<dt><strong><code>qd</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(n,1) Generalized velocity vector. Defaults to None.</dd>
<dt><strong><code>q2d</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(n,1) Generalized acceleration vector. Defaults to None.</dd>
<dt><strong><code>q3d</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(n,1) Generalized jerk vector. Defaults to None.</dd>
<dt><strong><code>q4d</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(n,1) Generalized jounce vector. Defaults to None.</dd>
<dt>WEE (list | sympy.Matrix, optional):</dt>
<dt>(6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time varying</dt>
<dt>wrench on the EE link.</dt>
<dt>If there is more than one end-effector, you can use a</dt>
<dt>list containing all wrenches instead.</dt>
<dt>Defaults to zeros(6, 1).</dt>
<dt>WDEE (list | sympy.Matrix, optional):</dt>
<dt>(6,1) WDEE (t) = [dMx,dMy,dMz,dFx,dFy,dFz] is the derivative</dt>
<dt>of the time varying wrench on the EE link.</dt>
<dt>If there is more than one end-effector, you can use a</dt>
<dt>list containing all wrenches instead.</dt>
<dt>Defaults to zeros(6, 1).</dt>
<dt>W2DEE (list | sympy.Matrix, optional):</dt>
<dt>(6,1) W2DEE (t) = [ddMx,ddMy,ddMz,ddFx,ddFy,ddFz] is the</dt>
<dt>2nd derivative of the time varying wrench on the EE link.</dt>
<dt>If there is more than one end-effector, you can use a</dt>
<dt>list containing all wrenches instead.</dt>
<dt>Defaults to zeros(6, 1).</dt>
<dt><strong><code>simplify</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Use simplify command on saved expressions.
Defaults to True.</dd>
<dt><strong><code>cse</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Use common subexpression elimination. Defaults to False.</dd>
<dt><strong><code>parallel</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Use parallel computation via multiprocessing.
Defaults to True.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ValueError:
Joint screw coordinates and/or reference configuration
of bodies not set.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy.Matrix</code></dt>
<dd>Generalized forces</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closed_form_inv_dyn_body_fixed(
    self, 
    q:sympy.MutableDenseMatrix=None, 
    qd: MutableDenseMatrix=None, 
    q2d: MutableDenseMatrix=None, 
    q3d: MutableDenseMatrix=None, 
    q4d: MutableDenseMatrix=None, 
    WEE: Union[MutableDenseMatrix,List[MutableDenseMatrix]]=..., 
    WDEE: Union[MutableDenseMatrix,List[MutableDenseMatrix]]=..., 
    W2DEE: Union[MutableDenseMatrix,List[MutableDenseMatrix]]=..., 
    simplify: bool=True, cse: bool=False, 
    parallel: bool=True) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Inverse dynamics using body fixed representation of the 
    twists in closed form. 

    The following expressions are saved in the class and can be 
    code generated afterwards:
        coriolis_centrifugal_matrix
        generalized_mass_inertia_matrix
        gravity_vector
        inverse_dynamics

    Args:
        q (sympy.Matrix, optional): 
            (n,1) Generalized position vector. Defaults to None.
        qd (sympy.Matrix, optional): 
            (n,1) Generalized velocity vector. Defaults to None.
        q2d (sympy.Matrix, optional): 
            (n,1) Generalized acceleration vector. Defaults to None.
        q3d (sympy.Matrix, optional): 
            (n,1) Generalized jerk vector. Defaults to None.
        q4d (sympy.Matrix, optional): 
            (n,1) Generalized jounce vector. Defaults to None.
        WEE (list | sympy.Matrix, optional): 
            (6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time varying 
            wrench on the EE link. 
            If there is more than one end-effector, you can use a 
            list containing all wrenches instead.
            Defaults to zeros(6, 1).
        WDEE (list | sympy.Matrix, optional): 
            (6,1) WDEE (t) = [dMx,dMy,dMz,dFx,dFy,dFz] is the derivative 
            of the time varying wrench on the EE link. 
            If there is more than one end-effector, you can use a 
            list containing all wrenches instead.
            Defaults to zeros(6, 1).
        W2DEE (list | sympy.Matrix, optional): 
            (6,1) W2DEE (t) = [ddMx,ddMy,ddMz,ddFx,ddFy,ddFz] is the 
            2nd derivative of the time varying wrench on the EE link. 
            If there is more than one end-effector, you can use a 
            list containing all wrenches instead.
            Defaults to zeros(6, 1).
        simplify (bool, optional): 
            Use simplify command on saved expressions. 
            Defaults to True.
        cse (bool, optional): 
            Use common subexpression elimination. Defaults to False.
        parallel (bool, optional): 
            Use parallel computation via multiprocessing. 
            Defaults to True.

    Raises:
        ValueError:
            Joint screw coordinates and/or reference configuration 
            of bodies not set.
    
    Returns:
        sympy.Matrix: Generalized forces
    &#34;&#34;&#34;
    if not q or not qd or not q2d:
        if not self.n:
            self.n = len(self.body_ref_config)
        if not self.q or not self.qd or not self.q2d:
            q, qd, q2d = generalized_vectors(self.n,self._find_start_index())
        else:
            q, qd, q2d, q3d, q4d = self.q, self.qd, self.q2d, self.q3d, self.q4d
    
    if WEE is Ellipsis:
        WEE = self.WEE
    if WDEE is Ellipsis:
        WDEE = self.WDEE
    if W2DEE is Ellipsis:
        W2DEE = self.W2DEE
    
    self._save_vectors(q, qd, q2d, q3d, q4d, WEE, WDEE, W2DEE)
    self.n = len(q)
    
    # prepare ee link selection
    if self.ee_parent is None:
        self.ee_parent = [self.n]
    if type(self.ee_parent) is not list: self.ee_parent = [self.ee_parent]
    self.n_ee = len(self.ee_parent)
    if self.n_ee &gt; 1:
        if type(WEE) is list and len(WEE) &gt; 1:
            assert(len(WEE) == len(self.ee_parent))
        if type(WDEE) is list and len(WDEE) &gt; 1:
            assert(len(WDEE) == len(self.ee_parent))
        if type(W2DEE) is list and len(W2DEE) &gt; 1:
            assert(len(W2DEE) == len(self.ee_parent)) 
    if type(WEE) is not list: WEE = [WEE]
    if type(WDEE) is not list: WDEE = [WDEE]
    if type(W2DEE) is not list: W2DEE = [W2DEE]
    
    if parallel:
        self._closed_form_inv_dyn_body_fixed_parallel(
            q, qd, q2d, q3d, q4d, WEE, WDEE, W2DEE, simplify, cse)
    else:
        self._closed_form_inv_dyn_body_fixed(
            q, qd, q2d, q3d, q4d, WEE, WDEE, W2DEE, simplify, cse)
    return self.Q</code></pre>
</details>
</dd>
<dt id="skidy.kinematics_generator.SymbolicKinDyn.closed_form_kinematics_body_fixed"><code class="name flex">
<span>def <span class="ident">closed_form_kinematics_body_fixed</span></span>(<span>self, q:sympy.matrices.dense.MutableDenseMatrix=None, qd:sympy.matrices.dense.MutableDenseMatrix=None, q2d:sympy.matrices.dense.MutableDenseMatrix=None, simplify:bool=True, cse:bool=False, parallel:bool=True) >sympy.matrices.dense.MutableDenseMatrix</span>
</code></dt>
<dd>
<div class="desc"><p>Position, Velocity and Acceleration Kinematics using Body
fixed representation of the twists in closed form.</p>
<p>The following expressions are saved in the class and can be
code generated afterwards:</p>
<pre><code>body_acceleration
body_acceleration_ee
body_jacobian_matrix
body_jacobian_matrix_dot 
body_jacobian_matrix_ee
body_jacobian_matrix_ee_dot
body_twist_ee
forward_kinematics
hybrid_acceleration
hybrid_acceleration_ee
hybrid_jacobian_matrix
hybrid_jacobian_matrix_dot
hybrid_jacobian_matrix_ee
hybrid_jacobian_matrix_ee_dot
hybrid_twist_ee
</code></pre>
<p>Needs class parameters body_ref_config, joint_screw_coord and ee
to be defined.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>q</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(n,1) Generalized position vector. Defaults to None.</dd>
<dt><strong><code>qd</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(n,1) Generalized velocity vector. Defaults to None.</dd>
<dt><strong><code>q2d</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(n,1) Generalized acceleration vector. Defaults to None.</dd>
<dt><strong><code>simplify</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Use simplify command on saved expressions.
Defaults to True.</dd>
<dt><strong><code>cse</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Use common subexpression elimination. Defaults to False.</dd>
<dt><strong><code>parallel</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Use parallel computation via multiprocessing.
Defaults to True.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ValueError:
Joint screw coordinates and/or reference configuration
of bodies not set.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy.Matrix</code></dt>
<dd>Forward kinematics.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closed_form_kinematics_body_fixed(
    self, q:sympy.MutableDenseMatrix=None, qd: MutableDenseMatrix=None, 
    q2d: MutableDenseMatrix=None, simplify: bool=True, 
    cse: bool=False, parallel: bool=True) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Position, Velocity and Acceleration Kinematics using Body 
    fixed representation of the twists in closed form.

    The following expressions are saved in the class and can be 
    code generated afterwards:
    
        body_acceleration
        body_acceleration_ee
        body_jacobian_matrix
        body_jacobian_matrix_dot 
        body_jacobian_matrix_ee
        body_jacobian_matrix_ee_dot
        body_twist_ee
        forward_kinematics
        hybrid_acceleration
        hybrid_acceleration_ee
        hybrid_jacobian_matrix
        hybrid_jacobian_matrix_dot
        hybrid_jacobian_matrix_ee
        hybrid_jacobian_matrix_ee_dot
        hybrid_twist_ee

    Needs class parameters body_ref_config, joint_screw_coord and ee 
    to be defined.

    Args:
        q (sympy.Matrix, optional): 
            (n,1) Generalized position vector. Defaults to None.
        qd (sympy.Matrix, optional): 
            (n,1) Generalized velocity vector. Defaults to None.
        q2d (sympy.Matrix, optional): 
            (n,1) Generalized acceleration vector. Defaults to None.
        simplify (bool, optional): 
            Use simplify command on saved expressions. 
            Defaults to True.
        cse (bool, optional): 
            Use common subexpression elimination. Defaults to False.
        parallel (bool, optional): 
            Use parallel computation via multiprocessing. 
            Defaults to True.
    Raises:
        ValueError:
            Joint screw coordinates and/or reference configuration 
            of bodies not set.
            
    Returns:
        sympy.Matrix: Forward kinematics.
    &#34;&#34;&#34;
    if not q or not qd or not q2d:
        if not self.n:
            self.n = len(self.body_ref_config)
        if not self.q or not self.qd or not self.q2d:
            print(self.q, self.qd, self.q2d)
            q, qd, q2d = generalized_vectors(self.n,self._find_start_index())
        else:
            q, qd, q2d = self.q, self.qd, self.q2d
            
    self._save_vectors(q, qd, q2d, None, None, ..., ..., ...)
    self.n = len(q)
    
    # prepare ee link selection
    if self.ee_parent is None:
        self.ee_parent = [self.n]
    if type(self.ee) is not list: self.ee = [self.ee]
    if type(self.ee_parent) is not list: self.ee_parent = [self.ee_parent]
    assert(len(self.ee) == len(self.ee_parent))    
    self.n_ee = len(self.ee_parent)
    
    if parallel:
        self._closed_form_kinematics_body_fixed_parallel(
            q, qd, q2d, simplify, cse)
    else:
        self._closed_form_kinematics_body_fixed(
            q, qd, q2d, simplify, cse)
    return self.fkin</code></pre>
</details>
</dd>
<dt id="skidy.kinematics_generator.SymbolicKinDyn.dh_to_screw_coord"><code class="name flex">
<span>def <span class="ident">dh_to_screw_coord</span></span>(<span>self, DH_param_table:sympy.matrices.dense.MutableDenseMatrix) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Build screw coordinate paramters (joint axis frames and
body reference frames) from a given modified Denavit-Hartenberg
(DH) parameter table.
Joint screw coordinates and reference configurations of bodies
are directly applied to class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>DH_param_table</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Table with modified DH parameters (n,5)
-&gt; (gamma,alpha,d,theta,r)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dh_to_screw_coord(self, DH_param_table: MutableDenseMatrix) -&gt; None:
    &#34;&#34;&#34;Build screw coordinate paramters (joint axis frames and 
    body reference frames) from a given modified Denavit-Hartenberg 
    (DH) parameter table.
    Joint screw coordinates and reference configurations of bodies 
    are directly applied to class.

    Args:
        DH_param_table (array_like): 
            Table with modified DH parameters (n,5) 
            -&gt; (gamma,alpha,d,theta,r)
    &#34;&#34;&#34;
    number_of_frames = DH_param_table.shape[0]
    self.B = []
    self.X = []
    for i in range(number_of_frames):
        # Reference configurations of bodies (i.e. of body-fixed 
        # reference frames) w.r.t their previous bodies
        # gamma, alpha, d, theta,r
        frame = DH_param_table[i, :]
        gamma = frame[0]
        alpha = frame[1]
        d = frame[2]
        theta = frame[3]
        r = frame[4]
        self.B.append(SO3Exp(Matrix([1, 0, 0]), alpha)
                      .row_join(Matrix([d, 0, 0]))
                      .col_join(Matrix([0, 0, 0, 1]).T)
                      * SO3Exp(Matrix([0, 0, 1]), theta)
                      .row_join(Matrix([0, 0, r]))
                      .col_join(Matrix([0, 0, 0, 1]).T)
                      )

        #  Joint screw coordinates in body-fixed representation
        if gamma == 0:
            self.X.append(Matrix([0, 0, 1, 0, 0, 0]))
        else:
            self.X.append(Matrix([0, 0, 0, 0, 0, 1]))</code></pre>
</details>
</dd>
<dt id="skidy.kinematics_generator.SymbolicKinDyn.load_from_urdf"><code class="name flex">
<span>def <span class="ident">load_from_urdf</span></span>(<span>self, path:str, symbolic:bool=True, cse:bool=False, simplify_numbers:bool=True, tolerance:float=0.0001, max_denominator:int=9) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Load robot from urdf.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>path to URDF.</dd>
<dt><strong><code>symbolic</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>generate symbols for numeric values.
Defaults to True.</dd>
<dt><strong><code>cse</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>use common subexpression elimination. Defaults to False.</dd>
<dt><strong><code>simplify_numbers</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Use eg. pi/2 instead of 1.5708. Defaults to True.</dd>
<dt><strong><code>tolerance</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>tolerance for simplify_numbers. Defaults to 0.0001.</dd>
<dt><strong><code>max_denominator</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum denominator to use for simplify numbers to avoid
values like 13/153. Use 0 to deactivate. Defaults to 9.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>supports only the joint types
"revolute", "continuous" and "prismatic".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_from_urdf(self, path: str, symbolic: bool=True, 
                   cse: bool=False, simplify_numbers: bool=True,  
                   tolerance: float=0.0001, max_denominator: int=9) -&gt; None:
    &#34;&#34;&#34;Load robot from urdf.

    Args:
        path (str): path to URDF.
        symbolic (bool, optional): 
            generate symbols for numeric values. 
            Defaults to True.
        cse (bool, optional): 
            use common subexpression elimination. Defaults to False.
        simplify_numbers (bool, optional): 
            Use eg. pi/2 instead of 1.5708. Defaults to True.
        tolerance (float, optional): 
            tolerance for simplify_numbers. Defaults to 0.0001.
        max_denominator (int, optional): 
            Maximum denominator to use for simplify numbers to avoid
            values like 13/153. Use 0 to deactivate. Defaults to 9.

    Raises:
        NotImplementedError: supports only the joint types 
            &#34;revolute&#34;, &#34;continuous&#34; and &#34;prismatic&#34;.
    &#34;&#34;&#34;        
    with open(path, &#34;r&#34;) as f:
        robot = URDF.from_xml_string(f.read())
    self.B = []
    self.X = []
    self._create_topology_lists(robot) # TODO: check!
    fixed_origin = None
    fixed_links = []
    DOF = 0
    xyz_rpy_syms = []
    for joint in robot.joints:
        if joint.joint_type in [&#34;revolute&#34;, &#34;continuous&#34;, &#34;prismatic&#34;]:
            DOF += 1
        elif joint.joint_type in [&#34;fixed&#34;]:
            pass
        else:
            raise NotImplementedError(
                &#34;Joint type &#39;&#34; + joint.joint_type+&#34;&#39; not implemented yet!&#34;)

    ji = 0  # joint index of used joints
    jia = 0  # joint index of all joints (fixed included)
    joint_origins = []
    for joint in robot.joints:
        name = joint.name
        origin = xyz_rpy_to_matrix(joint.origin.xyz+joint.origin.rpy)
        if symbolic:
            xyz_rpy = Matrix(joint.origin.xyz+joint.origin.rpy)
            xyz_rpy_syms.append(symbols(
                &#34; &#34;.join([name+&#34;_%s&#34; % s for s in [&#34;x&#34;, &#34;y&#34;, &#34;z&#34;, &#34;roll&#34;, &#34;pitch&#34;, &#34;yar&#34;]])))
            xyzrpylist = []
            if simplify_numbers:
                for i in range(6):
                    if (self._nsimplify(xyz_rpy[i], 
                                       tolerance=tolerance, 
                                       max_denominator=max_denominator) 
                        in [0, -1, 1, pi, -pi, pi/2, -pi/2, 3*pi/2, -3*pi/2]
                        ):
                        xyzrpylist.append(
                            self._nsimplify(xyz_rpy[i], tolerance=tolerance,
                                            max_denominator=max_denominator))
                    else:
                        xyzrpylist.append(xyz_rpy_syms[jia][i])
                        self.assignment_dict[xyz_rpy_syms[jia]
                                             [i]] = xyz_rpy[i]
            else:
                for i in range(6):
                    if xyz_rpy[i] == 0:
                        xyzrpylist.append(0)
                    elif xyz_rpy[i] == 1:
                        xyzrpylist.append(1)
                    elif xyz_rpy[i] == -1:
                        xyzrpylist.append(-1)
                    else:
                        xyzrpylist.append(xyz_rpy_syms[jia][i])
                        self.assignment_dict[xyz_rpy_syms[jia]
                                             [i]] = xyz_rpy[i]
            origin = xyz_rpy_to_matrix(xyzrpylist)
            if cse:
                origin = self._cse_expression(origin)
        elif simplify_numbers:
            for i in range(4):
                for j in range(4):
                    origin[i, j] = self._nsimplify(
                        origin[i, j], [pi], tolerance=tolerance,
                        max_denominator=max_denominator)
        joint_origins.append(origin)
        if joint.joint_type in [&#34;revolute&#34;, &#34;continuous&#34;, &#34;prismatic&#34;]:
            axis = Matrix(joint.axis)
            if simplify_numbers:
                for i in range(3):
                    axis[i] = self._nsimplify(axis[i], [pi], tolerance=tolerance,
                                        max_denominator=max_denominator)
            if fixed_origin:
                origin *= fixed_origin
                fixed_origin = None
            self.B.append(Matrix(origin))

            if joint.joint_type in [&#34;revolute&#34;, &#34;continuous&#34;]:
                self.X.append(Matrix(axis).col_join(Matrix([0, 0, 0])))
            else:
                self.X.append(Matrix(Matrix([0, 0, 0])).col_join(axis))
            ji += 1
        elif joint.joint_type == &#34;fixed&#34;:
            if fixed_origin:
                fixed_origin *= origin
            else:
                fixed_origin = origin
            fixed_links.append((joint.parent, joint.child))
        jia += 1

    self.Mb = []
    i = 0
    first_non_fixed = 1
    for link in robot.links:
        name = link.name
        # ignore base link
        if i &lt; first_non_fixed:
            if name in [x[1] for x in fixed_links]:
                first_non_fixed += 1
            i += 1
            continue
        inertia = Matrix(link.inertial.inertia.to_matrix())
        mass = link.inertial.mass
        inertiaorigin = xyz_rpy_to_matrix(link.inertial.origin.xyz+link.inertial.origin.rpy)
        if symbolic:
            I_syms = symbols(&#34;Ixx_%s Ixy_%s Ixz_%s Iyy_%s Iyz_%s Izz_%s&#34; % (
                name, name, name, name, name, name))
            c_syms = symbols(&#34;cx_%s cy_%s cz_%s&#34; % (name, name, name))
            I = inertia_matrix(*I_syms)
            m = symbols(&#34;m_%s&#34; % name)
            cg = Matrix([*c_syms])
        else:
            if simplify_numbers:
                for i in range(4):
                    for j in range(4):
                        inertiaorigin[i, j] = self._nsimplify(
                            inertiaorigin[i, j], [pi], tolerance=tolerance,
                            max_denominator=max_denominator)
                for i in range(3):
                    for j in range(3):
                        inertia[i, j] = self._nsimplify(
                            inertia[i, j], [pi], tolerance=tolerance,
                            max_denominator=max_denominator)
            I = Matrix(inertia)
            m = mass
            cg = Matrix(inertiaorigin[0:3, 3])
        M = mass_matrix_mixed_data(m, I, cg)
        if name in [x[1] for x in fixed_links]:
            j = i
            # transform Mass matrix
            while robot.links[j].name in [x[1] for x in fixed_links]:
                M = SE3AdjInvMatrix(
                    joint_origins[j-1]).T * M * SE3AdjInvMatrix(joint_origins[j-1])
                j -= 1
            self.Mb[-1] += M
            i += 1
            continue
        self.Mb.append(M)
        i += 1
    return</code></pre>
</details>
</dd>
<dt id="skidy.kinematics_generator.SymbolicKinDyn.partial_factor"><code class="name flex">
<span>def <span class="ident">partial_factor</span></span>(<span>self, exp:sympy.core.expr.Expr) >sympy.core.expr.Expr</span>
</code></dt>
<dd>
<div class="desc"><p>Partial factor simplification for sympy expression.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>exp</code></strong> :&ensp;<code>sympy.Expr</code></dt>
<dd>sympy expression.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy.Expr</code></dt>
<dd>modified sympy expression.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partial_factor(self, exp: sympy.Expr) -&gt; sympy.Expr:
    &#34;&#34;&#34;Partial factor simplification for sympy expression.

    Args:
        exp (sympy.Expr): sympy expression.

    Returns:
        sympy.Expr: modified sympy expression.
    &#34;&#34;&#34;
    # split up matrices
    if (type(exp) == sympy.matrices.immutable.ImmutableDenseMatrix
        or type(exp) == sympy.matrices.dense.MutableDenseMatrix):
        new_expr = zeros(*exp.shape)
        for i in range(exp.shape[0]):
            for j in range(exp.shape[1]):
                new_expr[i,j] = self.partial_factor(exp[i,j])
        return new_expr
        
    # seach for factors
    factor_map = defaultdict(set)
    const, additive_terms = exp.as_coeff_add()
    for term1, term2 in combinations(additive_terms, 2):
        common_terms = (
            set(term1.as_coeff_mul()[-1])
            &amp; set(term2.as_coeff_mul()[-1])
        )
        if common_terms:
            common_factor = sympy.Mul(*common_terms)
            factor_map[common_factor] |= {term1, term2}
    
    # sort by number of operations represented by the terms
    factor_list = sorted(
        factor_map.items(),
        key = lambda i: (i[0].count_ops() + 1) * len(i[1])
    )[::-1]

    # rebuild expression
    used = set()
    new_expr = nsimplify(0)
    for item in factor_list:
        factor = item[0]
        appearances = item[-1]
        terms = 0
        for instance in appearances:
            if instance not in used:
                terms += instance.as_coefficient(factor)
                used.add(instance)
        new_expr += factor * terms
    for term in set(additive_terms) - used:
        new_expr += term
    return new_expr + const</code></pre>
</details>
</dd>
<dt id="skidy.kinematics_generator.SymbolicKinDyn.simplify"><code class="name flex">
<span>def <span class="ident">simplify</span></span>(<span>self, exp:sympy.core.expr.Expr, cse:bool=False) >sympy.core.expr.Expr</span>
</code></dt>
<dd>
<div class="desc"><p>Faster simplify implementation for sympy expressions.
Expressions can be different simplified as with sympy.simplify.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>exp</code></strong> :&ensp;<code>sympy expression</code></dt>
<dd>Expression to simplify.</dd>
<dt><strong><code>cse</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Use common subexpression elimination. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy expression</code></dt>
<dd>Simplified expression.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplify(self, exp: sympy.Expr, cse: bool=False) -&gt; sympy.Expr:
    &#34;&#34;&#34;Faster simplify implementation for sympy expressions.
    Expressions can be different simplified as with sympy.simplify.

    Args:
        exp (sympy expression): 
            Expression to simplify.
        cse (bool, optional): 
            Use common subexpression elimination. Defaults to False.

    Returns:
        sympy expression: Simplified expression.
    &#34;&#34;&#34;
    if cse:
        exp = self._cse_expression(exp)
    if (type(exp) == sympy.matrices.immutable.ImmutableDenseMatrix
            or type(exp) == sympy.matrices.dense.MutableDenseMatrix):
        # fasten simplification of symmetric matrices
        if exp.is_square:
            # test if matrix is symmetric
            # numeric test is faster than is_symmetric method  for 
            # long expressions
            
            # create matrix with randon values
            num = lambdify(list(exp.free_symbols), exp, &#34;numpy&#34;)(
                *(random.random() for i in exp.free_symbols))
            # if (random) matrix is symmetric, we have to simplify 
            # less values
            if numpy.allclose(num, num.T):
                shape = exp.shape
                m_exp = exp.as_mutable()
                # simplify values only once in symmetric matrices
                for i in range(shape[0]):
                    for j in range(i):
                        m_exp[i, j] = self.simplify(exp[i, j])
                        if i != j:
                            m_exp[j, i] = exp[j, i]
                return Matrix(m_exp)
    if type(exp) == sympy.matrices.dense.MutableDenseMatrix:
        exp = exp.as_immutable()
    exp = fu(exp)  # fast function to simplify sin and cos expressions
    exp = cancel(exp)
    exp = factor(exp)
    exp = powsimp(exp)
    exp = self.partial_factor(exp)
    exp = exp.doit()
    return exp</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="skidy" href="index.html">skidy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="skidy.kinematics_generator.SymbolicKinDyn" href="#skidy.kinematics_generator.SymbolicKinDyn">SymbolicKinDyn</a></code></h4>
<ul class="">
<li><code><a title="skidy.kinematics_generator.SymbolicKinDyn.BODY_FIXED" href="#skidy.kinematics_generator.SymbolicKinDyn.BODY_FIXED">BODY_FIXED</a></code></li>
<li><code><a title="skidy.kinematics_generator.SymbolicKinDyn.SPATIAL" href="#skidy.kinematics_generator.SymbolicKinDyn.SPATIAL">SPATIAL</a></code></li>
<li><code><a title="skidy.kinematics_generator.SymbolicKinDyn.body_ref_config" href="#skidy.kinematics_generator.SymbolicKinDyn.body_ref_config">body_ref_config</a></code></li>
<li><code><a title="skidy.kinematics_generator.SymbolicKinDyn.closed_form_inv_dyn_body_fixed" href="#skidy.kinematics_generator.SymbolicKinDyn.closed_form_inv_dyn_body_fixed">closed_form_inv_dyn_body_fixed</a></code></li>
<li><code><a title="skidy.kinematics_generator.SymbolicKinDyn.closed_form_kinematics_body_fixed" href="#skidy.kinematics_generator.SymbolicKinDyn.closed_form_kinematics_body_fixed">closed_form_kinematics_body_fixed</a></code></li>
<li><code><a title="skidy.kinematics_generator.SymbolicKinDyn.config_representation" href="#skidy.kinematics_generator.SymbolicKinDyn.config_representation">config_representation</a></code></li>
<li><code><a title="skidy.kinematics_generator.SymbolicKinDyn.dh_to_screw_coord" href="#skidy.kinematics_generator.SymbolicKinDyn.dh_to_screw_coord">dh_to_screw_coord</a></code></li>
<li><code><a title="skidy.kinematics_generator.SymbolicKinDyn.joint_screw_coord" href="#skidy.kinematics_generator.SymbolicKinDyn.joint_screw_coord">joint_screw_coord</a></code></li>
<li><code><a title="skidy.kinematics_generator.SymbolicKinDyn.load_from_urdf" href="#skidy.kinematics_generator.SymbolicKinDyn.load_from_urdf">load_from_urdf</a></code></li>
<li><code><a title="skidy.kinematics_generator.SymbolicKinDyn.partial_factor" href="#skidy.kinematics_generator.SymbolicKinDyn.partial_factor">partial_factor</a></code></li>
<li><code><a title="skidy.kinematics_generator.SymbolicKinDyn.simplify" href="#skidy.kinematics_generator.SymbolicKinDyn.simplify">simplify</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>