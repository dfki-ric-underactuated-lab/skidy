<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>skidy.kinematics_generator API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>skidy.kinematics_generator</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import multiprocessing
import os
import queue
import random
from collections import defaultdict
from itertools import combinations
from multiprocessing import Process, Queue
from typing import Any, Callable, Dict, Generator, List, Tuple, Union

import numpy
import regex
import sympy
from pylatex import Command, Document, NoEscape, Section
from sympy import (Identity, Matrix, MutableDenseMatrix, cancel, ccode, 
                   factor, lambdify, nsimplify, octave_code, pi, powsimp,
                   symbols, zeros)
from sympy.printing.latex import LatexPrinter
from sympy.printing.numpy import NumPyPrinter
from sympy.simplify.cse_main import numbered_symbols
from sympy.simplify.fu import fu
from sympy.utilities.codegen import codegen
from urdf_parser_py.urdf import URDF

from skidy.matrices import (SE3AdjInvMatrix, SE3AdjMatrix,
                                           SE3adMatrix, SE3Exp, SE3Inv, SO3Exp,
                                           generalized_vectors, inertia_matrix,
                                           mass_matrix_mixed_data,
                                           xyz_rpy_to_matrix, matrix_to_xyz_rpy)


class _AbstractCodeGeneration():
    def __init__(self) -&gt; None:
        # variables for Code Generation:
        self.fkin = None  # forward_kinematics
        self.J = None  # system_jacobian_matrix
        self.Jb = None  # body_jacobian_matrix
        self.Jh = None  # hybrid_jacobian_matrix
        self.Jdot = None  # system_jacobian_dot
        self.Vb_ee = None  # body_twist_ee
        self.Vh_ee = None  # hybrid_twist_ee
        self.Jb_ee = None  # body_jacobian_matrix_ee
        self.Jh_ee = None  # hybrid_jacobian_matrix_ee
        self.M = None  # generalized_mass_inertia_matrix
        self.C = None  # coriolis_centrifugal_matrix
        self.Qgrav = None  # gravity_vector
        self.Q = None  # inverse_dynamics
        self.Vh_BFn = None # hybrid_twist
        self.Vb_BFn = None # body_twist
        self.Vhd_BFn = None  # hybrid_acceleration
        self.Vbd_BFn = None  # body_acceleration
        self.Vhd_ee = None  # hybrid_acceleration_ee
        self.Vbd_ee = None  # body_acceleration_ee
        self.Jh_dot = None  # hybrid_jacobian_matrix_dot
        self.Jb_dot = None  # body_jacobian_matrix_dot
        self.Jh_ee_dot = None  # hybrid_jacobian_matrix_ee_dot
        self.Jb_ee_dot = None  # body_jacobian_matrix_ee_dot

        # set of variable symbols to use in generated functions as arguments
        self.var_syms = set()
        self.optional_var_syms = set() # for wrenches
        
        # Value assignment
        # dict with assigned variables for code generation
        self.assignment_dict = {}  
        # dict for subexpressions fro common subexpression elimination
        self.subex_dict = {}  

        self.all_symbols = set()  # set with all used symbols


    def get_expressions_dict(self, filterNone: bool=True) -&gt; Dict[str,Union[sympy.Expr, None]]:
        &#34;&#34;&#34;Get dictionary with expression names (key) and generated 
        expressions (value).

        Args:
            filterNone (bool, optional): 
                Exclude expressions which haven&#39;t been generate yet. 
                Defaults to True.

        Returns:
            dict: dictionary with expression names (key) and generated 
                expressions (value).
        &#34;&#34;&#34;
        # all expressions in this dictionary can be code generated 
        # using the generate_code function.
        all_expressions = {&#34;forward_kinematics&#34;: self.fkin,
                           &#34;system_jacobian_matrix&#34;: self.J,
                           &#34;body_jacobian_matrix&#34;: self.Jb,
                           &#34;hybrid_jacobian_matrix&#34;: self.Jh,
                           &#34;system_jacobian_dot&#34;: self.Jdot,
                           &#34;body_twist_ee&#34;: self.Vb_ee,
                           &#34;hybrid_twist_ee&#34;: self.Vh_ee,
                           &#34;body_twist&#34;: self.Vb_BFn,
                           &#34;hybrid_twist&#34;: self.Vh_BFn,
                           &#34;body_jacobian_matrix_ee&#34;: self.Jb_ee,
                           &#34;hybrid_jacobian_matrix_ee&#34;: self.Jh_ee,
                           &#34;generalized_mass_inertia_matrix&#34;: self.M,
                           &#34;coriolis_centrifugal_matrix&#34;: self.C,
                           &#34;gravity_vector&#34;: self.Qgrav,
                           &#34;inverse_dynamics&#34;: self.Q,
                           &#34;hybrid_acceleration&#34;: self.Vhd_BFn,
                           &#34;body_acceleration&#34;: self.Vbd_BFn,
                           &#34;hybrid_acceleration_ee&#34;: self.Vhd_ee,
                           &#34;body_acceleration_ee&#34;: self.Vbd_ee,
                           &#34;hybrid_jacobian_matrix_dot&#34;: self.Jh_dot,
                           &#34;body_jacobian_matrix_dot&#34;: self.Jb_dot,
                           &#34;hybrid_jacobian_matrix_ee_dot&#34;: self.Jh_ee_dot,
                           &#34;body_jacobian_matrix_ee_dot&#34;: self.Jb_ee_dot}  
        # exclude expressions which are None
        if filterNone:
            filtered = {k: v for k, v in all_expressions.items()
                        if v is not None}
            return filtered
        return all_expressions

    def generate_code(self, python: bool=False, C: bool=False, Matlab: bool=False, 
                      cython: bool=False, latex: bool=False, landscape: bool=False,
                      folder: str=&#34;./generated_code&#34;, use_global_vars: bool=True, 
                      name: str=&#34;plant&#34;, project: str=&#34;Project&#34;) -&gt; None:
        &#34;&#34;&#34;Generate code from generated expressions. 
        Generates Python, C (C99), Matlab/Octave, Cython and/or LaTeX code.  
        Needs &#39;closed_form_inv_dyn_body_fixed&#39; and/or 
        &#39;closed_form_kinematics_body_fixed&#39; to run first.


        Args:
            python (bool, optional): 
                Generate Python code. Defaults to False.
            C (bool, optional): 
                Generate C99 code. Defaults to False.
            Matlab (bool, optional): 
                Generate Matlab/Octave code. Defaults to False.
            cython (bool, optional):
                Generate cython code. Defaults to False.
            latex (bool, optional):
                Generate latex code with all equations and generate pdf from it. 
                Defaults to False.
            landscape (bool, optional):
                Generate LaTeX document in landscape mode to fit longer equations.
                Defaults to False.
            folder (str, optional): 
                Folder where to save code. 
                Defaults to &#34;./generated_code&#34;.
            use_global_vars (bool, optional): 
                Constant vars like mass etc are no arguments of the 
                generated expressions. Defaults to True.
            name (str, optional): 
                Name of class and file. 
                Defaults to &#34;plant&#34;.
            project (str, optional): 
                Project name in C header. Defaults to &#34;Project&#34;.

        &#34;&#34;&#34;
        # create Folder
        if not os.path.exists(folder):
            os.mkdir(folder)

        # dict of expression names and expressions
        all_expressions = self.get_expressions_dict()

        # get individual tuples for expression names and expressions
        (names, expressions) = zip(*all_expressions.items())

        # generate set with all used symbols
        all_syms = set()
        for e in expressions:
            all_syms.update(e.free_symbols)

        if use_global_vars:
            # generate list of constant symbols
            constant_syms = self._sort_variables(
                all_syms
                .difference(self.var_syms)
                .difference(self.optional_var_syms)
                .union(self.subex_dict))
            # generate list with preassigned symbols like subexpressions
            # from common subexpression elimination
            not_assigned_syms = self._sort_variables(
                all_syms
                .difference(self.var_syms)
                .difference(self.optional_var_syms)
                .difference(self.assignment_dict)
                .difference(self.subex_dict)
                )
        else:
            constant_syms = []
            not_assigned_syms = []

        if python:
            print(&#34;Generate Python code&#34;)
            # create folder
            if not os.path.exists(os.path.join(folder, &#34;python&#34;)):
                os.mkdir(os.path.join(folder, &#34;python&#34;))

            p = NumPyPrinter()

            # start python file with import
            s = [&#34;import numpy\n\n&#34;]
            # class name
            s.append(&#34;class &#34;+regex.sub(&#34;^\w&#34;,lambda x: x.group().upper(),name)+&#34;():&#34;)
            # define __init__ function
            s.append(&#34;    def __init__(self, %s) -&gt; None:&#34; % (
                &#34;, &#34;.join(
                    [str(not_assigned_syms[i])+&#34;: float&#34; 
                     for i in range(len(not_assigned_syms))] 
                    + [str(i)+&#34;: float=&#34; + str(self.assignment_dict[i]) 
                       for i in self.assignment_dict])))
            if len(not_assigned_syms) &gt; 0:
                s.append(&#34;        &#34;
                         + &#34;, &#34;.join([&#34;self.&#34;+str(not_assigned_syms[i]) 
                                      for i in range(len(not_assigned_syms))])
                         + &#34; = &#34; 
                         + &#34;, &#34;.join([str(not_assigned_syms[i]) 
                                      for i in range(len(not_assigned_syms))])
                         )

            # append preassigned values to __init__ function
            if len(self.assignment_dict) &gt; 0:
                s.append(&#34;        &#34;
                         + &#34;, &#34;.join(sorted([&#34;self.&#34;+str(i) 
                                             for i in self.assignment_dict]))
                         + &#34; = &#34; 
                         + &#34;, &#34;.join(sorted([str(i) 
                                             for i in self.assignment_dict]))
                         )

            # append cse expressions to __init__ function
            if len(self.subex_dict) &gt; 0:
                for i in sorted([str(j) for j in self.subex_dict], key=lambda x: int(regex.findall(&#34;(?&lt;=sub)\d*&#34;,x)[0])):
                    modstring = p.doprint(self.subex_dict[symbols(i)])
                    for j in sorted([str(h) 
                                     for h in self.subex_dict[symbols(i)].free_symbols],
                                    reverse=1):
                        modstring = regex.sub(
                            str(j), &#34;self.&#34;+str(j), modstring)
                        # remove double self
                        modstring = regex.sub(&#34;self.self.&#34;, &#34;self.&#34;, modstring)
                    s.append(&#34;        self.&#34;+str(i)+&#34; = &#34; + modstring)

            # define functions
            for i in range(len(expressions)):
                var_syms = self._sort_variables(self.var_syms.intersection(
                    expressions[i].free_symbols))
                optional_var_syms = self._sort_variables(self.optional_var_syms.intersection(
                    expressions[i].free_symbols))
                const_syms = self._sort_variables(
                    set(constant_syms).intersection(
                        expressions[i].free_symbols))
                if len(var_syms) &gt; 0 or len(optional_var_syms) &gt; 0:
                    s.append(&#34;\n    def &#34;+names[i]+&#34;(self, %s) -&gt; numpy.ndarray:&#34; % (
                        &#34;, &#34;.join([str(var_syms[i])+&#34;: float&#34; 
                                   for i in range(len(var_syms))]
                                  + [str(optional_var_syms[i])+&#34;: float=0&#34; 
                                   for i in range(len(optional_var_syms))])))

                else:
                    s.append(&#34;\n    def &#34;+names[i]+&#34;(self) -&gt; numpy.ndarray:&#34;)
                
                if const_syms: # insert self. in front of const_syms
                    s.append(&#34;        &#34;
                            + names[i] 
                            + &#34; = &#34; 
                            + regex.sub(f&#34;(?&lt;=\W|^)(?={&#39;|&#39;.join([str(i) for i in const_syms])}(\W|\Z))&#34;,
                                        &#34;self.&#34;,
                                        p.doprint(expressions[i])))
                else: 
                    s.append(&#34;        &#34;
                            + names[i] 
                            + &#34; = &#34; 
                            + p.doprint(expressions[i]))
                s.append(&#34;        return &#34; + names[i])

            # replace numpy with np for better readability
            s = list(map(lambda x: x.replace(&#34;numpy.&#34;, &#34;np.&#34;), s))
            s[0] = &#34;import numpy as np\n\n&#34;

            # join list to string
            s = &#34;\n&#34;.join(s)

            # write python file
            with open(os.path.join(folder, &#34;python&#34;, name + &#34;.py&#34;), &#34;w+&#34;) as f:
                f.write(s)
            print(&#34;Done&#34;)

        if cython:
            print(&#34;Generate Cython code&#34;)
            # create folder
            if not os.path.exists(os.path.join(folder, &#34;cython&#34;)):
                os.mkdir(os.path.join(folder, &#34;cython&#34;))

            p = NumPyPrinter()

            # start python file with import
            s = [&#34;import numpy&#34;]
            s.append(&#34;cimport numpy\n\n&#34;)
            
            s.append(&#34;numpy.import_array()&#34;)
            s.append(&#34;DTYPE = numpy.float64&#34;)
            s.append(&#34;ctypedef numpy.float64_t DTYPE_t&#34;)
            
            s.append(&#34;\n&#34;)
            # class name
            s.append(&#34;cdef class &#34;+regex.sub(&#34;^\w&#34;,lambda x: x.group().upper(),name)+&#34;():&#34;)
            s.append(&#34;    cdef public double %s\n&#34;%(
                &#34;, &#34;.join(
                    [str(not_assigned_syms[i]) 
                        for i in range(len(not_assigned_syms))] 
                    + [str(i) 
                      for i in self.assignment_dict])))
            if self.subex_dict:
                s.append(&#34;    cdef double %s\n&#34;%(
                    &#34;, &#34;.join(
                        [str(i) 
                        for i in self.subex_dict])))
                    
            
            # define __cinit__ function
            s.append(&#34;    def __cinit__(self, %s):&#34; % (
                &#34;, &#34;.join(
                    [&#34;double &#34;+str(not_assigned_syms[i]) 
                     for i in range(len(not_assigned_syms))] 
                    + [&#34;double &#34;+str(i)+&#34; = &#34; + str(self.assignment_dict[i]) 
                       for i in self.assignment_dict])))
            if len(not_assigned_syms) &gt; 0:
                s.append(&#34;        &#34;
                         + &#34;, &#34;.join([&#34;self.&#34;+str(not_assigned_syms[i]) 
                                      for i in range(len(not_assigned_syms))])
                         + &#34; = &#34; 
                         + &#34;, &#34;.join([str(not_assigned_syms[i]) 
                                      for i in range(len(not_assigned_syms))])
                         )

            # append preassigned values to __cinit__ function
            if len(self.assignment_dict) &gt; 0:
                s.append(&#34;        &#34;
                         + &#34;, &#34;.join(sorted([&#34;self.&#34;+str(i) 
                                             for i in self.assignment_dict]))
                         + &#34; = &#34; 
                         + &#34;, &#34;.join(sorted([str(i) 
                                             for i in self.assignment_dict]))
                         )

            # append cse expressions to __cinit__ function
            if len(self.subex_dict) &gt; 0:
                for i in sorted([str(j) for j in self.subex_dict], key=lambda x: int(regex.findall(&#34;(?&lt;=sub)\d*&#34;,x)[0])):
                    modstring = p.doprint(self.subex_dict[symbols(i)])
                    for j in sorted([str(h) 
                                     for h in self.subex_dict[symbols(i)].free_symbols],
                                    reverse=1):
                        modstring = regex.sub(
                            str(j), &#34;self.&#34;+str(j), modstring)
                        modstring = regex.sub(&#34;(?&lt;=(\W|^)(?&lt;!\.)\d+)(?!\.)(?=\W|\Z)&#34;,&#34;.0&#34;, modstring) # replace integer with floats
                        # remove double self
                        modstring = regex.sub(&#34;self.self.&#34;, &#34;self.&#34;, modstring)
                    s.append(&#34;        self.&#34;+str(i)+&#34; = &#34; + modstring)

            # define functions
            for i in range(len(expressions)):
                var_syms = self._sort_variables(self.var_syms.intersection(
                    expressions[i].free_symbols))
                optional_var_syms = self._sort_variables(self.optional_var_syms.intersection(
                    expressions[i].free_symbols))
                const_syms = self._sort_variables(
                    set(constant_syms).intersection(
                        expressions[i].free_symbols))
                if len(var_syms) &gt; 0 or len(optional_var_syms) &gt; 0:
                    s.append(f&#34;\n    cpdef &#34;+names[i]+&#34;(self, %s):&#34; % (
                    # s.append(f&#34;\n    cpdef np.ndarray[DTYPE_t,ndim={len(expressions[i].shape)}] &#34;+names[i]+&#34;(self, %s):&#34; % (
                        &#34;, &#34;.join([&#34;double &#34;+str(var_syms[i]) 
                                   for i in range(len(var_syms))]
                                  + [&#34;double &#34;+str(optional_var_syms[i])+&#34;=0.0&#34; 
                                     for i in range(len(optional_var_syms))])))

                else:
                    s.append(&#34;\n    cpdef &#34;+names[i]+&#34;(self):&#34;)
                
                s.append(f&#34;        cdef numpy.ndarray[DTYPE_t,ndim={len(expressions[i].shape)}] &#34;
                         + names[i])
                if const_syms:
                    ex_string = regex.sub(f&#34;(?&lt;=\W|^)(?={&#39;|&#39;.join([str(i) for i in const_syms])}(\W|\Z))&#34;,&#34;self.&#34;,p.doprint(expressions[i]))
                    # replace integer with floats
                    ex_string = regex.sub(&#34;(?&lt;=(\W|^)(?&lt;!\.)\d+)(?!\.)(?=\W|\Z)&#34;,&#34;.0&#34;, ex_string) 
                    s.append(&#34;        &#34;
                            + names[i] 
                            + &#34; = &#34; 
                            + ex_string)
                            #  + regex.sub(&#34;(?&lt;=((?&lt;=[^\.])\W)\d+)(?=\W)(?!\.)&#34;,&#34;.0&#34;,regex.sub(f&#34;(?&lt;=\W|^)(?={&#39;|&#39;.join([str(i) for i in const_syms])}(\W|\Z))&#34;,&#34;self.&#34;,p.doprint(expressions[i]))))
                else:
                    ex_string = p.doprint(expressions[i])
                    # replace integer with floats
                    ex_string = regex.sub(&#34;(?&lt;=(\W|^)(?&lt;!\.)\d+)(?!\.)(?=\W|\Z)&#34;,&#34;.0&#34;, ex_string) 
                    s.append(&#34;        &#34;
                            + names[i] 
                            + &#34; = &#34; 
                            + ex_string)
                    
                s.append(&#34;        return &#34; + names[i])

            # replace numpy with np for better readability
            s = list(map(lambda x: x.replace(&#34;numpy.&#34;, &#34;np.&#34;), s))
            s[0] = &#34;import numpy as np&#34;
            s[1] = &#34;cimport numpy as np\n\n&#34;

            # join list to string
            s = &#34;\n&#34;.join(s)

            # create setup file to compile cython code
            su = (&#34;import os.path\n&#34;
                  + &#34;from setuptools import setup\n&#34;
                  + &#34;from Cython.Build import cythonize\n&#34;
                  + &#34;\n&#34;
                  + &#34;setup(\n&#34;
                  + f&#34;    name=&#39;{name}&#39;,\n&#34;
                  + f&#34;    ext_modules=cythonize(os.path.join(os.path.dirname(__file__), &#39;{name + &#39;.pyx&#39;}&#39;), \n&#34;
                  +  &#34;                          compiler_directives={&#39;language_level&#39; : &#39;3&#39;}),\n&#34;
                  + &#34;    zip_safe=False,\n&#34;
                  + &#34;)\n&#34;
            )


            # write cython file
            with open(os.path.join(folder, &#34;cython&#34;, name + &#34;.pyx&#34;), &#34;w+&#34;) as f:
                f.write(s)
            
            # write setup file
            with open(os.path.join(folder, &#34;cython&#34;, &#34;setup_&#34; + name + &#34;.py&#34;), &#34;w+&#34;) as f:
                f.write(su)
            
            print(&#34;Done&#34;)

        if C:
            print(&#34;Generate C code&#34;)
            if not os.path.exists(os.path.join(folder, &#34;C&#34;)):
                os.mkdir(os.path.join(folder, &#34;C&#34;))

            # generate c files
            if use_global_vars:
                [(c_name, c_code), (h_name, c_header)] = codegen(
                    [tuple((names[i], expressions[i])) 
                     for i in range(len(expressions))],
                    &#34;C99&#34;, name, project, header=False, 
                    empty=True, global_vars=constant_syms)
            else:
                [(c_name, c_code), (h_name, c_header)] = codegen(
                    [tuple((names[i], expressions[i])) 
                     for i in range(len(expressions))],
                    &#34;C99&#34;, name, project, header=False, empty=True)
            # change strange variable names
            c_code = regex.sub(r&#34;out_\d{10}[\d]+&#34;, &#34;out&#34;, c_code)
            c_header = regex.sub(r&#34;out_\d{10}[\d]+&#34;, &#34;out&#34;, c_header)

            c_lines = c_code.splitlines(True)
            i = 0
            # correct dimension of output array pointers
            while i &lt; len(c_lines):
                # find function definition
                if any(n+&#34;(&#34; in c_lines[i] for n in names):
                    # which expression is defined
                    [fname] = [n for n in names if n+&#34;(&#34; in c_lines[i]]
                    # find shape of expression
                    cols = all_expressions[fname].shape[1]
                    i += 1
                    # replace all 1D arrays with 2D arrays for matrices
                    while &#34;}&#34; not in c_lines[i]:
                        out = regex.findall(&#34;out\[[\d]+\]&#34;, c_lines[i])
                        if out and cols &gt; 1:
                            [num] = regex.findall(&#34;[\d]+&#34;, out[0])
                            num = int(num)
                            c_lines[i] = c_lines[i].replace(
                                out[0], f&#34;out[{num//cols}][{num%cols}]&#34;)
                        i += 1
                i += 1
            c_code = &#34;&#34;.join(c_lines)
            
            # save assinged parameters to another c file
            c_def_name = f&#34;{c_name[:-2]}_parameters.c&#34;
            header_insert = []
            c_definitions = [f&#39;#include &#34;{h_name}&#34;\n&#39;]
            c_definitions.append(&#34;#include &lt;math.h&gt;\n&#34;)
            c_definitions.append(&#34;\n&#34;)
            
            if not_assigned_syms:
                header_insert.append(f&#34;/* Please uncomment and assign values in &#39;{c_def_name}&#39;\n&#34;)
                c_definitions.append(f&#34;/* Please assign values and uncomment in &#39;{h_name}&#39;\n&#34;)
                for var in sorted([str(i) for i in not_assigned_syms]):
                    header_insert.append(f&#34;extern const float {var};\n&#34;)
                    if var == &#34;g&#34;:
                        c_definitions.append(f&#34;const float {var} = 9.81;\n&#34;)
                    else:
                        c_definitions.append(f&#34;const float {var} = 0;\n&#34;)
                header_insert.append(&#34;*/ \n&#34;)
                c_definitions.append(&#34;*/ \n&#34;)
            
            for var in sorted([str(i) for i in self.assignment_dict]):
                val = ccode(self.assignment_dict[symbols(var)])
                header_insert.append(f&#34;extern const float {var};\n&#34;)
                c_definitions.append(f&#34;const float {var} = {val};\n&#34;)


            # append cse expressions
            for var in sorted([str(j) for j in self.subex_dict], key=lambda x: int(regex.findall(&#34;(?&lt;=sub)\d*&#34;,x)[0])):
                val = ccode(self.subex_dict[symbols(var)])
                header_insert.append(f&#34;extern const float {var};\n&#34;)
                c_definitions.append(f&#34;const float {var} = {val};\n&#34;)

            
            
            if header_insert:
                header_insert.append(&#34;\n&#34;)
                h_lines = c_header.splitlines(True)
                for i in range(len(h_lines)):
                    if &#34;#endif&#34; in h_lines[i]:
                        h_lines[i:i] = header_insert 
                        break
                c_header = &#34;&#34;.join(h_lines)

            # write code files
            with open(os.path.join(folder, &#34;C&#34;, c_name), &#34;w+&#34;) as f:
                f.write(c_code)
            with open(os.path.join(folder, &#34;C&#34;, h_name), &#34;w+&#34;) as f:
                f.write(c_header)
            if header_insert:
                with open(os.path.join(folder, &#34;C&#34;, c_def_name), &#34;w+&#34;) as f:
                    f.writelines(c_definitions)
                
            print(&#34;Done&#34;)

        if Matlab:
            # create folder
            if not os.path.exists(os.path.join(folder, &#34;matlab&#34;)):
                os.mkdir(os.path.join(folder, &#34;matlab&#34;))
            m_class = []
            m_class.append(f&#34;classdef {name}\n&#34;)
            m_properties = not_assigned_syms[:]
            m_properties.extend([i for i in self.assignment_dict])
            # properties
            m_class.append(f&#34;\tproperties\n&#34;)
            for var in m_properties:
                m_class.append(f&#34;\t\t{str(var)}\n&#34;)
            # add cse subexpressions as private properties
            if self.subex_dict:
                m_class.append(&#34;\tend\n\n&#34;)
                m_class.append(f&#34;\tproperties (Access = private)\n&#34;)
                for var in [i for i in sorted([str(j) for j in self.subex_dict], key=lambda x: int(regex.findall(&#34;(?&lt;=sub)\d*&#34;,x)[0]))]:
                    m_class.append(f&#34;\t\t{str(var)}\n&#34;)
                # add subex to m_properties list
                m_properties.extend([i for i in sorted([str(j) for j in self.subex_dict], key=lambda x: int(regex.findall(&#34;(?&lt;=sub)\d*&#34;,x)[0]))])
            m_class.append(&#34;\tend\n\n&#34;)
            
            # methods
            m_class.append(f&#34;\tmethods\n&#34;)
            
            # init function
            # function argumens
            var_substr = &#34;, &#34;.join(
                    [str(not_assigned_syms[i]) 
                     for i in range(len(not_assigned_syms))] 
                    + [str(j) for j in self.assignment_dict])
            m_class.append(f&#34;\t\tfunction obj = {name}({var_substr})\n&#34;)
            
            # default values for not assigned variables
            if not_assigned_syms:
                m_class.append(f&#34;\t\t\t% TODO: Assign missing variables here:\n&#34;)
                for var in not_assigned_syms:
                    if str(var) == &#34;g&#34;:
                        m_class.append(f&#34;\t\t\t% if ~exist(&#39;{str(var)}&#39;,&#39;var&#39;); {str(var)} = 9.81; end\n&#34;)
                    else:
                        m_class.append(f&#34;\t\t\t% if ~exist(&#39;{str(var)}&#39;,&#39;var&#39;); {str(var)} = 0; end\n&#34;)
            # default values for assigned variables
            for var in self.assignment_dict:
                val = octave_code(self.assignment_dict[var])
                m_class.append(f&#34;\t\t\tif ~exist(&#39;{str(var)}&#39;,&#39;var&#39;); {str(var)} = {val}; end\n&#34;)
            m_class.append(&#34;&#34;)
            # save variables to parameters
            for var in not_assigned_syms:
                m_class.append(f&#34;\t\t\tobj.{str(var)} = {str(var)};\n&#34;)
            for var in self.assignment_dict:
                m_class.append(f&#34;\t\t\tobj.{str(var)} = {str(var)};\n&#34;)
            # calculate subexpressions
            for var in sorted([str(j) for j in self.subex_dict], key=lambda x: int(regex.findall(&#34;(?&lt;=sub)\d*&#34;,x)[0])):
                val = regex.sub(&#34;(?&lt;=\W|^)sub&#34;,&#34;obj.sub&#34;,octave_code(self.subex_dict[symbols(var)]))
                m_class.append(f&#34;\t\t\tobj.{str(var)} = {val};\n&#34;)       
            m_class.append(&#34;\t\tend\n\n&#34;)
            
            # Add generated functions
            for i in range(len(expressions)):
                # generate function
                [(m_name, m_code)] = codegen(
                    (names[i], expressions[i]), &#34;Octave&#34;, project=project, 
                    header=False, empty=True, 
                    argument_sequence=self._sort_variables(self.all_symbols)
                    )
                # remove already set variables
                m_func = m_code.splitlines(True)
                m_func = [f&#34;\t\t{line}&#34; for line in m_func]
                m_func[0] = m_func[0].replace(&#34;(&#34;,&#34;(obj, &#34;)
                m_func[0] = regex.sub(
                    &#34;(&#34; + &#39;|&#39;.join([f&#39;, {str(v)}(?=\W)&#39; for v in m_properties])+&#34;)&#34;,
                    &#34;&#34;, m_func[0])
                # remove unused variable symbols
                m_func[0] = regex.sub(
                    &#34;(&#34; + &#39;|&#39;.join([f&#39;, {str(v)}(?=\W)&#39; for v in self.var_syms.union(self.optional_var_syms).difference(expressions[i].free_symbols)])+&#34;)&#34;,
                    &#34;&#34;, m_func[0])
                # use obj.variables defined in class parameters
                for i in range(1, len(m_func)):
                    m_func[i] = regex.sub(f&#34;(?&lt;=\W|^)(?=({&#39;|&#39;.join([str(s) for s in m_properties])})\W)&#34;,&#34;obj.&#34;,m_func[i])        
                m_func.append(&#34;\n&#34;)
                m_class.extend(m_func)
            
            m_class.append(&#34;\tend\n&#34;)
            m_class.append(&#34;end\n&#34;)
            with open(os.path.join(folder, &#34;matlab&#34;, f&#34;{name}.m&#34;), &#34;w+&#34;) as f:
                f.writelines(m_class)
        
        if latex:
            # create folder
            if not os.path.exists(os.path.join(folder, &#34;latex&#34;)):
                os.mkdir(os.path.join(folder, &#34;latex&#34;))

            # Document with `\maketitle` command activated
            doc = Document(documentclass=&#34;article&#34;, inputenc=&#34;utf8&#34;)
            if landscape:
                doc.packages.append(NoEscape(r&#34;\usepackage[landscape,a4paper,top=2cm,bottom=2cm,left=2.5cm,right=2.5cm,marginparwidth=1.75cm]{geometry}&#34;))
            else: 
                doc.packages.append(NoEscape(r&#34;\usepackage[a4paper,top=2cm,bottom=2cm,left=2.5cm,right=2.5cm,marginparwidth=1.75cm]{geometry}&#34;))
            doc.packages.append(NoEscape(r&#34;\usepackage{amsmath}&#34;))
            doc.packages.append(NoEscape(r&#34;\usepackage{graphicx}&#34;))
            
            doc.preamble.append(Command(&#34;title&#34;, &#34;Equations of Motion&#34;))
            doc.preamble.append(Command(&#34;author&#34;, &#34;Author: SymbolicKinDyn&#34;))
            doc.preamble.append(Command(&#34;date&#34;, NoEscape(r&#34;\today&#34;)))
            doc.append(NoEscape(r&#34;\maketitle&#34;))
            doc.append(NoEscape(r&#34;\tableofcontents&#34;))
            doc.append(NoEscape(r&#34;\newpage&#34;))
            
            # create symbols and indices for equations
            for i in range(len(expressions)):
                letter = &#34;&#34;
                if &#34;jacobian&#34; in names[i]: letter = &#34;J&#34;
                elif &#34;twist&#34; in names[i]: letter = r&#34;V&#34;
                elif &#34;kinematics&#34; in names[i]: letter = r&#34;^0T_E&#34;
                elif &#34;inertia&#34; in names[i]: letter = &#34;M&#34;
                elif &#34;coriolis&#34; in names[i]: letter = &#34;C&#34;
                elif &#34;gravity&#34; in names[i]: letter = &#34;g&#34;
                elif &#34;dynamics&#34; in names[i]: letter = r&#34;\tau&#34;
                elif &#34;acceleration&#34; in names[i]: letter = r&#34;\dot V&#34;
                if &#34;dot&#34; in names[i]: letter = r&#34;\dot &#34;+letter
                if &#34;_ee&#34; in names[i]: letter = r&#34;^E&#34; + letter
                elif (&#34;twist&#34; in names[i] 
                      or &#34;jacobian&#34; in names[i] 
                      or &#34;acceleration&#34; in names[i]): letter = r&#34;^0&#34; + letter
                if &#34;hybrid&#34; in names[i]: letter += r&#34;_h&#34;
                elif &#34;body&#34; in names[i]: letter += r&#34;_b&#34;
                
                replacements = [(&#34;ddq&#34;, r&#34;\\ddot q&#34;), (&#34;dq&#34;, r&#34;\\dot q&#34;)]
                with doc.create(Section(regex.sub(&#34;_&#34;,&#34; &#34;,names[i]))):
                    eq = LatexPrinter().doprint(expressions[i])
                    for pat, repl in replacements:
                        eq = regex.sub(pat, repl, eq)
                    # doc.append(NoEscape(r&#34;\begin{footnotesize}&#34;))
                    doc.append(NoEscape(r&#34;\[ \resizebox{\ifdim\width&gt;\columnwidth\columnwidth\else\width\fi}{!}{$%&#34;))
                    doc.append(NoEscape(r&#34;\boldsymbol{&#34;f&#34;{letter}&#34;&#34;} = &#34;f&#34;{eq}&#34;))
                    doc.append(NoEscape(r&#34;$} \]&#34;))
                    # doc.append(NoEscape(r&#34;\end{footnotesize}&#34;))
                    doc.append(&#34;\n&#34;)
            
            # save tex file and compile pdf
            doc.generate_pdf(os.path.join(folder, &#34;latex&#34;,name), clean_tex=False)
                
            
class SymbolicKinDyn(_AbstractCodeGeneration):
    BODY_FIXED = &#34;body_fixed&#34;
    SPATIAL = &#34;spatial&#34;
    
    def __init__(self, 
                 gravity_vector: MutableDenseMatrix=None, 
                 ee: MutableDenseMatrix=None, 
                 body_ref_config: List[MutableDenseMatrix]=[], 
                 joint_screw_coord: List[MutableDenseMatrix]=[], 
                 config_representation: str=&#34;spatial&#34;, 
                 Mb: List[MutableDenseMatrix]=[], 
                 parent: List[int]=[], 
                 support: List[List[int]]=[], 
                 child: List[List[int]]=[], 
                 q:MutableDenseMatrix=None, 
                 qd: MutableDenseMatrix=None, 
                 q2d: MutableDenseMatrix=None, 
                 WEE: MutableDenseMatrix=zeros(6, 1),
                 **kwargs) -&gt; None:
        &#34;&#34;&#34;SymbolicKinDyn
        Symbolic tool to compute equations of motion of serial chain 
        robots and autogenerate code from the calculated equations. 
        This tool supports generation of python, C and Matlab code.

        Args:
            gravity_vector (sympy.Matrix, optional): 
                Vector of gravity. Defaults to None.
            ee (sympy.Matrix, optional): 
                End-effector configuration with reference to last link 
                body fixed frame in the chain. Defaults to None.
            body_ref_config (list of sympy.Matrix, optional): 
                List of reference configurations of bodies in body-fixed
                or spatial representation, dependent on selected 
                config_representation. 
                Leave empty for dH Parameter usage (dhToScrewCoord(...)). 
                Defaults to [].
            joint_screw_coord (list of sympy.Matrix, optional): 
                List of joint screw coordinates in body-fixed 
                or spatial representation, dependent on selected 
                config_representation. 
                Leave empty for dH Parameter usage (dhToScrewCoord(...)). 
                Defaults to [].
            config_representation (str, optional): 
                Use body fixed or spatial representation for reference 
                configuration of bodies and joint screw coordinates.
                Has to be &#34;body_fixed&#34; or &#34;spatial&#34;. 
                Defaults to &#34;spatial&#34;.
            Mb (list of sympy.Matrix, optional): 
                List of Mass Inertia matrices for all links. Only 
                necessary for inverse dynamics. Defaults to [].
            parent (list, optional): 
                list of parent link indices for any joint. Use 0 for world.
                Only necessary for tree-like robot structures. 
                Defaults to [].
            support (list, optional): 
                list of lists with one list per link which includes all 
                support links beginning with the first link in the chain 
                and including the current link.
                Only necessary for tree-like robot structures. 
                Defaults to [].
            child (list, optional): 
                list of lists with one list per link which includes all
                child links. Use empty list if no child link is present.
                Only necessary for tree-like robot structures. 
                Defaults to [].
            q (sympy.Matrix, optional): 
                (n,1) Generalized position vector. Defaults to None.
            qd (sympy.Matrix, optional): 
                (n,1) Generalized velocity vector. Defaults to None.
            q2d (sympy.Matrix, optional): 
                (n,1) Generalized acceleration vector. Defaults to None.
            WEE (sympy.Matrix, optional): 
                (6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time varying 
                wrench on the EE link. 
                Defaults to zeros(6, 1).
            
        &#34;&#34;&#34;
        super().__init__()
        self.n = None  # degrees of freedom
        self.gravity_vector = gravity_vector
        self.ee = ee

        self.B = [] # List of reference configurations of bodies in body-fixed representation.
        self.X = [] # List of joint screw coordinates in body-fixed representation.

        self.A = [] # List of reference configurations of bodies in spatial representation.
        self.Y = [] # List of joint screw coordinates in spatial representation.
        
        self.config_representation = config_representation # @property: checks for valid value 
        if body_ref_config != []:
            self.body_ref_config = body_ref_config # @property: sets A or B
        if joint_screw_coord != []:
            self.joint_screw_coord = joint_screw_coord # @property: sets X or Y
        # support of old syntax
        if &#34;A&#34; in kwargs:
            self.A = kwargs[&#34;A&#34;]
            n = len(self.A)
            if n:
                self.n = n
        if &#34;B&#34; in kwargs:
            self.B = kwargs[&#34;B&#34;]
            n = len(self.B)
            if n:
                self.n = n
        if &#34;X&#34; in kwargs:
            self.X = kwargs[&#34;X&#34;]
        if &#34;Y&#34; in kwargs:
            self.Y = kwargs[&#34;Y&#34;]

            
        self.Mb = Mb
        self.parent = parent
        self.child = child
        self.support = support

        # temporary vars
        self._FK_C = None
        self._A = None
        self._a = None
        self._V = None  # system twist

        
        # Multiprocessing
        # dict of queues, which saves values and results
        self.queue_dict = {}  
        # dict of running processes
        self.process_dict = {}  
        
        # generalized vectors end external forces
        self.q = q
        self.qd = qd
        self.q2d = q2d
        self.WEE = WEE

        
    @property
    def config_representation(self) -&gt; str:
        return self._config_representation
    
    @config_representation.setter
    def config_representation(self, value: str) -&gt; None:
        if value not in {self.BODY_FIXED, self.SPATIAL}:
            raise ValueError(&#34;config_representation has to be &#39;body_fixed&#39; or &#39;spatial&#39;&#34;)
        self._config_representation = value
    
    @property
    def body_ref_config(self) -&gt; list:
        if self.config_representation == self.BODY_FIXED:
            return self.B
        elif self.config_representation == self.SPATIAL:
            return self.A
    
    @body_ref_config.setter
    def body_ref_config(self, value: List[MutableDenseMatrix]) -&gt; None:
        n = len(value)
        if n:
            self.n = n
        if self.config_representation == self.BODY_FIXED:
            self.B = value
        elif self.config_representation == self.SPATIAL:
            self.A = value
    
    @property
    def joint_screw_coord(self) -&gt; list:
        if self.config_representation == self.BODY_FIXED:
            return self.X
        elif self.config_representation == self.SPATIAL:
            return self.Y
    
    @joint_screw_coord.setter
    def joint_screw_coord(self, value: List[MutableDenseMatrix]) -&gt; None:
        if self.config_representation == self.BODY_FIXED:
            self.X = value
        elif self.config_representation == self.SPATIAL:
            self.Y = value
    
    def closed_form_kinematics_body_fixed(
        self, q:sympy.MutableDenseMatrix=None, qd: MutableDenseMatrix=None, 
        q2d: MutableDenseMatrix=None, simplify: bool=True, 
        cse: bool=False, parallel: bool=True) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Position, Velocity and Acceleration Kinematics using Body 
        fixed representation of the twists in closed form.

        The following expressions are saved in the class and can be 
        code generated afterwards:
        
            body_acceleration
            body_acceleration_ee
            body_jacobian_matrix
            body_jacobian_matrix_dot 
            body_jacobian_matrix_ee
            body_jacobian_matrix_ee_dot
            body_twist_ee
            forward_kinematics
            hybrid_acceleration
            hybrid_acceleration_ee
            hybrid_jacobian_matrix
            hybrid_jacobian_matrix_dot
            hybrid_jacobian_matrix_ee
            hybrid_jacobian_matrix_ee_dot
            hybrid_twist_ee

        Needs class parameters body_ref_config, joint_screw_coord and ee 
        to be defined.

        Args:
            q (sympy.Matrix, optional): 
                (n,1) Generalized position vector. Defaults to None.
            qd (sympy.Matrix, optional): 
                (n,1) Generalized velocity vector. Defaults to None.
            q2d (sympy.Matrix, optional): 
                (n,1) Generalized acceleration vector. Defaults to None.
            simplify (bool, optional): 
                Use simplify command on saved expressions. 
                Defaults to True.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.
            parallel (bool, optional): 
                Use parallel computation via multiprocessing. 
                Defaults to True.
        Raises:
            ValueError:
                Joint screw coordinates and/or reference configuration 
                of bodies not set.
                
        Returns:
            sympy.Matrix: Forward kinematics.
        &#34;&#34;&#34;
        if not q or not qd or not q2d:
            if not self.n:
                self.n = len(self.body_ref_config)
            if not self.q or not self.qd or not self.q2d:
                q, qd, q2d = generalized_vectors(self.n,self._find_start_index())
            else:
                q, qd, q2d = self.q, self.qd, self.q2d
            
        if parallel:
            self._closed_form_kinematics_body_fixed_parallel(
                q, qd, q2d, simplify, cse)
        else:
            self._closed_form_kinematics_body_fixed(
                q, qd, q2d, simplify, cse)
        return self.fkin

    def closed_form_inv_dyn_body_fixed(
        self, q:sympy.MutableDenseMatrix=None, qd: MutableDenseMatrix=None, 
        q2d: MutableDenseMatrix=None, WEE: MutableDenseMatrix=..., 
        simplify: bool=True, cse: bool=False, 
        parallel: bool=True) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Inverse dynamics using body fixed representation of the 
        twists in closed form. 

        The following expressions are saved in the class and can be 
        code generated afterwards:
            coriolis_centrifugal_matrix
            generalized_mass_inertia_matrix
            gravity_vector
            inverse_dynamics

        Args:
            q (sympy.Matrix, optional): 
                (n,1) Generalized position vector. Defaults to None.
            qd (sympy.Matrix, optional): 
                (n,1) Generalized velocity vector. Defaults to None.
            q2d (sympy.Matrix, optional): 
                (n,1) Generalized acceleration vector. Defaults to None.
            WEE (sympy.Matrix, optional): 
                (6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time varying 
                wrench on the EE link. 
                Defaults to zeros(6, 1).
            simplify (bool, optional): 
                Use simplify command on saved expressions. 
                Defaults to True.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.
            parallel (bool, optional): 
                Use parallel computation via multiprocessing. 
                Defaults to True.

        Raises:
            ValueError:
                Joint screw coordinates and/or reference configuration 
                of bodies not set.
        
        Returns:
            sympy.Matrix: Generalized forces
        &#34;&#34;&#34;
        if not q or not qd or not q2d:
            if not self.n:
                self.n = len(self.body_ref_config)
            if not self.q or not self.qd or not self.q2d:
                q, qd, q2d = generalized_vectors(self.n,self._find_start_index())
            else:
                q, qd, q2d = self.q, self.qd, self.q2d
        
        if WEE is Ellipsis:
            WEE = self.WEE
            
        if parallel:
            self._closed_form_inv_dyn_body_fixed_parallel(
                q, qd, q2d, WEE, simplify, cse)
        else:
            self._closed_form_inv_dyn_body_fixed(
                q, qd, q2d, WEE, simplify, cse)
        return self.Q

    def _closed_form_kinematics_body_fixed(
        self, q: MutableDenseMatrix, qd: MutableDenseMatrix, 
        q2d: MutableDenseMatrix, simplify: bool=True, 
        cse: bool=False) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Position, velocity and acceleration kinematics using 
        body fixed representation of the twists in closed form.

        The following expressions are saved in the class and can be 
        code generated afterwards:
            body_acceleration
            body_acceleration_ee
            body_jacobian_matrix
            body_jacobian_matrix_dot 
            body_jacobian_matrix_ee
            body_jacobian_matrix_ee_dot
            body_twist_ee
            forward_kinematics
            hybrid_acceleration
            hybrid_acceleration_ee
            hybrid_jacobian_matrix
            hybrid_jacobian_matrix_dot
            hybrid_jacobian_matrix_ee
            hybrid_jacobian_matrix_ee_dot
            hybrid_twist_ee

            Needs class parameters body_ref_config, joint_screw_coord 
            and ee to be defined.

        Args:
            q (sympy.Matrix): 
                (n,1) Generalized position vector.
            qd (sympy.Matrix): 
                (n,1) Generalized velocity vector.
            q2d (sympy.Matrix): 
                (n,1) Generalized acceleration vector.
            simplify (bool, optional): 
                Use simplify command on saved expressions. 
                Defaults to True.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.


        Returns:
            sympy.Matrix: Forward kinematics.
        &#34;&#34;&#34;
        print(&#34;Forward kinematics calculation&#34;)
        self.var_syms.update(q.free_symbols)
        self.var_syms.update(qd.free_symbols)
        self.var_syms.update(q2d.free_symbols)

        self.n = len(q)  # DOF

        # calc Forward kinematics
        if self.parent and self.support:
            FK_C, A = self._calc_A_matrix_tree(q)
        else:    
            FK_C, A = self._calc_A_matrix(q)
            
        fkin = FK_C[self.n-1]*self.ee
        if simplify:
            fkin = self.simplify(fkin, cse)
        elif cse:
            fkin = self._cse_expression(fkin)    
        self.fkin = fkin


        if self.J is not None:
            J = self.J
            V = self._V
        else:
            # Block diagonal matrix X (6n x n) of the screw coordinate 
            # vector associated to all joints in the body frame (Constant)
            X = zeros(6*self.n, self.n)
            for i in range(self.n):
                X[6*i:6*i+6, i] = self.X[i]

            # System level Jacobian
            J = A*X
            if simplify:
                J = self.simplify(J, cse)
            elif cse:
                J = self._cse_expression(J)
            self.J = J

            # System twist (6n x 1)
            V = J*qd
            self._V = V

        # Different Jacobians
        R_i = Matrix(fkin[:3, :3]).row_join(
            zeros(3, 1)).col_join(Matrix([0, 0, 0, 1]).T)
        if simplify:  # fastens later simplifications
            R_i = self.simplify(R_i, cse)
        elif cse:
            R_i = self._cse_expression(R_i)

        R_BFn = Matrix(FK_C[-1][:3, :3]).row_join(
            zeros(3, 1)).col_join(Matrix([0, 0, 0, 1]).T)

        # Body fixed Jacobian of last moving body 
        # (This may not correspond to end-effector frame)
        Jb = J[-6:, :]
        if simplify:
            Jb = self.simplify(Jb, cse)
        elif cse:
            Jb = self._cse_expression(Jb)

        Vb_BFn = Jb*qd  # Body fixed twist of last moving body
        if simplify:
            Vb_BFn = self.simplify(Vb_BFn, cse)
        elif cse:
            Vb_BFn = self._cse_expression(Vb_BFn)
        Vh_BFn = SE3AdjMatrix(R_BFn)*Vb_BFn
        if simplify:
            Vh_BFn = self.simplify(Vh_BFn, cse)
        elif cse:
            Vh_BFn = self._cse_expression(Vh_BFn)
        self.Vb_BFn = Vb_BFn
        self.Vh_BFn = Vh_BFn

        # Body fixed twist of end-effector frame
        Vb_ee = SE3AdjMatrix(SE3Inv(self.ee))*Vb_BFn
        if simplify:
            Vb_ee = self.simplify(Vb_ee, cse)
        elif cse:
            Vb_ee = self._cse_expression(Vb_ee)
        # Hybrid twist of end-effector frame
        Vh_ee = SE3AdjMatrix(R_i)*Vb_ee
        if simplify:
            Vh_ee = self.simplify(Vh_ee, cse)
        elif cse:
            Vh_ee = self._cse_expression(Vh_ee)

        self.Vb_ee = Vb_ee
        self.Vh_ee = Vh_ee

        # Body fixed Jacobian of end-effector frame
        Jb_ee = SE3AdjMatrix(SE3Inv(self.ee))*Jb
        if simplify:
            Jb_ee = self.simplify(Jb_ee, cse)
        elif cse:
            Jb_ee = self._cse_expression(Jb_ee)

        # Hybrid Jacobian of end-effector frame
        Jh_ee = SE3AdjMatrix(R_i)*Jb_ee
        # Hybrid Jacobian of last moving body
        Jh = SE3AdjMatrix(R_i)*Jb  

        if simplify:
            Jh_ee = self.simplify(Jh_ee, cse)
            Jh = self.simplify(Jh, cse)
        elif cse:
            Jh_ee = self._cse_expression(Jh_ee)
            Jh = self._cse_expression(Jh)

        self.Jh_ee = Jh_ee
        self.Jb_ee = Jb_ee
        self.Jh = Jh
        self.Jb = Jb

        # Acceleration computations
        if self._a is not None:
            a = self._a
        else:
            # Block diagonal matrix a (6n x 6n)
            a = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                a[6*i:6*i+6, 6*i:6*i+6] = SE3adMatrix(self.X[i])*qd[i]
            if simplify:
                a = self.simplify(a, cse)
            elif cse:
                a = self._cse_expression(a)
            self._a = a

        # System acceleration (6n x 1)
        Jdot = -A*a*J  # Sys-level Jacobian time derivative
        if simplify:
            Jdot = self.simplify(Jdot, cse)
        elif cse:
            Jdot = self._cse_expression(Jdot)

        self.Jdot = Jdot

        Vbd = J*q2d - A*a*V

        # Hybrid acceleration of the last body
        Vbd_BFn = Vbd[-6:, :]
        if simplify:
            Vbd_BFn = self.simplify(Vbd_BFn, cse)
        elif cse:
            Vbd_BFn = self._cse_expression(Vbd_BFn)
        # Hybrid twist of end-effector frame 
        # TODO: check comments
        Vhd_BFn = (SE3AdjMatrix(R_BFn)*Vbd_BFn 
                   + SE3adMatrix(Matrix(Vh_BFn[:3, :])
                                      .col_join(Matrix([0, 0, 0])))
                   * SE3AdjMatrix(R_BFn)*Vb_BFn)  

        if simplify:
            Vhd_BFn = self.simplify(Vhd_BFn, cse)
        elif cse:
            Vhd_BFn = self._cse_expression(Vhd_BFn)

        self.Vbd_BFn = Vbd_BFn
        self.Vhd_BFn = Vhd_BFn

        # Body fixed twist of end-effector frame
        # Hybrid acceleration of the EE
        Vbd_ee = SE3AdjMatrix(SE3Inv(self.ee))*Vbd_BFn
        if simplify:
            Vbd_ee = self.simplify(Vbd_ee, cse)
        elif cse:
            Vbd_ee = self._cse_expression(Vbd_ee)
        # Hybrid twist of end-effector frame
        Vhd_ee = SE3AdjMatrix(R_i)*Vbd_ee + SE3adMatrix(Matrix(
            Vh_ee[:3, :]).col_join(Matrix([0, 0, 0])))*\
                SE3AdjMatrix(R_i)*Vb_ee  
        if simplify:
            Vhd_ee = self.simplify(Vhd_ee, cse)
        elif cse:
            Vhd_ee = self._cse_expression(Vhd_ee)

        self.Vbd_ee = Vbd_ee
        self.Vhd_ee = Vhd_ee

        # Body Jacobian time derivative

        # For the last moving body
        Jb_dot = Jdot[-6:, :]
        self.Jb_dot = Jb_dot

        # For the EE
        Jb_ee_dot = SE3AdjMatrix(SE3Inv(self.ee))*Jb_dot
        if simplify:
            Jb_ee_dot = self.simplify(Jb_ee_dot, cse)
        elif cse:
            Jb_ee_dot = self._cse_expression(Jb_ee_dot)
        self.Jb_ee_dot = Jb_ee_dot

        # Hybrid Jacobian time derivative
        # For the last moving body
        Jh_dot = SE3AdjMatrix(R_BFn)*Jb_dot + SE3adMatrix(
            Matrix(Vh_BFn[:3, :]).col_join(Matrix([0, 0, 0])))*\
                SE3AdjMatrix(R_BFn)*Jb
        if simplify:
            Jh_dot = self.simplify(Jh_dot, cse)
        elif cse:
            Jh_dot = self._cse_expression(Jh_dot)
        self.Jh_dot = Jh_dot

        # For the EE
        Jh_ee_dot = SE3AdjMatrix(R_i)*Jb_ee_dot + SE3adMatrix(
            Matrix(Vh_ee[:3, :]).col_join(Matrix([0, 0, 0])))*\
                SE3AdjMatrix(R_i)*Jb_ee
        if simplify:
            Jh_ee_dot = self.simplify(Jh_ee_dot, cse)
        elif cse:
            Jh_ee_dot = self._cse_expression(Jh_ee_dot)
        self.Jh_ee_dot = Jh_ee_dot

        for e in self._get_expressions():
            self.all_symbols.update(e.free_symbols)

        print(&#34;Done&#34;)
        return fkin

    def _closed_form_inv_dyn_body_fixed(self, q: MutableDenseMatrix, 
                                        qd: MutableDenseMatrix, 
                                        q2d: MutableDenseMatrix, 
                                        WEE: MutableDenseMatrix=zeros(6, 1), 
                                        simplify: bool=True, 
                                        cse: bool=False) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Inverse dynamics using body fixed representation of the 
        twists in closed form. 

        The following expressions are saved in the class and can be code 
        generated afterwards:
            coriolis_centrifugal_matrix
            generalized_mass_inertia_matrix
            gravity_vector
            inverse_dynamics

        Args:
            q (sympy.Matrix): (n,1) Generalized position vector.
            qd (sympy.Matrix): (n,1 )Generalized velocity vector.
            q2d (sympy.Matrix): (n,1) Generalized acceleration vector.
            WEE (sympy.Matrix, optional): 
                (6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time 
                varying wrench on the EE link. Defaults to zeros(6, 1).
            simplify (bool, optional): Use simplify command 
                on saved expressions. Defaults to True.
            cse (bool, optional): Use common subexpression 
                elimination. Defaults to False.

        Returns:
            sympy.Matrix: Generalized forces
        &#34;&#34;&#34;
        print(&#34;Inverse dynamics calculation&#34;)

        self.var_syms.update(q.free_symbols)
        self.var_syms.update(qd.free_symbols)
        self.var_syms.update(q2d.free_symbols)
        self.optional_var_syms.update(WEE.free_symbols)

        self.n = len(q)

        # calc Forward kinematics
        if self.parent and self.support:
            FK_C, A = self._calc_A_matrix_tree(q)
        else:    
            FK_C, A = self._calc_A_matrix(q)
        
        if self.J is not None:
            J = self.J  # system level Jacobian
            V = self._V  # system twist
        else:
            # Block diagonal matrix X (6n x n) of the screw coordinate 
            # vector associated to all joints in the body frame (constant)
            X = zeros(6*self.n, self.n)
            for i in range(self.n):
                X[6*i:6*i+6, i] = self.X[i]

            # System level Jacobian
            J = A*X
            if simplify:
                J = self.simplify(J, cse)
            elif cse:
                J = self._cse_expression(J)
            self.J = J

            # System twist (6n x 1)
            V = J*qd
            self._V = V

        # Acceleration computations
        if self._a is not None:
            a = self._a
        else:
            # Block diagonal matrix a (6n x 6n)
            a = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                a[6*i:6*i+6, 6*i:6*i+6] = SE3adMatrix(self.X[i])*qd[i]
            self._a = a

        # System acceleration (6n x 1)
        Vd = J*q2d - A*a*V

        # Block Diagonal Mb (6n x 6n) Mass inertia matrix in body frame 
        # (constant)
        Mb = zeros(6*self.n, 6*self.n)
        for i in range(self.n):
            Mb[i*6:i*6+6, i*6:i*6+6] = self.Mb[i]

        # Block diagonal matrix b (6n x 6n) used in Coriolis matrix
        b = zeros(6*self.n, 6*self.n)
        for i in range(self.n):
            b[i*6:i*6+6, i*6:i*6+6] = SE3adMatrix(Matrix(V[6*i:6*i+6]))

        # Block diagonal matrix Cb (6n x 6n)
        Cb = -Mb*A*a - b.T * Mb

        # Lets setup the Equations of Motion

        # Mass inertia matrix in joint space (n x n)
        M = J.T*Mb*J
        if simplify:
            M = self.simplify(M, cse)
        elif cse:
            M = self._cse_expression(M)

        # Coriolis-Centrifugal matrix in joint space (n x n)
        C = J.T * Cb * J
        if simplify:
            C = self.simplify(C, cse)
        elif cse:
            C = self._cse_expression(C)

        # Gravity Term
        U = SE3AdjInvMatrix(FK_C[0])
        for k in range(1, self.n):
            U = U.col_join(SE3AdjInvMatrix(FK_C[k]))

        Vd_0 = zeros(6, 1)
        Vd_0[3:6, 0] = self.gravity_vector
        Qgrav = J.T*Mb*U*Vd_0
        if simplify:
            Qgrav = self.simplify(Qgrav, cse)
        elif cse:
            Qgrav = self._cse_expression(Qgrav)

        # External Wrench
        Wext = zeros(6*self.n, 1)
        # WEE (t) is the time varying wrench on the EE link.
        Wext[-6:, 0] = WEE
        Qext = J.T * Wext

        # Generalized forces Q
        # Q = M*q2d + C*qd   # without gravity
        Q = M*q2d + C*qd + Qgrav + Qext

        if simplify:
            Q = self.simplify(Q, cse)
        elif cse:
            Q = self._cse_expression(Q)

        self.M = M
        self.C = C
        self.Q = Q
        self.Qgrav = Qgrav

        # save used symbols
        for e in self._get_expressions():
            self.all_symbols.update(e.free_symbols)

        print(&#34;Done&#34;)
        return Q

    def _closed_form_kinematics_body_fixed_parallel(
        self, q: MutableDenseMatrix, qd: MutableDenseMatrix, 
        q2d: MutableDenseMatrix, simplify: bool=True, 
        cse: bool=False) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Position, velocity and acceleration kinematics using 
        body fixed representation of the twists in closed form.

        The following expressions are saved in the class and can be 
        code generated afterwards:
            body_acceleration
            body_acceleration_ee
            body_jacobian_matrix
            body_jacobian_matrix_dot 
            body_jacobian_matrix_ee
            body_jacobian_matrix_ee_dot
            body_twist_ee
            forward_kinematics
            hybrid_acceleration
            hybrid_acceleration_ee
            hybrid_jacobian_matrix
            hybrid_jacobian_matrix_dot
            hybrid_jacobian_matrix_ee
            hybrid_jacobian_matrix_ee_dot
            hybrid_twist_ee

        Args:
            q (sympy.Matrix): 
                (n,1) Generalized position vector.
            qd (sympy.Matrix): 
                (n,1) Generalized velocity vector.
            q2d (sympy.Matrix): 
                (n,1) Generalized acceleration vector.
            simplify (bool, optional): 
                Use simplify command on saved expressions. 
                Defaults to True.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.

        Returns:
            sympy.Matrix: Forward kinematics.
        &#34;&#34;&#34;
        # This method does the same as _closed_form_kinematics_body_fixed.
        # Parallel computation is implemented by writing most values 
        # in queues, organized in a dict.
        # This ensures the correct order for the execution.
        # To understand the calculations it is recommended to read the 
        # code in _closed_form_kinematics_body_fixed since it is more 
        # readable and has the same structure.

        print(&#34;Forward kinematics calculation&#34;)
        self.var_syms.update(q.free_symbols)
        self.var_syms.update(qd.free_symbols)
        self.var_syms.update(q2d.free_symbols)

        self.n = len(q)
        self.queue_dict[&#34;subex_dict&#34;] = Queue()

        # calc Forward kinematics
        if self.parent and self.support:
            FK_C, A = self._calc_A_matrix_tree(q)
        else:    
            FK_C, A = self._calc_A_matrix(q)
        
        self._set_value(&#34;fkin&#34;, FK_C[self.n-1]*self.ee)
        if simplify:
            self._start_simplification_process(&#34;fkin&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;fkin&#34;)


        if self.J is not None:
            self._set_value(&#34;J&#34;, self.J)
            self._set_value(&#34;V&#34;, self._V)
        else:
            # Block diagonal matrix X (6n x n) of the screw coordinate 
            # vector associated to all joints in the body frame (Constant)
            X = zeros(6*self.n, self.n)
            for i in range(self.n):
                X[6*i:6*i+6, i] = self.X[i]

            # System level Jacobian
            self._set_value(&#34;J&#34;, A*X)
            if simplify:
                self._start_simplification_process(&#34;J&#34;, cse)
            elif cse:
                self._start_cse_process(&#34;J&#34;)
            # System twist (6n x 1)
            self._set_value_as_process(&#34;V&#34;, lambda: self._get_value(&#34;J&#34;)*qd)

        # Different Jacobians
        self._set_value_as_process(
            &#34;R_i&#34;, 
            lambda: 
                Matrix(self._get_value(&#34;fkin&#34;)[:3, :3])
                .row_join(zeros(3, 1))
                .col_join(Matrix([0, 0, 0, 1]).T)
            )

        if simplify:  # fastens later simplifications
            self._start_simplification_process(&#34;R_i&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;R_i&#34;)

        self._set_value(&#34;R_BFn&#34;, Matrix(FK_C[-1][:3, :3]).row_join(
            zeros(3, 1)).col_join(Matrix([0, 0, 0, 1]).T))

        # Body fixed Jacobian of last moving body 
        # (This may not correspond to end-effector frame)
        self._set_value_as_process(&#34;Jb&#34;, lambda: self._get_value(&#34;J&#34;)[-6:, :])
        if simplify:
            self._start_simplification_process(&#34;Jb&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Jb&#34;)

        self._set_value_as_process(&#34;Vb_BFn&#34;, lambda: self._get_value(&#34;Jb&#34;)*qd)
        # Body fixed twist of last moving body
        if simplify:
            self._start_simplification_process(&#34;Vb_BFn&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Vb_BFn&#34;)

        self._set_value_as_process(&#34;Vh_BFn&#34;, lambda: SE3AdjMatrix(
            self._get_value(&#34;R_BFn&#34;))*self._get_value(&#34;Vb_BFn&#34;))
        if simplify:
            self._start_simplification_process(&#34;Vh_BFn&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Vh_BFn&#34;)

        # Body fixed twist of end-effector frame
        self._set_value_as_process(&#34;Vb_ee&#34;, lambda: SE3AdjMatrix(
            SE3Inv(self.ee))*self._get_value(&#34;Vb_BFn&#34;))
        if simplify:
            self._start_simplification_process(&#34;Vb_ee&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Vb_ee&#34;)
        # Hybrid twist of end-effector frame
        self._set_value_as_process(&#34;Vh_ee&#34;, lambda: SE3AdjMatrix(
            self._get_value(&#34;R_i&#34;))*self._get_value(&#34;Vb_ee&#34;))
        if simplify:
            self._start_simplification_process(&#34;Vh_ee&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Vh_ee&#34;)

        # Body fixed Jacobian of end-effector frame
        self._set_value_as_process(&#34;Jb_ee&#34;, lambda: SE3AdjMatrix(
            SE3Inv(self.ee))*self._get_value(&#34;Jb&#34;))
        if simplify:
            self._start_simplification_process(&#34;Jb_ee&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Jb_ee&#34;)

        # Hybrid Jacobian of end-effector frame
        self._set_value_as_process(&#34;Jh_ee&#34;, lambda: SE3AdjMatrix(
            self._get_value(&#34;R_i&#34;))*self._get_value(&#34;Jb_ee&#34;))
        # Hybrid Jacobian of last moving body
        self._set_value_as_process(&#34;Jh&#34;, lambda: SE3AdjMatrix(
            self._get_value(&#34;R_i&#34;))*self._get_value(&#34;Jb&#34;))

        if simplify:
            self._start_simplification_process(&#34;Jh_ee&#34;, cse)
            self._start_simplification_process(&#34;Jh&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Jh_ee&#34;)
            self._start_cse_process(&#34;Jh&#34;)

        # Acceleration computations
        if self._a is not None:
            self._set_value(&#34;a&#34;, self._a)
        else:
            # Block diagonal matrix a (6n x 6n)
            a = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                a[6*i:6*i+6, 6*i:6*i+6] = SE3adMatrix(self.X[i])*qd[i]
            self._set_value(&#34;a&#34;, a)
            if simplify:
                self._start_simplification_process(&#34;a&#34;, cse)
            elif cse:
                self._start_cse_process(&#34;a&#34;)

        # System acceleration (6n x 1)
        # System-level Jacobian time derivative
        self._set_value_as_process(
            &#34;Jdot&#34;, lambda: -A*self._get_value(&#34;a&#34;)*self._get_value(&#34;J&#34;))
        if simplify:
            self._start_simplification_process(&#34;Jdot&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Jdot&#34;)

        self._set_value_as_process(&#34;Vbd&#34;, lambda: self._get_value(
            &#34;J&#34;)*q2d - A*self._get_value(&#34;a&#34;)*self._get_value(&#34;V&#34;))

        # Hybrid acceleration of the last body
        self._set_value_as_process(
            &#34;Vbd_BFn&#34;, lambda: self._get_value(&#34;Vbd&#34;)[-6:, :])

        if simplify:
            self._start_simplification_process(&#34;Vbd_BFn&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Vbd_BFn&#34;)

        # Hybrid twist of end-effector frame
        self._set_value_as_process(
            &#34;Vhd_BFn&#34;, 
            lambda: 
                SE3AdjMatrix(self._get_value(&#34;R_BFn&#34;))
                * self._get_value(&#34;Vbd_BFn&#34;) 
                + SE3adMatrix(Matrix(self._get_value(&#34;Vh_BFn&#34;)[:3, :])
                                   .col_join(Matrix([0, 0, 0])))
                * SE3AdjMatrix(self._get_value(&#34;R_BFn&#34;))
                * self._get_value(&#34;Vb_BFn&#34;)
            )

        if simplify:
            self._start_simplification_process(&#34;Vhd_BFn&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Vhd_BFn&#34;)

        # Body fixed twist of end-effector frame
        # Hybrid acceleration of the EE
        self._set_value_as_process(&#34;Vbd_ee&#34;, lambda: SE3AdjMatrix(
            SE3Inv(self.ee))*self._get_value(&#34;Vbd_BFn&#34;))
        if simplify:
            self._start_simplification_process(&#34;Vbd_ee&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Vbd_ee&#34;)
        # Hybrid twist of end-effector frame
        self._set_value_as_process(
            &#34;Vhd_ee&#34;, 
            lambda: 
                SE3AdjMatrix(self._get_value(&#34;R_i&#34;)) 
                * self._get_value(&#34;Vbd_ee&#34;) 
                + SE3adMatrix(Matrix(self._get_value(&#34;Vh_ee&#34;)[:3, :])
                                   .col_join(Matrix([0, 0, 0])))
                * SE3AdjMatrix(self._get_value(&#34;R_i&#34;))
                * self._get_value(&#34;Vb_ee&#34;)
            )  # Hybrid twist of end-effector frame

        if simplify:
            self._start_simplification_process(&#34;Vhd_ee&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Vhd_ee&#34;)

        # Body Jacobian time derivative

        # For the last moving body
        self._set_value_as_process(
            &#34;Jb_dot&#34;, lambda: self._get_value(&#34;Jdot&#34;)[-6:, :])

        # For the EE
        self._set_value_as_process(&#34;Jb_ee_dot&#34;, lambda: SE3AdjMatrix(
            SE3Inv(self.ee))*self._get_value(&#34;Jb_dot&#34;))
        if simplify:
            self._start_simplification_process(&#34;Jb_ee_dot&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Jb_ee_dot&#34;)

        # Hybrid Jacobian time derivative
        # For the last moving body
        self._set_value_as_process(
            &#34;Jh_dot&#34;, 
            lambda: 
                SE3AdjMatrix(self._get_value(&#34;R_BFn&#34;))
                * self._get_value(&#34;Jb_dot&#34;) 
                + SE3adMatrix(Matrix(self._get_value(&#34;Vh_BFn&#34;)[:3, :])
                                   .col_join(Matrix([0, 0, 0])))
                * SE3AdjMatrix(self._get_value(&#34;R_BFn&#34;))
                * self._get_value(&#34;Jb&#34;)
            )
        if simplify:
            self._start_simplification_process(&#34;Jh_dot&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Jh_dot&#34;)

        # For the EE
        self._set_value_as_process(
            &#34;Jh_ee_dot&#34;, 
            lambda: 
                SE3AdjMatrix(self._get_value(&#34;R_i&#34;))
                * self._get_value(&#34;Jb_ee_dot&#34;) 
                + SE3adMatrix(Matrix(self._get_value(&#34;Vh_ee&#34;)[:3, :])
                                   .col_join(Matrix([0, 0, 0])))
                * SE3AdjMatrix(self._get_value(&#34;R_i&#34;))
                * self._get_value(&#34;Jb_ee&#34;)
            )
        if simplify:
            self._start_simplification_process(&#34;Jh_ee_dot&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Jh_ee_dot&#34;)
        self._a = self._get_value(&#34;a&#34;)
        self._V = self._get_value(&#34;V&#34;)

        # variables for Code Generation:
        self.fkin = self._get_value(&#34;fkin&#34;)
        self.J = self._get_value(&#34;J&#34;)
        self.Jb = self._get_value(&#34;Jb&#34;)
        self.Jh = self._get_value(&#34;Jh&#34;)
        self.Jdot = self._get_value(&#34;Jdot&#34;)
        self.Vb_ee = self._get_value(&#34;Vb_ee&#34;)
        self.Vh_ee = self._get_value(&#34;Vh_ee&#34;)
        self.Jb_ee = self._get_value(&#34;Jb_ee&#34;)
        self.Jh_ee = self._get_value(&#34;Jh_ee&#34;)
        self.Vh_BFn = self._get_value(&#34;Vh_BFn&#34;)
        self.Vb_BFn = self._get_value(&#34;Vb_BFn&#34;)
        self.Vhd_BFn = self._get_value(&#34;Vhd_BFn&#34;)
        self.Vbd_BFn = self._get_value(&#34;Vbd_BFn&#34;)
        self.Vhd_ee = self._get_value(&#34;Vhd_ee&#34;)
        self.Vbd_ee = self._get_value(&#34;Vbd_ee&#34;)
        self.Jh_dot = self._get_value(&#34;Jh_dot&#34;)
        self.Jb_dot = self._get_value(&#34;Jb_dot&#34;)
        self.Jh_ee_dot = self._get_value(&#34;Jh_ee_dot&#34;)
        self.Jb_ee_dot = self._get_value(&#34;Jb_ee_dot&#34;)

        try:
            while True:
                self.subex_dict.update(
                    self.queue_dict[&#34;subex_dict&#34;].get(timeout=0.05))
        except queue.Empty:
            pass

        # empty Queues
        for i in self.queue_dict:
            self._flush_queue(self.queue_dict[i])
        self.queue_dict = {}

        # join Processes
        for i in self.process_dict:
            self.process_dict[i].join()
        self.process_dict = {}

        # save used symbols
        for e in self._get_expressions():
            self.all_symbols.update(e.free_symbols)

        print(&#34;Done&#34;)
        return self.fkin

    def _closed_form_inv_dyn_body_fixed_parallel(
        self, q: MutableDenseMatrix, qd: MutableDenseMatrix, 
        q2d: MutableDenseMatrix, WEE: MutableDenseMatrix=zeros(6, 1), 
        simplify: bool=True, cse: bool=False) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Inverse dynamics using body fixed representation of the 
        twists in closed form. 

        The following expressions are saved in the class and can be 
        code generated afterwards:
            coriolis_centrifugal_matrix
            generalized_mass_inertia_matrix
            gravity_vector
            inverse_dynamics

        Args:
            q (sympy.Matrix): 
                (n,1) Generalized position vector.
            qd (sympy.Matrix): 
                (n,1 )Generalized velocity vector.
            q2d (sympy.Matrix): 
                (n,1) Generalized acceleration vector.
            WEE (sympy.Matrix, optional): 
                (6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time varying 
                wrench on the EE link. 
                Defaults to zeros(6, 1).
            simplify (bool, optional): 
                Use simplify command on saved expressions. 
                Defaults to True.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.

        Returns:
            sympy.Matrix: Generalized Forces
        &#34;&#34;&#34;
        # This method does the same as _closed_form_inv_dyn_body_fixed.
        # Parallel computation is implemented by writing most values 
        # in queues, organized in a dict.
        # This ensures the correct order for the execution.
        # To understand the calculations it is recommended to read the 
        # code in _closed_form_inv_dyn_body_fixed since it is more 
        # readable and has the same structure.

        print(&#34;Inverse dynamics calculation&#34;)

        self.var_syms.update(q.free_symbols)
        self.var_syms.update(qd.free_symbols)
        self.var_syms.update(q2d.free_symbols)
        self.optional_var_syms.update(WEE.free_symbols)

        self.n = len(q)
        self.queue_dict[&#34;subex_dict&#34;] = Queue()

        # calc Forward kinematics
        if self.parent and self.support:
            FK_C, A = self._calc_A_matrix_tree(q)
        else:    
            FK_C, A = self._calc_A_matrix(q)
        
        if self.J is not None:
            self._set_value(&#34;J&#34;, self.J)
            self._set_value(&#34;V&#34;, self._V)
        else:
            # Block diagonal matrix X (6n x n) of the screw coordinate 
            # vector associated to all joints in the body frame (Constant)
            X = zeros(6*self.n, self.n)
            for i in range(self.n):
                X[6*i:6*i+6, i] = self.X[i]

            # System level Jacobian
            self._set_value(&#34;J&#34;, A*X)
            if simplify:
                self._start_simplification_process(&#34;J&#34;, cse)
            elif cse:
                self._start_cse_process(&#34;J&#34;)

            # System twist (6n x 1)
            self._set_value_as_process(&#34;V&#34;, lambda: self._get_value(&#34;J&#34;)*qd)

        # Acceleration computations

        if self._a is not None:
            a = self._a
        else:
            # Block diagonal matrix a (6n x 6n)
            a = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                a[6*i:6*i+6, 6*i:6*i+6] = SE3adMatrix(self.X[i])*qd[i]
            self._a = a

        # System acceleration (6n x 1)
        # Vd = J*q2d - A*a*V
        self._set_value_as_process(&#34;Vd&#34;, lambda: self._get_value(
            &#34;J&#34;)*q2d - A*a*self._get_value(&#34;V&#34;))

        # Block Diagonal Mb (6n x 6n) Mass inertia matrix in body frame 
        # (Constant)
        Mb = zeros(6*self.n, 6*self.n)
        for i in range(self.n):
            Mb[i*6:i*6+6, i*6:i*6+6] = self.Mb[i]

        # Block diagonal matrix b (6n x 6n) used in Coriolis matrix
        def _b():
            nonlocal self
            b = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                b[i*6:i*6+6, i*6:i*6 + 6] = SE3adMatrix(
                    Matrix(self._get_value(&#34;V&#34;)[6*i:6*i+6]))
            return b
        self._set_value_as_process(&#34;b&#34;, _b)

        # Block diagonal matrix Cb (6n x 6n)
        self._set_value_as_process(
            &#34;Cb&#34;, lambda: -Mb*A*a - self._get_value(&#34;b&#34;).T * Mb)

        # Lets setup the Equations of Motion

        # Mass inertia matrix in joint space (n x n)
        self._set_value_as_process(
            &#34;M&#34;, lambda: self._get_value(&#34;J&#34;).T*Mb*self._get_value(&#34;J&#34;))
        if simplify:
            self._start_simplification_process(&#34;M&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;M&#34;)

        # Coriolis-Centrifugal matrix in joint space (n x n)
        self._set_value_as_process(&#34;C&#34;, lambda: self._get_value(
            &#34;J&#34;).T*self._get_value(&#34;Cb&#34;)*self._get_value(&#34;J&#34;))
        if simplify:
            self._start_simplification_process(&#34;C&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;C&#34;)

        # Gravity Term
        U = SE3AdjInvMatrix(FK_C[0])
        for k in range(1, self.n):
            U = U.col_join(SE3AdjInvMatrix(FK_C[k]))

        Vd_0 = zeros(6, 1)
        Vd_0[3:6, 0] = self.gravity_vector
        self._set_value_as_process(
            &#34;Qgrav&#34;, lambda: self._get_value(&#34;J&#34;).T*Mb*U*Vd_0)
        if simplify:
            self._start_simplification_process(&#34;Qgrav&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Qgrav&#34;)

        # External Wrench
        Wext = zeros(6*self.n, 1)
        # WEE (t) is the time varying wrench on the EE link.
        Wext[-6:, 0] = WEE
        self._set_value_as_process(
            &#34;Qext&#34;, lambda: self._get_value(&#34;J&#34;).T * Wext)

        # Generalized forces Q
        self._set_value_as_process(
            &#34;Q&#34;, 
            lambda: 
                self._get_value(&#34;M&#34;) * q2d 
                + self._get_value(&#34;C&#34;) * qd 
                + self._get_value(&#34;Qgrav&#34;) 
                + self._get_value(&#34;Qext&#34;)
            )

        if simplify:
            self._start_simplification_process(&#34;Q&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Q&#34;)

        self._V = self._get_value(&#34;V&#34;)
        self.J = self._get_value(&#34;J&#34;)
        self.M = self._get_value(&#34;M&#34;)
        self.C = self._get_value(&#34;C&#34;)
        self.Qgrav = self._get_value(&#34;Qgrav&#34;)
        self.Q = self._get_value(&#34;Q&#34;)

        try:
            while True:
                self.subex_dict.update(
                    self.queue_dict[&#34;subex_dict&#34;].get(timeout=0.05))
        except queue.Empty:
            pass

        # empty Queues
        for i in self.queue_dict:
            self._flush_queue(self.queue_dict[i])
        self.queue_dict = {}

        # join Processes
        for i in self.process_dict:
            self.process_dict[i].join()
        self.process_dict = {}

        # save used symbols
        for e in self._get_expressions():
            self.all_symbols.update(e.free_symbols)

        print(&#34;Done&#34;)
        return self.Q

    def partial_factor(self, exp: sympy.Expr) -&gt; sympy.Expr:
        &#34;&#34;&#34;Partial factor simplification for sympy expression.

        Args:
            exp (sympy.Expr): sympy expression.

        Returns:
            sympy.Expr: modified sympy expression.
        &#34;&#34;&#34;
        # split up matrices
        if (type(exp) == sympy.matrices.immutable.ImmutableDenseMatrix
            or type(exp) == sympy.matrices.dense.MutableDenseMatrix):
            new_expr = zeros(*exp.shape)
            for i in range(exp.shape[0]):
                for j in range(exp.shape[1]):
                    new_expr[i,j] = self.partial_factor(exp[i,j])
            return new_expr
            
        # seach for factors
        factor_map = defaultdict(set)
        const, additive_terms = exp.as_coeff_add()
        for term1, term2 in combinations(additive_terms, 2):
            common_terms = (
                set(term1.as_coeff_mul()[-1])
                &amp; set(term2.as_coeff_mul()[-1])
            )
            if common_terms:
                common_factor = sympy.Mul(*common_terms)
                factor_map[common_factor] |= {term1, term2}
        
        # sort by number of operations represented by the terms
        factor_list = sorted(
            factor_map.items(),
            key = lambda i: (i[0].count_ops() + 1) * len(i[1])
        )[::-1]

        # rebuild expression
        used = set()
        new_expr = nsimplify(0)
        for item in factor_list:
            factor = item[0]
            appearances = item[-1]
            terms = 0
            for instance in appearances:
                if instance not in used:
                    terms += instance.as_coefficient(factor)
                    used.add(instance)
            new_expr += factor * terms
        for term in set(additive_terms) - used:
            new_expr += term
        return new_expr + const

    def simplify(self, exp: sympy.Expr, cse: bool=False) -&gt; sympy.Expr:
        &#34;&#34;&#34;Faster simplify implementation for sympy expressions.
        Expressions can be different simplified as with sympy.simplify.

        Args:
            exp (sympy expression): 
                Expression to simplify.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.

        Returns:
            sympy expression: Simplified expression.
        &#34;&#34;&#34;
        if cse:
            exp = self._cse_expression(exp)
        if (type(exp) == sympy.matrices.immutable.ImmutableDenseMatrix
                or type(exp) == sympy.matrices.dense.MutableDenseMatrix):
            # fasten simplification of symmetric matrices
            if exp.is_square:
                # test if matrix is symmetric
                # numeric test is faster than is_symmetric method  for 
                # long expressions
                
                # create matrix with randon values
                num = lambdify(list(exp.free_symbols), exp, &#34;numpy&#34;)(
                    *(random.random() for i in exp.free_symbols))
                # if (random) matrix is symmetric, we have to simplify 
                # less values
                if numpy.allclose(num, num.T):
                    shape = exp.shape
                    m_exp = exp.as_mutable()
                    # simplify values only once in symmetric matrices
                    for i in range(shape[0]):
                        for j in range(i):
                            m_exp[i, j] = self.simplify(exp[i, j])
                            if i != j:
                                m_exp[j, i] = exp[j, i]
                    return Matrix(m_exp)
        if type(exp) == sympy.matrices.dense.MutableDenseMatrix:
            exp = exp.as_immutable()
        exp = fu(exp)  # fast function to simplify sin and cos expressions
        exp = cancel(exp)
        exp = factor(exp)
        exp = powsimp(exp)
        exp = self.partial_factor(exp)
        exp = exp.doit()
        return exp

    def _create_topology_lists(self,robot: URDF) -&gt; None:
        &#34;&#34;&#34;Generate parent, support and child list from URDF.

        Args:
            robot (URDF): URDF of robot.
        &#34;&#34;&#34;
        # names of all links in urdf
        link_names = [link.name for link in robot.links] 
        parent_names = [] # names of parent links corresponding link_names
        connection_type = [] # 0 for fixed, None for base, 1 else
        body_index = [] # index of link; -1 for fixed links
        parent = [] # parent array
        child = [] # child array
        support = [] # support array
        # find parent link names and search for fixed joints
        for name in link_names:
            for joint in robot.joints:
                if joint.child == name:
                    parent_names.append(joint.parent)
                    body_index.append(None) # specify later
                    if joint.joint_type == &#34;fixed&#34;:
                        connection_type.append(0)
                    else:
                        connection_type.append(1)
                    break
            else: # base link
                parent_names.append(None)
                connection_type.append(None)
                body_index.append(0)

        # generate body indices concatenating fixed bodies
        while None in body_index:
            i1 = body_index.index(None) # i of current link
            # update until parent is already specified
            while body_index[link_names.index(parent_names[i1])] is None:
                i1 = link_names.index(parent_names[i1])
            # fixed links get index -1
            if connection_type[i1] == 0:
                body_index[i1] = -1
                continue
            i2 = link_names.index(parent_names[i1]) # i of parent link
            while body_index[i2] == -1: # find forst non fixed parent
                i2 = link_names.index(parent_names[i2])
            index = body_index[i2]+1 # body index
            while index in body_index: # find first unused index
                index+=1
            body_index[i1] = index
            
        parent = [None for _ in range(max(body_index))] 
        child = [[] for _ in range(max(body_index))]
        support = [[] for _ in range(max(body_index))]

        # fill parent, child and support array
        for i in range(len(body_index)):
            idx = body_index[i] # get index of current body
            if idx &lt;= 0: # ignore base and fixed bodys
                continue
            i1 = link_names.index(parent_names[i]) # parent index
            while body_index[i1] == -1: # find first non fixed parent
                i1 = link_names.index(parent_names[i1])
            parent[idx-1] = body_index[i1] # save parent index
            if body_index[i1] &gt; 0: # ignore base
                child[body_index[i1]-1].append(idx) # save child to parent
            i2 = i
            while body_index[i2] != 0: # save all indices in support path
                if  body_index[i2] &gt; 0: # ignore fixed links
                    support[idx-1].append(body_index[i2])
                i2 = link_names.index(parent_names[i2])
            support[idx-1].reverse()
        self.support = support
        self.child = child
        self.parent = parent
            
    def _nsimplify(
        self,num: float, *args, max_denominator: int=0, **kwargs
        ) -&gt; Union[sympy.Expr, float]:
        &#34;&#34;&#34;Find a simple sympy representation for a number like 1/2 
        instead of 0.5. This function extends sympy.nsimplify with a 
        parameter to specify a maximum denominator to avoid simplifications
        like 13/157.  

        Args:
            num (float): number to simplify.
            max_denominator (int, optional): 
                maximum denominator to use. Use 0 to deactivate. 
                Defaults to 0.

        Returns:
            Union[sympy.Expr, float]: simplified number.
        &#34;&#34;&#34;
        ex = nsimplify(num,*args,**kwargs)
        if not max_denominator:
            return ex
        if ex.is_rational:
            try:
                d = ex.denominator
                if d &gt; max_denominator:
                    return num
            except ValueError:
                return ex
        elif type(ex) in {sympy.core.add.Add, sympy.core.power.Pow}:
            return num
        for i in regex.findall(&#34;(?&lt;=Rational\(\d*, )\d*&#34;, sympy.srepr(ex)):
            if abs(int(i)) &gt; max_denominator:
                return num
        return ex
        
    def load_from_urdf(self, path: str, symbolic: bool=True, 
                       cse: bool=False, simplify_numbers: bool=True,  
                       tolerance: float=0.0001, max_denominator: int=9) -&gt; None:
        &#34;&#34;&#34;Load robot from urdf.

        Args:
            path (str): path to URDF.
            symbolic (bool, optional): 
                generate symbols for numeric values. 
                Defaults to True.
            cse (bool, optional): 
                use common subexpression elimination. Defaults to False.
            simplify_numbers (bool, optional): 
                Use eg. pi/2 instead of 1.5708. Defaults to True.
            tolerance (float, optional): 
                tolerance for simplify_numbers. Defaults to 0.0001.
            max_denominator (int, optional): 
                Maximum denominator to use for simplify numbers to avoid
                values like 13/153. Use 0 to deactivate. Defaults to 9.

        Raises:
            NotImplementedError: supports only the joint types 
                &#34;revolute&#34;, &#34;continuous&#34; and &#34;prismatic&#34;.
        &#34;&#34;&#34;        
        with open(path, &#34;r&#34;) as f:
            robot = URDF.from_xml_string(f.read())
        self.B = []
        self.X = []
        self._create_topology_lists(robot) # TODO: check!
        fixed_origin = None
        fixed_links = []
        DOF = 0
        xyz_rpy_syms = []
        for joint in robot.joints:
            if joint.joint_type in [&#34;revolute&#34;, &#34;continuous&#34;, &#34;prismatic&#34;]:
                DOF += 1
            elif joint.joint_type in [&#34;fixed&#34;]:
                pass
            else:
                raise NotImplementedError(
                    &#34;Joint type &#39;&#34; + joint.joint_type+&#34;&#39; not implemented yet!&#34;)

        ji = 0  # joint index of used joints
        jia = 0  # joint index of all joints (fixed included)
        joint_origins = []
        for joint in robot.joints:
            name = joint.name
            origin = xyz_rpy_to_matrix(joint.origin.xyz+joint.origin.rpy)
            if symbolic:
                xyz_rpy = Matrix(joint.origin.xyz+joint.origin.rpy)
                xyz_rpy_syms.append(symbols(
                    &#34; &#34;.join([name+&#34;_%s&#34; % s for s in [&#34;x&#34;, &#34;y&#34;, &#34;z&#34;, &#34;roll&#34;, &#34;pitch&#34;, &#34;yar&#34;]])))
                xyzrpylist = []
                if simplify_numbers:
                    for i in range(6):
                        if (self._nsimplify(xyz_rpy[i], 
                                           tolerance=tolerance, 
                                           max_denominator=max_denominator) 
                            in [0, -1, 1, pi, -pi, pi/2, -pi/2, 3*pi/2, -3*pi/2]
                            ):
                            xyzrpylist.append(
                                self._nsimplify(xyz_rpy[i], tolerance=tolerance,
                                                max_denominator=max_denominator))
                        else:
                            xyzrpylist.append(xyz_rpy_syms[jia][i])
                            self.assignment_dict[xyz_rpy_syms[jia]
                                                 [i]] = xyz_rpy[i]
                else:
                    for i in range(6):
                        if xyz_rpy[i] == 0:
                            xyzrpylist.append(0)
                        elif xyz_rpy[i] == 1:
                            xyzrpylist.append(1)
                        elif xyz_rpy[i] == -1:
                            xyzrpylist.append(-1)
                        else:
                            xyzrpylist.append(xyz_rpy_syms[jia][i])
                            self.assignment_dict[xyz_rpy_syms[jia]
                                                 [i]] = xyz_rpy[i]
                origin = xyz_rpy_to_matrix(xyzrpylist)
                if cse:
                    origin = self._cse_expression(origin)
            elif simplify_numbers:
                for i in range(4):
                    for j in range(4):
                        origin[i, j] = self._nsimplify(
                            origin[i, j], [pi], tolerance=tolerance,
                            max_denominator=max_denominator)
            joint_origins.append(origin)
            if joint.joint_type in [&#34;revolute&#34;, &#34;continuous&#34;, &#34;prismatic&#34;]:
                axis = Matrix(joint.axis)
                if simplify_numbers:
                    for i in range(3):
                        axis[i] = self._nsimplify(axis[i], [pi], tolerance=tolerance,
                                            max_denominator=max_denominator)
                if fixed_origin:
                    origin *= fixed_origin
                    fixed_origin = None
                self.B.append(Matrix(origin))

                if joint.joint_type in [&#34;revolute&#34;, &#34;continuous&#34;]:
                    self.X.append(Matrix(axis).col_join(Matrix([0, 0, 0])))
                else:
                    self.X.append(Matrix(Matrix([0, 0, 0])).col_join(axis))
                ji += 1
            elif joint.joint_type == &#34;fixed&#34;:
                if fixed_origin:
                    fixed_origin *= origin
                else:
                    fixed_origin = origin
                fixed_links.append((joint.parent, joint.child))
            jia += 1

        self.Mb = []
        i = 0
        first_non_fixed = 1
        for link in robot.links:
            name = link.name
            # ignore base link
            if i &lt; first_non_fixed:
                if name in [x[1] for x in fixed_links]:
                    first_non_fixed += 1
                i += 1
                continue
            inertia = Matrix(link.inertial.inertia.to_matrix())
            mass = link.inertial.mass
            inertiaorigin = xyz_rpy_to_matrix(link.inertial.origin.xyz+link.inertial.origin.rpy)
            if symbolic:
                I_syms = symbols(&#34;Ixx_%s Ixy_%s Ixz_%s Iyy_%s Iyz_%s Izz_%s&#34; % (
                    name, name, name, name, name, name))
                c_syms = symbols(&#34;cx_%s cy_%s cz_%s&#34; % (name, name, name))
                I = inertia_matrix(*I_syms)
                m = symbols(&#34;m_%s&#34; % name)
                cg = Matrix([*c_syms])
            else:
                if simplify_numbers:
                    for i in range(4):
                        for j in range(4):
                            inertiaorigin[i, j] = self._nsimplify(
                                inertiaorigin[i, j], [pi], tolerance=tolerance,
                                max_denominator=max_denominator)
                    for i in range(3):
                        for j in range(3):
                            inertia[i, j] = self._nsimplify(
                                inertia[i, j], [pi], tolerance=tolerance,
                                max_denominator=max_denominator)
                I = Matrix(inertia)
                m = mass
                cg = Matrix(inertiaorigin[0:3, 3])
            M = mass_matrix_mixed_data(m, I, cg)
            if name in [x[1] for x in fixed_links]:
                j = i
                # transform Mass matrix
                while robot.links[j].name in [x[1] for x in fixed_links]:
                    M = SE3AdjInvMatrix(
                        joint_origins[j-1]).T * M * SE3AdjInvMatrix(joint_origins[j-1])
                    j -= 1
                self.Mb[-1] += M
                i += 1
                continue
            self.Mb.append(M)
            i += 1
        return

    def dh_to_screw_coord(self, DH_param_table: MutableDenseMatrix) -&gt; None:
        &#34;&#34;&#34;Build screw coordinate paramters (joint axis frames and 
        body reference frames) from a given modified Denavit-Hartenberg 
        (DH) parameter table.
        Joint screw coordinates and reference configurations of bodies 
        are directly applied to class.

        Args:
            DH_param_table (array_like): 
                Table with modified DH parameters (n,5) 
                -&gt; (gamma,alpha,d,theta,r)
        &#34;&#34;&#34;
        number_of_frames = DH_param_table.shape[0]
        self.B = []
        self.X = []
        for i in range(number_of_frames):
            # Reference configurations of bodies (i.e. of body-fixed 
            # reference frames) w.r.t their previous bodies
            # gamma, alpha, d, theta,r
            frame = DH_param_table[i, :]
            gamma = frame[0]
            alpha = frame[1]
            d = frame[2]
            theta = frame[3]
            r = frame[4]
            self.B.append(SO3Exp(Matrix([1, 0, 0]), alpha)
                          .row_join(Matrix([d, 0, 0]))
                          .col_join(Matrix([0, 0, 0, 1]).T)
                          * SO3Exp(Matrix([0, 0, 1]), theta)
                          .row_join(Matrix([0, 0, r]))
                          .col_join(Matrix([0, 0, 0, 1]).T)
                          )

            #  Joint screw coordinates in body-fixed representation
            if gamma == 0:
                self.X.append(Matrix([0, 0, 1, 0, 0, 0]))
            else:
                self.X.append(Matrix([0, 0, 0, 0, 0, 1]))

    def _set_value_as_process(self, name: str, target: Callable) -&gt; None:
        &#34;&#34;&#34;Set return value of target as value to queue in 
        self.queue_dict with identifier name.

        Args:
            name (str): Identifier.
            target (function): function, which returns value. 
        &#34;&#34;&#34;
        if name not in self.queue_dict:
            self.queue_dict[name] = Queue()
        if name in self.process_dict:
            print(&#34;already there&#34;)
        self.process_dict[name] = Process(
            target=lambda: self._set_value(name, target()), args=(), name=name)
        self.process_dict[name].start()

    def _set_value(self, name: str, var: Any) -&gt; None:
        &#34;&#34;&#34;Set value to queue in self.queue_dict.

        Args:
            name (str): Identifier.
            var (any): Value to save.
        &#34;&#34;&#34;
        if name not in self.queue_dict:
            self.queue_dict[name] = Queue()
        self.queue_dict[name].put(var)

    def _start_simplification_process(
        self, name: str, cse: bool=False) -&gt; None:
        &#34;&#34;&#34;Start Process, which simplifies and overwrites value in 
        queue from self.queue_dict.

        Args:
            name (str): Identifier
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.
        &#34;&#34;&#34;
        if name not in self.queue_dict:
            self.queue_dict[name] = Queue()
        self.process_dict[name+&#34;_simplify&#34;] = Process(
            target=self._simplify_parallel, 
            args=(name, cse,), 
            name=name+&#34;_simplify&#34;)
        self.process_dict[name+&#34;_simplify&#34;].start()

    def _start_cse_process(self, name: str) -&gt; None:
        &#34;&#34;&#34;Start Process, which generates cse expression and overwrites value in 
        queue from self.queue_dict.

        Args:
            name (str): Identifier
        &#34;&#34;&#34;
        if name not in self.queue_dict:
            self.queue_dict[name] = Queue()
        self.process_dict[name+&#34;_cse&#34;] = Process(
            target=self._cse_parallel, 
            args=(name,), 
            name=name+&#34;_cse&#34;)
        self.process_dict[name+&#34;_cse&#34;].start()

    def _get_value(self, name: str) -&gt; Any:
        &#34;&#34;&#34;Get value from queue in self.queue_dict and put it in again.

        Args:
            name (str): Identifier.

        Returns:
            any: Value
        &#34;&#34;&#34;
        value = self.queue_dict[name].get()
        self.queue_dict[name].put(value)
        return value

    def _simplify_parallel(self, name: str, cse: bool=False) -&gt; None:
        &#34;&#34;&#34;Take value from self.queue_dict, simplify it and put it in 
        again.

        Args:
            name (str): Identifier
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.
        &#34;&#34;&#34;
        value = self.simplify(self.queue_dict[name].get(), cse)
        self.queue_dict[name].put(value)
        
    def _cse_parallel(self, name: str) -&gt; None:
        &#34;&#34;&#34;Take value from self.queue_dict, generate cse_expressions and 
        put it in again.

        Args:
            name (str): Identifier
        &#34;&#34;&#34;
        value = self._cse_expression(self.queue_dict[name].get())
        self.queue_dict[name].put(value)

    def _flush_queue(self, q: Queue) -&gt; None:
        &#34;&#34;&#34;Flush all items in queue

        Args:
            q (Queue): Queue to flush
        &#34;&#34;&#34;
        try:
            while True:
                q.get(block=False)
        except queue.Empty:
            pass

    def _individual_numbered_symbols(
        self, exclude: list=[], i: List[int]=[0]) -&gt; Generator[sympy.Symbol, None, None]:
        &#34;&#34;&#34;create individual symbol names for subexpressions using 
        multiprocessing.

        Args:
            exclude (list, optional): 
                List of names, which should not be used. Defaults to [].
            i (list, optional): 
                List with starting value -1 as first value. Is used as 
                counter and should not be set. Defaults to [0].

        Returns:
            sympy.numbered_symbols:  Symbols
        &#34;&#34;&#34;
        i[0] += 1
        prefix=&#34;sub%s_%s_&#34; % (
            &#34;_&#34;.join([str(j) for j in multiprocessing.current_process()._identity]), 
            i[0]
            )
        prefix = prefix.replace(&#34;sub_&#34;,&#34;sub0_&#34;)
        return numbered_symbols(
            prefix=prefix, 
            exclude=exclude)

    def _sort_variables(self, vars:List[sympy.Symbol]) -&gt; List[sympy.Symbol]:
        &#34;&#34;&#34;Sort variables for code generation starting with q, qd, qdd, 
        continuing with variable symbols and ending with constant 
        symbols.

        Args:
            vars (list of sympy.symbols): Variables to sort.

        Returns:
            list: Sorted list of variables.
        &#34;&#34;&#34;
        # vars as set
        vars = set(vars)
        # divide into variable and constant symbols
        var_syms = self.var_syms.intersection(vars)
        optional_var_syms = self.optional_var_syms.intersection(vars)
        rest = list(vars.difference(var_syms).difference(optional_var_syms))
        # divide variable symbols into q, dq, ddq and other variable symbols
        q = []
        dq = []
        ddq = []
        var_rest = []
        opt_var = []
        for i in var_syms:
            if str(i).startswith(&#34;ddq&#34;):
                ddq.append(i)
            elif str(i).startswith(&#34;dq&#34;):
                dq.append(i)
            elif str(i).startswith(&#34;q&#34;):
                q.append(i)
            else:
                var_rest.append(i)
                
        for i in optional_var_syms:  
            opt_var.append(i)
            
        def symsort(data: List[sympy.Symbol]) -&gt; List[sympy.Symbol]:
            &#34;&#34;&#34;Sort symbols

            Args:
                data (list): symbols

            Returns:
                list: sorted symbols
            &#34;&#34;&#34;
            return [x for _, x in sorted(zip(list(map(str, data)), data))]
        
        # return sorted list
        return (symsort(q) 
                + symsort(dq) 
                + symsort(ddq) 
                + symsort(var_rest) 
                + symsort(opt_var) 
                + symsort(rest))

    def _cse_expression(self, exp: sympy.Expr) -&gt; sympy.Expr:
        &#34;&#34;&#34;Use common subexpression elimination to shorten expression.
        The used subexpressions are saved to the class internal 
        subex_dict.

        Args:
            exp (Sympy expression): Expression to shorten using cse.

        Returns:
            Sympy expression: Shortened expression.
        &#34;&#34;&#34;
        # cse expression
        r, e = sympy.cse([exp, exp], self._individual_numbered_symbols(
            exclude=self.all_symbols), order=&#34;canonical&#34;, ignore=self.var_syms)
        # add subexpressions to dict
        for (sym, val) in r:
            self.subex_dict[sym] = val
            # for multiprocessing save in queue
            try:
                self.queue_dict[&#34;subex_dict&#34;].put(self.subex_dict)
            except:
                pass
            # update used symbols
            self.all_symbols.update({sym})
        return e[0]

    def _get_expressions(self) -&gt; List[sympy.Expr]:
        &#34;&#34;&#34;Get list of all generated expressions.

        Returns:
            list: generated expressions.
        &#34;&#34;&#34;
        expression_dict = self.get_expressions_dict()
        expressions = [expression_dict[i] for i in expression_dict]
        return expressions

    def _calc_A_matrix(
        self, q: MutableDenseMatrix
        ) -&gt; Tuple[List[MutableDenseMatrix], MutableDenseMatrix]:
        &#34;&#34;&#34;Calculate forward kinematics and the block diagonal matrix 
        A (6n x 6n) of the Adjoint of body frame for serial robots.

        Args:
            q (sympy.MutableDenseMatrix): 
                Generalized position vector.

        Raises:
            ValueError: 
                Joint screw coordinates or body reference configuration 
                not found.

        Returns:
            Tuple[List[MutableDenseMatrix], MutableDenseMatrix]: (FK, A)
        &#34;&#34;&#34;
        # calc Forward kinematics
        if self._FK_C is not None:
            FK_C = self._FK_C
        elif self.A:
            # print(&#34;Using absolute configuration (A) of the body frames&#34;)
            FK_f = [SE3Exp(self.Y[0], q[0])]
            FK_C = [FK_f[0]*self.A[0]]
            for i in range(1, self.n):
                FK_f.append(FK_f[i-1]*SE3Exp(self.Y[i], q[i]))
                FK_C.append(FK_f[i]*self.A[i])
            self._FK_C = FK_C
            if not self.X:
                # Joint screw coordinates in body-fixed representation 
                # computed from screw coordinates in IFR
                self.X = [SE3AdjInvMatrix(
                    self.A[i])*self.Y[i] for i in range(self.n)]

        elif self.B:
            # print(&#39;Using relative configuration (B) of the body frames&#39;)
            FK_C = [self.B[0]*SE3Exp(self.X[0], q[0])]
            for i in range(1, self.n):
                FK_C.append(FK_C[i-1]*self.B[i]*SE3Exp(self.X[i], q[i]))
            self._FK_C = FK_C
        else:
            # &#39;Absolute (A) or Relative (B) configuration of the bodies should be provided in class!&#39;
            raise ValueError(&#34;Joint screw coordinates and/or reference configuration of bodies not set.&#34;)

        # Block diagonal matrix A (6n x 6n) of the Adjoint of body frame
        if self._A is not None:
            A = self._A
        else:
            A = Matrix(Identity(6*self.n))
            for i in range(self.n):
                for j in range(i):
                    Crel = SE3Inv(FK_C[i])*FK_C[j]
                    AdCrel = SE3AdjMatrix(Crel)
                    r = 6*(i)
                    c = 6*(j)
                    A[r:r+6, c:c+6] = AdCrel
            self._A = A
        return FK_C, A

    def _calc_A_matrix_tree(self, q: MutableDenseMatrix):
        &#34;&#34;&#34;Calculate forward kinematics and the block diagonal matrix 
        A (6n x 6n) of the Adjoint of body frame for tree like robot 
        structures.

        Args:
            q (sympy.MutableDenseMatrix): 
                Generalized position vector.

        Raises:
            ValueError: 
                Joint screw coordinates or body reference configuration 
                not found.

        Returns:
            Tuple[List[MutableDenseMatrix], MutableDenseMatrix]: (FK, A)
        &#34;&#34;&#34;
        if self._FK_C is not None:
            FK_C = self._FK_C
        elif self.A:
            # print(&#34;Using absolute configuration (A) of the body frames&#34;)
            FK_f = []
            FK_C = []
            for i in range(self.n):
                if self.parent[i] == 0: # bodies with no predecessor
                    # Initialization for the first body
                    FK_f.append(SE3Exp(self.Y[i], q[i]))
                    FK_C.append(FK_f[i]*self.A[i])
                else:
                    FK_f.append(FK_f[self.parent[i]-1]*SE3Exp(self.Y[i], q[i]))
                    FK_C.append(FK_f[i]*self.A[i])      
            self._FK_C = FK_C
            if not self.X:
                # Joint screw coordinates in body-fixed representation 
                # computed from screw coordinates in IFR
                self.X = [SE3AdjInvMatrix(
                    self.A[i])*self.Y[i] for i in range(self.n)]

        elif self.B:
            # print(&#39;Using relative configuration (B) of the body frames&#39;)
            FK_C = []
            for i in range(self.n):
                if self.parent[i] == 0: # bodies with no predecessor
                    # Initialization for the first body
                    FK_C.append(self.B[i]*SE3Exp(self.X[i], q[i]))
                else:
                    FK_C.append(FK_C[self.parent[i]-1]*self.B[i]*SE3Exp(self.X[i], q[i]))
        else:
            # &#39;Absolute (A) or Relative (B) configuration of the bodies should be provided in class!&#39;
            raise ValueError(&#34;Joint screw coordinates and/or reference configuration of bodies not set.&#34;)

        # Block diagonal matrix A (6n x 6n) of the Adjoint of body frame
        if self._A is not None:
            A = self._A
        else:
            A = Matrix(Identity(6*self.n))
            for i in range(self.n):        
                if True:
                # if self.parent[i] != 0:
                    for k in self.support[i]:
                        j = k-1
                        Crel = SE3Inv(FK_C[i])*FK_C[j]
                        AdCrel = SE3AdjMatrix(Crel)
                        r = 6*(i)
                        c = 6*(j)
                        A[r:r+6, c:c+6] = AdCrel
            self._A = A
        return FK_C, A
    
    def _find_start_index(self) -&gt; int:
        &#34;&#34;&#34;Guess if 0 or 1 is the first index in the robot by analysing 
        used variable names.

        Returns:
            int: index.
        &#34;&#34;&#34;
        # search all symbols
        syms = set()
        for i in self.Mb:
            syms.update(i.free_symbols)
        for i in self.body_ref_config:
            syms.update(i.free_symbols)
        for i in self.joint_screw_coord:
            syms.update(i.free_symbols)
        # search all indices in symbols
        indices = []
        for i in syms:
            indices.extend(regex.findall(&#34;\d+&#34;,str(i)))
        #find smalles used index
        if indices:
            if min([int(i) for i in indices]) == 0:
                return 0
            if max([int(i) for i in indices]) == self.n -1:
                return 0
        return 1</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="skidy.kinematics_generator.SymbolicKinDyn"><code class="flex name class">
<span>class <span class="ident">SymbolicKinDyn</span></span>
<span>(</span><span>gravity_vector: sympy.matrices.dense.MutableDenseMatrix = None, ee: sympy.matrices.dense.MutableDenseMatrix = None, body_ref_config: List[sympy.matrices.dense.MutableDenseMatrix] = [], joint_screw_coord: List[sympy.matrices.dense.MutableDenseMatrix] = [], config_representation: str = 'spatial', Mb: List[sympy.matrices.dense.MutableDenseMatrix] = [], parent: List[int] = [], support: List[List[int]] = [], child: List[List[int]] = [], q: sympy.matrices.dense.MutableDenseMatrix = None, qd: sympy.matrices.dense.MutableDenseMatrix = None, q2d: sympy.matrices.dense.MutableDenseMatrix = None, WEE: sympy.matrices.dense.MutableDenseMatrix = Matrix([
[0],
[0],
[0],
[0],
[0],
[0]]), **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>SymbolicKinDyn
Symbolic tool to compute equations of motion of serial chain
robots and autogenerate code from the calculated equations.
This tool supports generation of python, C and Matlab code.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gravity_vector</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>Vector of gravity. Defaults to None.</dd>
<dt><strong><code>ee</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>End-effector configuration with reference to last link
body fixed frame in the chain. Defaults to None.</dd>
<dt><strong><code>body_ref_config</code></strong> :&ensp;<code>list</code> of <code>sympy.Matrix</code>, optional</dt>
<dd>List of reference configurations of bodies in body-fixed
or spatial representation, dependent on selected
config_representation.
Leave empty for dH Parameter usage (dhToScrewCoord(&hellip;)).
Defaults to [].</dd>
<dt><strong><code>joint_screw_coord</code></strong> :&ensp;<code>list</code> of <code>sympy.Matrix</code>, optional</dt>
<dd>List of joint screw coordinates in body-fixed
or spatial representation, dependent on selected
config_representation.
Leave empty for dH Parameter usage (dhToScrewCoord(&hellip;)).
Defaults to [].</dd>
<dt><strong><code>config_representation</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Use body fixed or spatial representation for reference
configuration of bodies and joint screw coordinates.
Has to be "body_fixed" or "spatial".
Defaults to "spatial".</dd>
<dt><strong><code>Mb</code></strong> :&ensp;<code>list</code> of <code>sympy.Matrix</code>, optional</dt>
<dd>List of Mass Inertia matrices for all links. Only
necessary for inverse dynamics. Defaults to [].</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>list of parent link indices for any joint. Use 0 for world.
Only necessary for tree-like robot structures.
Defaults to [].</dd>
<dt><strong><code>support</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>list of lists with one list per link which includes all
support links beginning with the first link in the chain
and including the current link.
Only necessary for tree-like robot structures.
Defaults to [].</dd>
<dt><strong><code>child</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>list of lists with one list per link which includes all
child links. Use empty list if no child link is present.
Only necessary for tree-like robot structures.
Defaults to [].</dd>
<dt><strong><code>q</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(n,1) Generalized position vector. Defaults to None.</dd>
<dt><strong><code>qd</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(n,1) Generalized velocity vector. Defaults to None.</dd>
<dt><strong><code>q2d</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(n,1) Generalized acceleration vector. Defaults to None.</dd>
<dt><strong><code>WEE</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time varying
wrench on the EE link.
Defaults to zeros(6, 1).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SymbolicKinDyn(_AbstractCodeGeneration):
    BODY_FIXED = &#34;body_fixed&#34;
    SPATIAL = &#34;spatial&#34;
    
    def __init__(self, 
                 gravity_vector: MutableDenseMatrix=None, 
                 ee: MutableDenseMatrix=None, 
                 body_ref_config: List[MutableDenseMatrix]=[], 
                 joint_screw_coord: List[MutableDenseMatrix]=[], 
                 config_representation: str=&#34;spatial&#34;, 
                 Mb: List[MutableDenseMatrix]=[], 
                 parent: List[int]=[], 
                 support: List[List[int]]=[], 
                 child: List[List[int]]=[], 
                 q:MutableDenseMatrix=None, 
                 qd: MutableDenseMatrix=None, 
                 q2d: MutableDenseMatrix=None, 
                 WEE: MutableDenseMatrix=zeros(6, 1),
                 **kwargs) -&gt; None:
        &#34;&#34;&#34;SymbolicKinDyn
        Symbolic tool to compute equations of motion of serial chain 
        robots and autogenerate code from the calculated equations. 
        This tool supports generation of python, C and Matlab code.

        Args:
            gravity_vector (sympy.Matrix, optional): 
                Vector of gravity. Defaults to None.
            ee (sympy.Matrix, optional): 
                End-effector configuration with reference to last link 
                body fixed frame in the chain. Defaults to None.
            body_ref_config (list of sympy.Matrix, optional): 
                List of reference configurations of bodies in body-fixed
                or spatial representation, dependent on selected 
                config_representation. 
                Leave empty for dH Parameter usage (dhToScrewCoord(...)). 
                Defaults to [].
            joint_screw_coord (list of sympy.Matrix, optional): 
                List of joint screw coordinates in body-fixed 
                or spatial representation, dependent on selected 
                config_representation. 
                Leave empty for dH Parameter usage (dhToScrewCoord(...)). 
                Defaults to [].
            config_representation (str, optional): 
                Use body fixed or spatial representation for reference 
                configuration of bodies and joint screw coordinates.
                Has to be &#34;body_fixed&#34; or &#34;spatial&#34;. 
                Defaults to &#34;spatial&#34;.
            Mb (list of sympy.Matrix, optional): 
                List of Mass Inertia matrices for all links. Only 
                necessary for inverse dynamics. Defaults to [].
            parent (list, optional): 
                list of parent link indices for any joint. Use 0 for world.
                Only necessary for tree-like robot structures. 
                Defaults to [].
            support (list, optional): 
                list of lists with one list per link which includes all 
                support links beginning with the first link in the chain 
                and including the current link.
                Only necessary for tree-like robot structures. 
                Defaults to [].
            child (list, optional): 
                list of lists with one list per link which includes all
                child links. Use empty list if no child link is present.
                Only necessary for tree-like robot structures. 
                Defaults to [].
            q (sympy.Matrix, optional): 
                (n,1) Generalized position vector. Defaults to None.
            qd (sympy.Matrix, optional): 
                (n,1) Generalized velocity vector. Defaults to None.
            q2d (sympy.Matrix, optional): 
                (n,1) Generalized acceleration vector. Defaults to None.
            WEE (sympy.Matrix, optional): 
                (6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time varying 
                wrench on the EE link. 
                Defaults to zeros(6, 1).
            
        &#34;&#34;&#34;
        super().__init__()
        self.n = None  # degrees of freedom
        self.gravity_vector = gravity_vector
        self.ee = ee

        self.B = [] # List of reference configurations of bodies in body-fixed representation.
        self.X = [] # List of joint screw coordinates in body-fixed representation.

        self.A = [] # List of reference configurations of bodies in spatial representation.
        self.Y = [] # List of joint screw coordinates in spatial representation.
        
        self.config_representation = config_representation # @property: checks for valid value 
        if body_ref_config != []:
            self.body_ref_config = body_ref_config # @property: sets A or B
        if joint_screw_coord != []:
            self.joint_screw_coord = joint_screw_coord # @property: sets X or Y
        # support of old syntax
        if &#34;A&#34; in kwargs:
            self.A = kwargs[&#34;A&#34;]
            n = len(self.A)
            if n:
                self.n = n
        if &#34;B&#34; in kwargs:
            self.B = kwargs[&#34;B&#34;]
            n = len(self.B)
            if n:
                self.n = n
        if &#34;X&#34; in kwargs:
            self.X = kwargs[&#34;X&#34;]
        if &#34;Y&#34; in kwargs:
            self.Y = kwargs[&#34;Y&#34;]

            
        self.Mb = Mb
        self.parent = parent
        self.child = child
        self.support = support

        # temporary vars
        self._FK_C = None
        self._A = None
        self._a = None
        self._V = None  # system twist

        
        # Multiprocessing
        # dict of queues, which saves values and results
        self.queue_dict = {}  
        # dict of running processes
        self.process_dict = {}  
        
        # generalized vectors end external forces
        self.q = q
        self.qd = qd
        self.q2d = q2d
        self.WEE = WEE

        
    @property
    def config_representation(self) -&gt; str:
        return self._config_representation
    
    @config_representation.setter
    def config_representation(self, value: str) -&gt; None:
        if value not in {self.BODY_FIXED, self.SPATIAL}:
            raise ValueError(&#34;config_representation has to be &#39;body_fixed&#39; or &#39;spatial&#39;&#34;)
        self._config_representation = value
    
    @property
    def body_ref_config(self) -&gt; list:
        if self.config_representation == self.BODY_FIXED:
            return self.B
        elif self.config_representation == self.SPATIAL:
            return self.A
    
    @body_ref_config.setter
    def body_ref_config(self, value: List[MutableDenseMatrix]) -&gt; None:
        n = len(value)
        if n:
            self.n = n
        if self.config_representation == self.BODY_FIXED:
            self.B = value
        elif self.config_representation == self.SPATIAL:
            self.A = value
    
    @property
    def joint_screw_coord(self) -&gt; list:
        if self.config_representation == self.BODY_FIXED:
            return self.X
        elif self.config_representation == self.SPATIAL:
            return self.Y
    
    @joint_screw_coord.setter
    def joint_screw_coord(self, value: List[MutableDenseMatrix]) -&gt; None:
        if self.config_representation == self.BODY_FIXED:
            self.X = value
        elif self.config_representation == self.SPATIAL:
            self.Y = value
    
    def closed_form_kinematics_body_fixed(
        self, q:sympy.MutableDenseMatrix=None, qd: MutableDenseMatrix=None, 
        q2d: MutableDenseMatrix=None, simplify: bool=True, 
        cse: bool=False, parallel: bool=True) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Position, Velocity and Acceleration Kinematics using Body 
        fixed representation of the twists in closed form.

        The following expressions are saved in the class and can be 
        code generated afterwards:
        
            body_acceleration
            body_acceleration_ee
            body_jacobian_matrix
            body_jacobian_matrix_dot 
            body_jacobian_matrix_ee
            body_jacobian_matrix_ee_dot
            body_twist_ee
            forward_kinematics
            hybrid_acceleration
            hybrid_acceleration_ee
            hybrid_jacobian_matrix
            hybrid_jacobian_matrix_dot
            hybrid_jacobian_matrix_ee
            hybrid_jacobian_matrix_ee_dot
            hybrid_twist_ee

        Needs class parameters body_ref_config, joint_screw_coord and ee 
        to be defined.

        Args:
            q (sympy.Matrix, optional): 
                (n,1) Generalized position vector. Defaults to None.
            qd (sympy.Matrix, optional): 
                (n,1) Generalized velocity vector. Defaults to None.
            q2d (sympy.Matrix, optional): 
                (n,1) Generalized acceleration vector. Defaults to None.
            simplify (bool, optional): 
                Use simplify command on saved expressions. 
                Defaults to True.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.
            parallel (bool, optional): 
                Use parallel computation via multiprocessing. 
                Defaults to True.
        Raises:
            ValueError:
                Joint screw coordinates and/or reference configuration 
                of bodies not set.
                
        Returns:
            sympy.Matrix: Forward kinematics.
        &#34;&#34;&#34;
        if not q or not qd or not q2d:
            if not self.n:
                self.n = len(self.body_ref_config)
            if not self.q or not self.qd or not self.q2d:
                q, qd, q2d = generalized_vectors(self.n,self._find_start_index())
            else:
                q, qd, q2d = self.q, self.qd, self.q2d
            
        if parallel:
            self._closed_form_kinematics_body_fixed_parallel(
                q, qd, q2d, simplify, cse)
        else:
            self._closed_form_kinematics_body_fixed(
                q, qd, q2d, simplify, cse)
        return self.fkin

    def closed_form_inv_dyn_body_fixed(
        self, q:sympy.MutableDenseMatrix=None, qd: MutableDenseMatrix=None, 
        q2d: MutableDenseMatrix=None, WEE: MutableDenseMatrix=..., 
        simplify: bool=True, cse: bool=False, 
        parallel: bool=True) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Inverse dynamics using body fixed representation of the 
        twists in closed form. 

        The following expressions are saved in the class and can be 
        code generated afterwards:
            coriolis_centrifugal_matrix
            generalized_mass_inertia_matrix
            gravity_vector
            inverse_dynamics

        Args:
            q (sympy.Matrix, optional): 
                (n,1) Generalized position vector. Defaults to None.
            qd (sympy.Matrix, optional): 
                (n,1) Generalized velocity vector. Defaults to None.
            q2d (sympy.Matrix, optional): 
                (n,1) Generalized acceleration vector. Defaults to None.
            WEE (sympy.Matrix, optional): 
                (6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time varying 
                wrench on the EE link. 
                Defaults to zeros(6, 1).
            simplify (bool, optional): 
                Use simplify command on saved expressions. 
                Defaults to True.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.
            parallel (bool, optional): 
                Use parallel computation via multiprocessing. 
                Defaults to True.

        Raises:
            ValueError:
                Joint screw coordinates and/or reference configuration 
                of bodies not set.
        
        Returns:
            sympy.Matrix: Generalized forces
        &#34;&#34;&#34;
        if not q or not qd or not q2d:
            if not self.n:
                self.n = len(self.body_ref_config)
            if not self.q or not self.qd or not self.q2d:
                q, qd, q2d = generalized_vectors(self.n,self._find_start_index())
            else:
                q, qd, q2d = self.q, self.qd, self.q2d
        
        if WEE is Ellipsis:
            WEE = self.WEE
            
        if parallel:
            self._closed_form_inv_dyn_body_fixed_parallel(
                q, qd, q2d, WEE, simplify, cse)
        else:
            self._closed_form_inv_dyn_body_fixed(
                q, qd, q2d, WEE, simplify, cse)
        return self.Q

    def _closed_form_kinematics_body_fixed(
        self, q: MutableDenseMatrix, qd: MutableDenseMatrix, 
        q2d: MutableDenseMatrix, simplify: bool=True, 
        cse: bool=False) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Position, velocity and acceleration kinematics using 
        body fixed representation of the twists in closed form.

        The following expressions are saved in the class and can be 
        code generated afterwards:
            body_acceleration
            body_acceleration_ee
            body_jacobian_matrix
            body_jacobian_matrix_dot 
            body_jacobian_matrix_ee
            body_jacobian_matrix_ee_dot
            body_twist_ee
            forward_kinematics
            hybrid_acceleration
            hybrid_acceleration_ee
            hybrid_jacobian_matrix
            hybrid_jacobian_matrix_dot
            hybrid_jacobian_matrix_ee
            hybrid_jacobian_matrix_ee_dot
            hybrid_twist_ee

            Needs class parameters body_ref_config, joint_screw_coord 
            and ee to be defined.

        Args:
            q (sympy.Matrix): 
                (n,1) Generalized position vector.
            qd (sympy.Matrix): 
                (n,1) Generalized velocity vector.
            q2d (sympy.Matrix): 
                (n,1) Generalized acceleration vector.
            simplify (bool, optional): 
                Use simplify command on saved expressions. 
                Defaults to True.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.


        Returns:
            sympy.Matrix: Forward kinematics.
        &#34;&#34;&#34;
        print(&#34;Forward kinematics calculation&#34;)
        self.var_syms.update(q.free_symbols)
        self.var_syms.update(qd.free_symbols)
        self.var_syms.update(q2d.free_symbols)

        self.n = len(q)  # DOF

        # calc Forward kinematics
        if self.parent and self.support:
            FK_C, A = self._calc_A_matrix_tree(q)
        else:    
            FK_C, A = self._calc_A_matrix(q)
            
        fkin = FK_C[self.n-1]*self.ee
        if simplify:
            fkin = self.simplify(fkin, cse)
        elif cse:
            fkin = self._cse_expression(fkin)    
        self.fkin = fkin


        if self.J is not None:
            J = self.J
            V = self._V
        else:
            # Block diagonal matrix X (6n x n) of the screw coordinate 
            # vector associated to all joints in the body frame (Constant)
            X = zeros(6*self.n, self.n)
            for i in range(self.n):
                X[6*i:6*i+6, i] = self.X[i]

            # System level Jacobian
            J = A*X
            if simplify:
                J = self.simplify(J, cse)
            elif cse:
                J = self._cse_expression(J)
            self.J = J

            # System twist (6n x 1)
            V = J*qd
            self._V = V

        # Different Jacobians
        R_i = Matrix(fkin[:3, :3]).row_join(
            zeros(3, 1)).col_join(Matrix([0, 0, 0, 1]).T)
        if simplify:  # fastens later simplifications
            R_i = self.simplify(R_i, cse)
        elif cse:
            R_i = self._cse_expression(R_i)

        R_BFn = Matrix(FK_C[-1][:3, :3]).row_join(
            zeros(3, 1)).col_join(Matrix([0, 0, 0, 1]).T)

        # Body fixed Jacobian of last moving body 
        # (This may not correspond to end-effector frame)
        Jb = J[-6:, :]
        if simplify:
            Jb = self.simplify(Jb, cse)
        elif cse:
            Jb = self._cse_expression(Jb)

        Vb_BFn = Jb*qd  # Body fixed twist of last moving body
        if simplify:
            Vb_BFn = self.simplify(Vb_BFn, cse)
        elif cse:
            Vb_BFn = self._cse_expression(Vb_BFn)
        Vh_BFn = SE3AdjMatrix(R_BFn)*Vb_BFn
        if simplify:
            Vh_BFn = self.simplify(Vh_BFn, cse)
        elif cse:
            Vh_BFn = self._cse_expression(Vh_BFn)
        self.Vb_BFn = Vb_BFn
        self.Vh_BFn = Vh_BFn

        # Body fixed twist of end-effector frame
        Vb_ee = SE3AdjMatrix(SE3Inv(self.ee))*Vb_BFn
        if simplify:
            Vb_ee = self.simplify(Vb_ee, cse)
        elif cse:
            Vb_ee = self._cse_expression(Vb_ee)
        # Hybrid twist of end-effector frame
        Vh_ee = SE3AdjMatrix(R_i)*Vb_ee
        if simplify:
            Vh_ee = self.simplify(Vh_ee, cse)
        elif cse:
            Vh_ee = self._cse_expression(Vh_ee)

        self.Vb_ee = Vb_ee
        self.Vh_ee = Vh_ee

        # Body fixed Jacobian of end-effector frame
        Jb_ee = SE3AdjMatrix(SE3Inv(self.ee))*Jb
        if simplify:
            Jb_ee = self.simplify(Jb_ee, cse)
        elif cse:
            Jb_ee = self._cse_expression(Jb_ee)

        # Hybrid Jacobian of end-effector frame
        Jh_ee = SE3AdjMatrix(R_i)*Jb_ee
        # Hybrid Jacobian of last moving body
        Jh = SE3AdjMatrix(R_i)*Jb  

        if simplify:
            Jh_ee = self.simplify(Jh_ee, cse)
            Jh = self.simplify(Jh, cse)
        elif cse:
            Jh_ee = self._cse_expression(Jh_ee)
            Jh = self._cse_expression(Jh)

        self.Jh_ee = Jh_ee
        self.Jb_ee = Jb_ee
        self.Jh = Jh
        self.Jb = Jb

        # Acceleration computations
        if self._a is not None:
            a = self._a
        else:
            # Block diagonal matrix a (6n x 6n)
            a = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                a[6*i:6*i+6, 6*i:6*i+6] = SE3adMatrix(self.X[i])*qd[i]
            if simplify:
                a = self.simplify(a, cse)
            elif cse:
                a = self._cse_expression(a)
            self._a = a

        # System acceleration (6n x 1)
        Jdot = -A*a*J  # Sys-level Jacobian time derivative
        if simplify:
            Jdot = self.simplify(Jdot, cse)
        elif cse:
            Jdot = self._cse_expression(Jdot)

        self.Jdot = Jdot

        Vbd = J*q2d - A*a*V

        # Hybrid acceleration of the last body
        Vbd_BFn = Vbd[-6:, :]
        if simplify:
            Vbd_BFn = self.simplify(Vbd_BFn, cse)
        elif cse:
            Vbd_BFn = self._cse_expression(Vbd_BFn)
        # Hybrid twist of end-effector frame 
        # TODO: check comments
        Vhd_BFn = (SE3AdjMatrix(R_BFn)*Vbd_BFn 
                   + SE3adMatrix(Matrix(Vh_BFn[:3, :])
                                      .col_join(Matrix([0, 0, 0])))
                   * SE3AdjMatrix(R_BFn)*Vb_BFn)  

        if simplify:
            Vhd_BFn = self.simplify(Vhd_BFn, cse)
        elif cse:
            Vhd_BFn = self._cse_expression(Vhd_BFn)

        self.Vbd_BFn = Vbd_BFn
        self.Vhd_BFn = Vhd_BFn

        # Body fixed twist of end-effector frame
        # Hybrid acceleration of the EE
        Vbd_ee = SE3AdjMatrix(SE3Inv(self.ee))*Vbd_BFn
        if simplify:
            Vbd_ee = self.simplify(Vbd_ee, cse)
        elif cse:
            Vbd_ee = self._cse_expression(Vbd_ee)
        # Hybrid twist of end-effector frame
        Vhd_ee = SE3AdjMatrix(R_i)*Vbd_ee + SE3adMatrix(Matrix(
            Vh_ee[:3, :]).col_join(Matrix([0, 0, 0])))*\
                SE3AdjMatrix(R_i)*Vb_ee  
        if simplify:
            Vhd_ee = self.simplify(Vhd_ee, cse)
        elif cse:
            Vhd_ee = self._cse_expression(Vhd_ee)

        self.Vbd_ee = Vbd_ee
        self.Vhd_ee = Vhd_ee

        # Body Jacobian time derivative

        # For the last moving body
        Jb_dot = Jdot[-6:, :]
        self.Jb_dot = Jb_dot

        # For the EE
        Jb_ee_dot = SE3AdjMatrix(SE3Inv(self.ee))*Jb_dot
        if simplify:
            Jb_ee_dot = self.simplify(Jb_ee_dot, cse)
        elif cse:
            Jb_ee_dot = self._cse_expression(Jb_ee_dot)
        self.Jb_ee_dot = Jb_ee_dot

        # Hybrid Jacobian time derivative
        # For the last moving body
        Jh_dot = SE3AdjMatrix(R_BFn)*Jb_dot + SE3adMatrix(
            Matrix(Vh_BFn[:3, :]).col_join(Matrix([0, 0, 0])))*\
                SE3AdjMatrix(R_BFn)*Jb
        if simplify:
            Jh_dot = self.simplify(Jh_dot, cse)
        elif cse:
            Jh_dot = self._cse_expression(Jh_dot)
        self.Jh_dot = Jh_dot

        # For the EE
        Jh_ee_dot = SE3AdjMatrix(R_i)*Jb_ee_dot + SE3adMatrix(
            Matrix(Vh_ee[:3, :]).col_join(Matrix([0, 0, 0])))*\
                SE3AdjMatrix(R_i)*Jb_ee
        if simplify:
            Jh_ee_dot = self.simplify(Jh_ee_dot, cse)
        elif cse:
            Jh_ee_dot = self._cse_expression(Jh_ee_dot)
        self.Jh_ee_dot = Jh_ee_dot

        for e in self._get_expressions():
            self.all_symbols.update(e.free_symbols)

        print(&#34;Done&#34;)
        return fkin

    def _closed_form_inv_dyn_body_fixed(self, q: MutableDenseMatrix, 
                                        qd: MutableDenseMatrix, 
                                        q2d: MutableDenseMatrix, 
                                        WEE: MutableDenseMatrix=zeros(6, 1), 
                                        simplify: bool=True, 
                                        cse: bool=False) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Inverse dynamics using body fixed representation of the 
        twists in closed form. 

        The following expressions are saved in the class and can be code 
        generated afterwards:
            coriolis_centrifugal_matrix
            generalized_mass_inertia_matrix
            gravity_vector
            inverse_dynamics

        Args:
            q (sympy.Matrix): (n,1) Generalized position vector.
            qd (sympy.Matrix): (n,1 )Generalized velocity vector.
            q2d (sympy.Matrix): (n,1) Generalized acceleration vector.
            WEE (sympy.Matrix, optional): 
                (6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time 
                varying wrench on the EE link. Defaults to zeros(6, 1).
            simplify (bool, optional): Use simplify command 
                on saved expressions. Defaults to True.
            cse (bool, optional): Use common subexpression 
                elimination. Defaults to False.

        Returns:
            sympy.Matrix: Generalized forces
        &#34;&#34;&#34;
        print(&#34;Inverse dynamics calculation&#34;)

        self.var_syms.update(q.free_symbols)
        self.var_syms.update(qd.free_symbols)
        self.var_syms.update(q2d.free_symbols)
        self.optional_var_syms.update(WEE.free_symbols)

        self.n = len(q)

        # calc Forward kinematics
        if self.parent and self.support:
            FK_C, A = self._calc_A_matrix_tree(q)
        else:    
            FK_C, A = self._calc_A_matrix(q)
        
        if self.J is not None:
            J = self.J  # system level Jacobian
            V = self._V  # system twist
        else:
            # Block diagonal matrix X (6n x n) of the screw coordinate 
            # vector associated to all joints in the body frame (constant)
            X = zeros(6*self.n, self.n)
            for i in range(self.n):
                X[6*i:6*i+6, i] = self.X[i]

            # System level Jacobian
            J = A*X
            if simplify:
                J = self.simplify(J, cse)
            elif cse:
                J = self._cse_expression(J)
            self.J = J

            # System twist (6n x 1)
            V = J*qd
            self._V = V

        # Acceleration computations
        if self._a is not None:
            a = self._a
        else:
            # Block diagonal matrix a (6n x 6n)
            a = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                a[6*i:6*i+6, 6*i:6*i+6] = SE3adMatrix(self.X[i])*qd[i]
            self._a = a

        # System acceleration (6n x 1)
        Vd = J*q2d - A*a*V

        # Block Diagonal Mb (6n x 6n) Mass inertia matrix in body frame 
        # (constant)
        Mb = zeros(6*self.n, 6*self.n)
        for i in range(self.n):
            Mb[i*6:i*6+6, i*6:i*6+6] = self.Mb[i]

        # Block diagonal matrix b (6n x 6n) used in Coriolis matrix
        b = zeros(6*self.n, 6*self.n)
        for i in range(self.n):
            b[i*6:i*6+6, i*6:i*6+6] = SE3adMatrix(Matrix(V[6*i:6*i+6]))

        # Block diagonal matrix Cb (6n x 6n)
        Cb = -Mb*A*a - b.T * Mb

        # Lets setup the Equations of Motion

        # Mass inertia matrix in joint space (n x n)
        M = J.T*Mb*J
        if simplify:
            M = self.simplify(M, cse)
        elif cse:
            M = self._cse_expression(M)

        # Coriolis-Centrifugal matrix in joint space (n x n)
        C = J.T * Cb * J
        if simplify:
            C = self.simplify(C, cse)
        elif cse:
            C = self._cse_expression(C)

        # Gravity Term
        U = SE3AdjInvMatrix(FK_C[0])
        for k in range(1, self.n):
            U = U.col_join(SE3AdjInvMatrix(FK_C[k]))

        Vd_0 = zeros(6, 1)
        Vd_0[3:6, 0] = self.gravity_vector
        Qgrav = J.T*Mb*U*Vd_0
        if simplify:
            Qgrav = self.simplify(Qgrav, cse)
        elif cse:
            Qgrav = self._cse_expression(Qgrav)

        # External Wrench
        Wext = zeros(6*self.n, 1)
        # WEE (t) is the time varying wrench on the EE link.
        Wext[-6:, 0] = WEE
        Qext = J.T * Wext

        # Generalized forces Q
        # Q = M*q2d + C*qd   # without gravity
        Q = M*q2d + C*qd + Qgrav + Qext

        if simplify:
            Q = self.simplify(Q, cse)
        elif cse:
            Q = self._cse_expression(Q)

        self.M = M
        self.C = C
        self.Q = Q
        self.Qgrav = Qgrav

        # save used symbols
        for e in self._get_expressions():
            self.all_symbols.update(e.free_symbols)

        print(&#34;Done&#34;)
        return Q

    def _closed_form_kinematics_body_fixed_parallel(
        self, q: MutableDenseMatrix, qd: MutableDenseMatrix, 
        q2d: MutableDenseMatrix, simplify: bool=True, 
        cse: bool=False) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Position, velocity and acceleration kinematics using 
        body fixed representation of the twists in closed form.

        The following expressions are saved in the class and can be 
        code generated afterwards:
            body_acceleration
            body_acceleration_ee
            body_jacobian_matrix
            body_jacobian_matrix_dot 
            body_jacobian_matrix_ee
            body_jacobian_matrix_ee_dot
            body_twist_ee
            forward_kinematics
            hybrid_acceleration
            hybrid_acceleration_ee
            hybrid_jacobian_matrix
            hybrid_jacobian_matrix_dot
            hybrid_jacobian_matrix_ee
            hybrid_jacobian_matrix_ee_dot
            hybrid_twist_ee

        Args:
            q (sympy.Matrix): 
                (n,1) Generalized position vector.
            qd (sympy.Matrix): 
                (n,1) Generalized velocity vector.
            q2d (sympy.Matrix): 
                (n,1) Generalized acceleration vector.
            simplify (bool, optional): 
                Use simplify command on saved expressions. 
                Defaults to True.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.

        Returns:
            sympy.Matrix: Forward kinematics.
        &#34;&#34;&#34;
        # This method does the same as _closed_form_kinematics_body_fixed.
        # Parallel computation is implemented by writing most values 
        # in queues, organized in a dict.
        # This ensures the correct order for the execution.
        # To understand the calculations it is recommended to read the 
        # code in _closed_form_kinematics_body_fixed since it is more 
        # readable and has the same structure.

        print(&#34;Forward kinematics calculation&#34;)
        self.var_syms.update(q.free_symbols)
        self.var_syms.update(qd.free_symbols)
        self.var_syms.update(q2d.free_symbols)

        self.n = len(q)
        self.queue_dict[&#34;subex_dict&#34;] = Queue()

        # calc Forward kinematics
        if self.parent and self.support:
            FK_C, A = self._calc_A_matrix_tree(q)
        else:    
            FK_C, A = self._calc_A_matrix(q)
        
        self._set_value(&#34;fkin&#34;, FK_C[self.n-1]*self.ee)
        if simplify:
            self._start_simplification_process(&#34;fkin&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;fkin&#34;)


        if self.J is not None:
            self._set_value(&#34;J&#34;, self.J)
            self._set_value(&#34;V&#34;, self._V)
        else:
            # Block diagonal matrix X (6n x n) of the screw coordinate 
            # vector associated to all joints in the body frame (Constant)
            X = zeros(6*self.n, self.n)
            for i in range(self.n):
                X[6*i:6*i+6, i] = self.X[i]

            # System level Jacobian
            self._set_value(&#34;J&#34;, A*X)
            if simplify:
                self._start_simplification_process(&#34;J&#34;, cse)
            elif cse:
                self._start_cse_process(&#34;J&#34;)
            # System twist (6n x 1)
            self._set_value_as_process(&#34;V&#34;, lambda: self._get_value(&#34;J&#34;)*qd)

        # Different Jacobians
        self._set_value_as_process(
            &#34;R_i&#34;, 
            lambda: 
                Matrix(self._get_value(&#34;fkin&#34;)[:3, :3])
                .row_join(zeros(3, 1))
                .col_join(Matrix([0, 0, 0, 1]).T)
            )

        if simplify:  # fastens later simplifications
            self._start_simplification_process(&#34;R_i&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;R_i&#34;)

        self._set_value(&#34;R_BFn&#34;, Matrix(FK_C[-1][:3, :3]).row_join(
            zeros(3, 1)).col_join(Matrix([0, 0, 0, 1]).T))

        # Body fixed Jacobian of last moving body 
        # (This may not correspond to end-effector frame)
        self._set_value_as_process(&#34;Jb&#34;, lambda: self._get_value(&#34;J&#34;)[-6:, :])
        if simplify:
            self._start_simplification_process(&#34;Jb&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Jb&#34;)

        self._set_value_as_process(&#34;Vb_BFn&#34;, lambda: self._get_value(&#34;Jb&#34;)*qd)
        # Body fixed twist of last moving body
        if simplify:
            self._start_simplification_process(&#34;Vb_BFn&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Vb_BFn&#34;)

        self._set_value_as_process(&#34;Vh_BFn&#34;, lambda: SE3AdjMatrix(
            self._get_value(&#34;R_BFn&#34;))*self._get_value(&#34;Vb_BFn&#34;))
        if simplify:
            self._start_simplification_process(&#34;Vh_BFn&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Vh_BFn&#34;)

        # Body fixed twist of end-effector frame
        self._set_value_as_process(&#34;Vb_ee&#34;, lambda: SE3AdjMatrix(
            SE3Inv(self.ee))*self._get_value(&#34;Vb_BFn&#34;))
        if simplify:
            self._start_simplification_process(&#34;Vb_ee&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Vb_ee&#34;)
        # Hybrid twist of end-effector frame
        self._set_value_as_process(&#34;Vh_ee&#34;, lambda: SE3AdjMatrix(
            self._get_value(&#34;R_i&#34;))*self._get_value(&#34;Vb_ee&#34;))
        if simplify:
            self._start_simplification_process(&#34;Vh_ee&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Vh_ee&#34;)

        # Body fixed Jacobian of end-effector frame
        self._set_value_as_process(&#34;Jb_ee&#34;, lambda: SE3AdjMatrix(
            SE3Inv(self.ee))*self._get_value(&#34;Jb&#34;))
        if simplify:
            self._start_simplification_process(&#34;Jb_ee&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Jb_ee&#34;)

        # Hybrid Jacobian of end-effector frame
        self._set_value_as_process(&#34;Jh_ee&#34;, lambda: SE3AdjMatrix(
            self._get_value(&#34;R_i&#34;))*self._get_value(&#34;Jb_ee&#34;))
        # Hybrid Jacobian of last moving body
        self._set_value_as_process(&#34;Jh&#34;, lambda: SE3AdjMatrix(
            self._get_value(&#34;R_i&#34;))*self._get_value(&#34;Jb&#34;))

        if simplify:
            self._start_simplification_process(&#34;Jh_ee&#34;, cse)
            self._start_simplification_process(&#34;Jh&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Jh_ee&#34;)
            self._start_cse_process(&#34;Jh&#34;)

        # Acceleration computations
        if self._a is not None:
            self._set_value(&#34;a&#34;, self._a)
        else:
            # Block diagonal matrix a (6n x 6n)
            a = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                a[6*i:6*i+6, 6*i:6*i+6] = SE3adMatrix(self.X[i])*qd[i]
            self._set_value(&#34;a&#34;, a)
            if simplify:
                self._start_simplification_process(&#34;a&#34;, cse)
            elif cse:
                self._start_cse_process(&#34;a&#34;)

        # System acceleration (6n x 1)
        # System-level Jacobian time derivative
        self._set_value_as_process(
            &#34;Jdot&#34;, lambda: -A*self._get_value(&#34;a&#34;)*self._get_value(&#34;J&#34;))
        if simplify:
            self._start_simplification_process(&#34;Jdot&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Jdot&#34;)

        self._set_value_as_process(&#34;Vbd&#34;, lambda: self._get_value(
            &#34;J&#34;)*q2d - A*self._get_value(&#34;a&#34;)*self._get_value(&#34;V&#34;))

        # Hybrid acceleration of the last body
        self._set_value_as_process(
            &#34;Vbd_BFn&#34;, lambda: self._get_value(&#34;Vbd&#34;)[-6:, :])

        if simplify:
            self._start_simplification_process(&#34;Vbd_BFn&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Vbd_BFn&#34;)

        # Hybrid twist of end-effector frame
        self._set_value_as_process(
            &#34;Vhd_BFn&#34;, 
            lambda: 
                SE3AdjMatrix(self._get_value(&#34;R_BFn&#34;))
                * self._get_value(&#34;Vbd_BFn&#34;) 
                + SE3adMatrix(Matrix(self._get_value(&#34;Vh_BFn&#34;)[:3, :])
                                   .col_join(Matrix([0, 0, 0])))
                * SE3AdjMatrix(self._get_value(&#34;R_BFn&#34;))
                * self._get_value(&#34;Vb_BFn&#34;)
            )

        if simplify:
            self._start_simplification_process(&#34;Vhd_BFn&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Vhd_BFn&#34;)

        # Body fixed twist of end-effector frame
        # Hybrid acceleration of the EE
        self._set_value_as_process(&#34;Vbd_ee&#34;, lambda: SE3AdjMatrix(
            SE3Inv(self.ee))*self._get_value(&#34;Vbd_BFn&#34;))
        if simplify:
            self._start_simplification_process(&#34;Vbd_ee&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Vbd_ee&#34;)
        # Hybrid twist of end-effector frame
        self._set_value_as_process(
            &#34;Vhd_ee&#34;, 
            lambda: 
                SE3AdjMatrix(self._get_value(&#34;R_i&#34;)) 
                * self._get_value(&#34;Vbd_ee&#34;) 
                + SE3adMatrix(Matrix(self._get_value(&#34;Vh_ee&#34;)[:3, :])
                                   .col_join(Matrix([0, 0, 0])))
                * SE3AdjMatrix(self._get_value(&#34;R_i&#34;))
                * self._get_value(&#34;Vb_ee&#34;)
            )  # Hybrid twist of end-effector frame

        if simplify:
            self._start_simplification_process(&#34;Vhd_ee&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Vhd_ee&#34;)

        # Body Jacobian time derivative

        # For the last moving body
        self._set_value_as_process(
            &#34;Jb_dot&#34;, lambda: self._get_value(&#34;Jdot&#34;)[-6:, :])

        # For the EE
        self._set_value_as_process(&#34;Jb_ee_dot&#34;, lambda: SE3AdjMatrix(
            SE3Inv(self.ee))*self._get_value(&#34;Jb_dot&#34;))
        if simplify:
            self._start_simplification_process(&#34;Jb_ee_dot&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Jb_ee_dot&#34;)

        # Hybrid Jacobian time derivative
        # For the last moving body
        self._set_value_as_process(
            &#34;Jh_dot&#34;, 
            lambda: 
                SE3AdjMatrix(self._get_value(&#34;R_BFn&#34;))
                * self._get_value(&#34;Jb_dot&#34;) 
                + SE3adMatrix(Matrix(self._get_value(&#34;Vh_BFn&#34;)[:3, :])
                                   .col_join(Matrix([0, 0, 0])))
                * SE3AdjMatrix(self._get_value(&#34;R_BFn&#34;))
                * self._get_value(&#34;Jb&#34;)
            )
        if simplify:
            self._start_simplification_process(&#34;Jh_dot&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Jh_dot&#34;)

        # For the EE
        self._set_value_as_process(
            &#34;Jh_ee_dot&#34;, 
            lambda: 
                SE3AdjMatrix(self._get_value(&#34;R_i&#34;))
                * self._get_value(&#34;Jb_ee_dot&#34;) 
                + SE3adMatrix(Matrix(self._get_value(&#34;Vh_ee&#34;)[:3, :])
                                   .col_join(Matrix([0, 0, 0])))
                * SE3AdjMatrix(self._get_value(&#34;R_i&#34;))
                * self._get_value(&#34;Jb_ee&#34;)
            )
        if simplify:
            self._start_simplification_process(&#34;Jh_ee_dot&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Jh_ee_dot&#34;)
        self._a = self._get_value(&#34;a&#34;)
        self._V = self._get_value(&#34;V&#34;)

        # variables for Code Generation:
        self.fkin = self._get_value(&#34;fkin&#34;)
        self.J = self._get_value(&#34;J&#34;)
        self.Jb = self._get_value(&#34;Jb&#34;)
        self.Jh = self._get_value(&#34;Jh&#34;)
        self.Jdot = self._get_value(&#34;Jdot&#34;)
        self.Vb_ee = self._get_value(&#34;Vb_ee&#34;)
        self.Vh_ee = self._get_value(&#34;Vh_ee&#34;)
        self.Jb_ee = self._get_value(&#34;Jb_ee&#34;)
        self.Jh_ee = self._get_value(&#34;Jh_ee&#34;)
        self.Vh_BFn = self._get_value(&#34;Vh_BFn&#34;)
        self.Vb_BFn = self._get_value(&#34;Vb_BFn&#34;)
        self.Vhd_BFn = self._get_value(&#34;Vhd_BFn&#34;)
        self.Vbd_BFn = self._get_value(&#34;Vbd_BFn&#34;)
        self.Vhd_ee = self._get_value(&#34;Vhd_ee&#34;)
        self.Vbd_ee = self._get_value(&#34;Vbd_ee&#34;)
        self.Jh_dot = self._get_value(&#34;Jh_dot&#34;)
        self.Jb_dot = self._get_value(&#34;Jb_dot&#34;)
        self.Jh_ee_dot = self._get_value(&#34;Jh_ee_dot&#34;)
        self.Jb_ee_dot = self._get_value(&#34;Jb_ee_dot&#34;)

        try:
            while True:
                self.subex_dict.update(
                    self.queue_dict[&#34;subex_dict&#34;].get(timeout=0.05))
        except queue.Empty:
            pass

        # empty Queues
        for i in self.queue_dict:
            self._flush_queue(self.queue_dict[i])
        self.queue_dict = {}

        # join Processes
        for i in self.process_dict:
            self.process_dict[i].join()
        self.process_dict = {}

        # save used symbols
        for e in self._get_expressions():
            self.all_symbols.update(e.free_symbols)

        print(&#34;Done&#34;)
        return self.fkin

    def _closed_form_inv_dyn_body_fixed_parallel(
        self, q: MutableDenseMatrix, qd: MutableDenseMatrix, 
        q2d: MutableDenseMatrix, WEE: MutableDenseMatrix=zeros(6, 1), 
        simplify: bool=True, cse: bool=False) -&gt; MutableDenseMatrix:
        &#34;&#34;&#34;Inverse dynamics using body fixed representation of the 
        twists in closed form. 

        The following expressions are saved in the class and can be 
        code generated afterwards:
            coriolis_centrifugal_matrix
            generalized_mass_inertia_matrix
            gravity_vector
            inverse_dynamics

        Args:
            q (sympy.Matrix): 
                (n,1) Generalized position vector.
            qd (sympy.Matrix): 
                (n,1 )Generalized velocity vector.
            q2d (sympy.Matrix): 
                (n,1) Generalized acceleration vector.
            WEE (sympy.Matrix, optional): 
                (6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time varying 
                wrench on the EE link. 
                Defaults to zeros(6, 1).
            simplify (bool, optional): 
                Use simplify command on saved expressions. 
                Defaults to True.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.

        Returns:
            sympy.Matrix: Generalized Forces
        &#34;&#34;&#34;
        # This method does the same as _closed_form_inv_dyn_body_fixed.
        # Parallel computation is implemented by writing most values 
        # in queues, organized in a dict.
        # This ensures the correct order for the execution.
        # To understand the calculations it is recommended to read the 
        # code in _closed_form_inv_dyn_body_fixed since it is more 
        # readable and has the same structure.

        print(&#34;Inverse dynamics calculation&#34;)

        self.var_syms.update(q.free_symbols)
        self.var_syms.update(qd.free_symbols)
        self.var_syms.update(q2d.free_symbols)
        self.optional_var_syms.update(WEE.free_symbols)

        self.n = len(q)
        self.queue_dict[&#34;subex_dict&#34;] = Queue()

        # calc Forward kinematics
        if self.parent and self.support:
            FK_C, A = self._calc_A_matrix_tree(q)
        else:    
            FK_C, A = self._calc_A_matrix(q)
        
        if self.J is not None:
            self._set_value(&#34;J&#34;, self.J)
            self._set_value(&#34;V&#34;, self._V)
        else:
            # Block diagonal matrix X (6n x n) of the screw coordinate 
            # vector associated to all joints in the body frame (Constant)
            X = zeros(6*self.n, self.n)
            for i in range(self.n):
                X[6*i:6*i+6, i] = self.X[i]

            # System level Jacobian
            self._set_value(&#34;J&#34;, A*X)
            if simplify:
                self._start_simplification_process(&#34;J&#34;, cse)
            elif cse:
                self._start_cse_process(&#34;J&#34;)

            # System twist (6n x 1)
            self._set_value_as_process(&#34;V&#34;, lambda: self._get_value(&#34;J&#34;)*qd)

        # Acceleration computations

        if self._a is not None:
            a = self._a
        else:
            # Block diagonal matrix a (6n x 6n)
            a = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                a[6*i:6*i+6, 6*i:6*i+6] = SE3adMatrix(self.X[i])*qd[i]
            self._a = a

        # System acceleration (6n x 1)
        # Vd = J*q2d - A*a*V
        self._set_value_as_process(&#34;Vd&#34;, lambda: self._get_value(
            &#34;J&#34;)*q2d - A*a*self._get_value(&#34;V&#34;))

        # Block Diagonal Mb (6n x 6n) Mass inertia matrix in body frame 
        # (Constant)
        Mb = zeros(6*self.n, 6*self.n)
        for i in range(self.n):
            Mb[i*6:i*6+6, i*6:i*6+6] = self.Mb[i]

        # Block diagonal matrix b (6n x 6n) used in Coriolis matrix
        def _b():
            nonlocal self
            b = zeros(6*self.n, 6*self.n)
            for i in range(self.n):
                b[i*6:i*6+6, i*6:i*6 + 6] = SE3adMatrix(
                    Matrix(self._get_value(&#34;V&#34;)[6*i:6*i+6]))
            return b
        self._set_value_as_process(&#34;b&#34;, _b)

        # Block diagonal matrix Cb (6n x 6n)
        self._set_value_as_process(
            &#34;Cb&#34;, lambda: -Mb*A*a - self._get_value(&#34;b&#34;).T * Mb)

        # Lets setup the Equations of Motion

        # Mass inertia matrix in joint space (n x n)
        self._set_value_as_process(
            &#34;M&#34;, lambda: self._get_value(&#34;J&#34;).T*Mb*self._get_value(&#34;J&#34;))
        if simplify:
            self._start_simplification_process(&#34;M&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;M&#34;)

        # Coriolis-Centrifugal matrix in joint space (n x n)
        self._set_value_as_process(&#34;C&#34;, lambda: self._get_value(
            &#34;J&#34;).T*self._get_value(&#34;Cb&#34;)*self._get_value(&#34;J&#34;))
        if simplify:
            self._start_simplification_process(&#34;C&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;C&#34;)

        # Gravity Term
        U = SE3AdjInvMatrix(FK_C[0])
        for k in range(1, self.n):
            U = U.col_join(SE3AdjInvMatrix(FK_C[k]))

        Vd_0 = zeros(6, 1)
        Vd_0[3:6, 0] = self.gravity_vector
        self._set_value_as_process(
            &#34;Qgrav&#34;, lambda: self._get_value(&#34;J&#34;).T*Mb*U*Vd_0)
        if simplify:
            self._start_simplification_process(&#34;Qgrav&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Qgrav&#34;)

        # External Wrench
        Wext = zeros(6*self.n, 1)
        # WEE (t) is the time varying wrench on the EE link.
        Wext[-6:, 0] = WEE
        self._set_value_as_process(
            &#34;Qext&#34;, lambda: self._get_value(&#34;J&#34;).T * Wext)

        # Generalized forces Q
        self._set_value_as_process(
            &#34;Q&#34;, 
            lambda: 
                self._get_value(&#34;M&#34;) * q2d 
                + self._get_value(&#34;C&#34;) * qd 
                + self._get_value(&#34;Qgrav&#34;) 
                + self._get_value(&#34;Qext&#34;)
            )

        if simplify:
            self._start_simplification_process(&#34;Q&#34;, cse)
        elif cse:
            self._start_cse_process(&#34;Q&#34;)

        self._V = self._get_value(&#34;V&#34;)
        self.J = self._get_value(&#34;J&#34;)
        self.M = self._get_value(&#34;M&#34;)
        self.C = self._get_value(&#34;C&#34;)
        self.Qgrav = self._get_value(&#34;Qgrav&#34;)
        self.Q = self._get_value(&#34;Q&#34;)

        try:
            while True:
                self.subex_dict.update(
                    self.queue_dict[&#34;subex_dict&#34;].get(timeout=0.05))
        except queue.Empty:
            pass

        # empty Queues
        for i in self.queue_dict:
            self._flush_queue(self.queue_dict[i])
        self.queue_dict = {}

        # join Processes
        for i in self.process_dict:
            self.process_dict[i].join()
        self.process_dict = {}

        # save used symbols
        for e in self._get_expressions():
            self.all_symbols.update(e.free_symbols)

        print(&#34;Done&#34;)
        return self.Q

    def partial_factor(self, exp: sympy.Expr) -&gt; sympy.Expr:
        &#34;&#34;&#34;Partial factor simplification for sympy expression.

        Args:
            exp (sympy.Expr): sympy expression.

        Returns:
            sympy.Expr: modified sympy expression.
        &#34;&#34;&#34;
        # split up matrices
        if (type(exp) == sympy.matrices.immutable.ImmutableDenseMatrix
            or type(exp) == sympy.matrices.dense.MutableDenseMatrix):
            new_expr = zeros(*exp.shape)
            for i in range(exp.shape[0]):
                for j in range(exp.shape[1]):
                    new_expr[i,j] = self.partial_factor(exp[i,j])
            return new_expr
            
        # seach for factors
        factor_map = defaultdict(set)
        const, additive_terms = exp.as_coeff_add()
        for term1, term2 in combinations(additive_terms, 2):
            common_terms = (
                set(term1.as_coeff_mul()[-1])
                &amp; set(term2.as_coeff_mul()[-1])
            )
            if common_terms:
                common_factor = sympy.Mul(*common_terms)
                factor_map[common_factor] |= {term1, term2}
        
        # sort by number of operations represented by the terms
        factor_list = sorted(
            factor_map.items(),
            key = lambda i: (i[0].count_ops() + 1) * len(i[1])
        )[::-1]

        # rebuild expression
        used = set()
        new_expr = nsimplify(0)
        for item in factor_list:
            factor = item[0]
            appearances = item[-1]
            terms = 0
            for instance in appearances:
                if instance not in used:
                    terms += instance.as_coefficient(factor)
                    used.add(instance)
            new_expr += factor * terms
        for term in set(additive_terms) - used:
            new_expr += term
        return new_expr + const

    def simplify(self, exp: sympy.Expr, cse: bool=False) -&gt; sympy.Expr:
        &#34;&#34;&#34;Faster simplify implementation for sympy expressions.
        Expressions can be different simplified as with sympy.simplify.

        Args:
            exp (sympy expression): 
                Expression to simplify.
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.

        Returns:
            sympy expression: Simplified expression.
        &#34;&#34;&#34;
        if cse:
            exp = self._cse_expression(exp)
        if (type(exp) == sympy.matrices.immutable.ImmutableDenseMatrix
                or type(exp) == sympy.matrices.dense.MutableDenseMatrix):
            # fasten simplification of symmetric matrices
            if exp.is_square:
                # test if matrix is symmetric
                # numeric test is faster than is_symmetric method  for 
                # long expressions
                
                # create matrix with randon values
                num = lambdify(list(exp.free_symbols), exp, &#34;numpy&#34;)(
                    *(random.random() for i in exp.free_symbols))
                # if (random) matrix is symmetric, we have to simplify 
                # less values
                if numpy.allclose(num, num.T):
                    shape = exp.shape
                    m_exp = exp.as_mutable()
                    # simplify values only once in symmetric matrices
                    for i in range(shape[0]):
                        for j in range(i):
                            m_exp[i, j] = self.simplify(exp[i, j])
                            if i != j:
                                m_exp[j, i] = exp[j, i]
                    return Matrix(m_exp)
        if type(exp) == sympy.matrices.dense.MutableDenseMatrix:
            exp = exp.as_immutable()
        exp = fu(exp)  # fast function to simplify sin and cos expressions
        exp = cancel(exp)
        exp = factor(exp)
        exp = powsimp(exp)
        exp = self.partial_factor(exp)
        exp = exp.doit()
        return exp

    def _create_topology_lists(self,robot: URDF) -&gt; None:
        &#34;&#34;&#34;Generate parent, support and child list from URDF.

        Args:
            robot (URDF): URDF of robot.
        &#34;&#34;&#34;
        # names of all links in urdf
        link_names = [link.name for link in robot.links] 
        parent_names = [] # names of parent links corresponding link_names
        connection_type = [] # 0 for fixed, None for base, 1 else
        body_index = [] # index of link; -1 for fixed links
        parent = [] # parent array
        child = [] # child array
        support = [] # support array
        # find parent link names and search for fixed joints
        for name in link_names:
            for joint in robot.joints:
                if joint.child == name:
                    parent_names.append(joint.parent)
                    body_index.append(None) # specify later
                    if joint.joint_type == &#34;fixed&#34;:
                        connection_type.append(0)
                    else:
                        connection_type.append(1)
                    break
            else: # base link
                parent_names.append(None)
                connection_type.append(None)
                body_index.append(0)

        # generate body indices concatenating fixed bodies
        while None in body_index:
            i1 = body_index.index(None) # i of current link
            # update until parent is already specified
            while body_index[link_names.index(parent_names[i1])] is None:
                i1 = link_names.index(parent_names[i1])
            # fixed links get index -1
            if connection_type[i1] == 0:
                body_index[i1] = -1
                continue
            i2 = link_names.index(parent_names[i1]) # i of parent link
            while body_index[i2] == -1: # find forst non fixed parent
                i2 = link_names.index(parent_names[i2])
            index = body_index[i2]+1 # body index
            while index in body_index: # find first unused index
                index+=1
            body_index[i1] = index
            
        parent = [None for _ in range(max(body_index))] 
        child = [[] for _ in range(max(body_index))]
        support = [[] for _ in range(max(body_index))]

        # fill parent, child and support array
        for i in range(len(body_index)):
            idx = body_index[i] # get index of current body
            if idx &lt;= 0: # ignore base and fixed bodys
                continue
            i1 = link_names.index(parent_names[i]) # parent index
            while body_index[i1] == -1: # find first non fixed parent
                i1 = link_names.index(parent_names[i1])
            parent[idx-1] = body_index[i1] # save parent index
            if body_index[i1] &gt; 0: # ignore base
                child[body_index[i1]-1].append(idx) # save child to parent
            i2 = i
            while body_index[i2] != 0: # save all indices in support path
                if  body_index[i2] &gt; 0: # ignore fixed links
                    support[idx-1].append(body_index[i2])
                i2 = link_names.index(parent_names[i2])
            support[idx-1].reverse()
        self.support = support
        self.child = child
        self.parent = parent
            
    def _nsimplify(
        self,num: float, *args, max_denominator: int=0, **kwargs
        ) -&gt; Union[sympy.Expr, float]:
        &#34;&#34;&#34;Find a simple sympy representation for a number like 1/2 
        instead of 0.5. This function extends sympy.nsimplify with a 
        parameter to specify a maximum denominator to avoid simplifications
        like 13/157.  

        Args:
            num (float): number to simplify.
            max_denominator (int, optional): 
                maximum denominator to use. Use 0 to deactivate. 
                Defaults to 0.

        Returns:
            Union[sympy.Expr, float]: simplified number.
        &#34;&#34;&#34;
        ex = nsimplify(num,*args,**kwargs)
        if not max_denominator:
            return ex
        if ex.is_rational:
            try:
                d = ex.denominator
                if d &gt; max_denominator:
                    return num
            except ValueError:
                return ex
        elif type(ex) in {sympy.core.add.Add, sympy.core.power.Pow}:
            return num
        for i in regex.findall(&#34;(?&lt;=Rational\(\d*, )\d*&#34;, sympy.srepr(ex)):
            if abs(int(i)) &gt; max_denominator:
                return num
        return ex
        
    def load_from_urdf(self, path: str, symbolic: bool=True, 
                       cse: bool=False, simplify_numbers: bool=True,  
                       tolerance: float=0.0001, max_denominator: int=9) -&gt; None:
        &#34;&#34;&#34;Load robot from urdf.

        Args:
            path (str): path to URDF.
            symbolic (bool, optional): 
                generate symbols for numeric values. 
                Defaults to True.
            cse (bool, optional): 
                use common subexpression elimination. Defaults to False.
            simplify_numbers (bool, optional): 
                Use eg. pi/2 instead of 1.5708. Defaults to True.
            tolerance (float, optional): 
                tolerance for simplify_numbers. Defaults to 0.0001.
            max_denominator (int, optional): 
                Maximum denominator to use for simplify numbers to avoid
                values like 13/153. Use 0 to deactivate. Defaults to 9.

        Raises:
            NotImplementedError: supports only the joint types 
                &#34;revolute&#34;, &#34;continuous&#34; and &#34;prismatic&#34;.
        &#34;&#34;&#34;        
        with open(path, &#34;r&#34;) as f:
            robot = URDF.from_xml_string(f.read())
        self.B = []
        self.X = []
        self._create_topology_lists(robot) # TODO: check!
        fixed_origin = None
        fixed_links = []
        DOF = 0
        xyz_rpy_syms = []
        for joint in robot.joints:
            if joint.joint_type in [&#34;revolute&#34;, &#34;continuous&#34;, &#34;prismatic&#34;]:
                DOF += 1
            elif joint.joint_type in [&#34;fixed&#34;]:
                pass
            else:
                raise NotImplementedError(
                    &#34;Joint type &#39;&#34; + joint.joint_type+&#34;&#39; not implemented yet!&#34;)

        ji = 0  # joint index of used joints
        jia = 0  # joint index of all joints (fixed included)
        joint_origins = []
        for joint in robot.joints:
            name = joint.name
            origin = xyz_rpy_to_matrix(joint.origin.xyz+joint.origin.rpy)
            if symbolic:
                xyz_rpy = Matrix(joint.origin.xyz+joint.origin.rpy)
                xyz_rpy_syms.append(symbols(
                    &#34; &#34;.join([name+&#34;_%s&#34; % s for s in [&#34;x&#34;, &#34;y&#34;, &#34;z&#34;, &#34;roll&#34;, &#34;pitch&#34;, &#34;yar&#34;]])))
                xyzrpylist = []
                if simplify_numbers:
                    for i in range(6):
                        if (self._nsimplify(xyz_rpy[i], 
                                           tolerance=tolerance, 
                                           max_denominator=max_denominator) 
                            in [0, -1, 1, pi, -pi, pi/2, -pi/2, 3*pi/2, -3*pi/2]
                            ):
                            xyzrpylist.append(
                                self._nsimplify(xyz_rpy[i], tolerance=tolerance,
                                                max_denominator=max_denominator))
                        else:
                            xyzrpylist.append(xyz_rpy_syms[jia][i])
                            self.assignment_dict[xyz_rpy_syms[jia]
                                                 [i]] = xyz_rpy[i]
                else:
                    for i in range(6):
                        if xyz_rpy[i] == 0:
                            xyzrpylist.append(0)
                        elif xyz_rpy[i] == 1:
                            xyzrpylist.append(1)
                        elif xyz_rpy[i] == -1:
                            xyzrpylist.append(-1)
                        else:
                            xyzrpylist.append(xyz_rpy_syms[jia][i])
                            self.assignment_dict[xyz_rpy_syms[jia]
                                                 [i]] = xyz_rpy[i]
                origin = xyz_rpy_to_matrix(xyzrpylist)
                if cse:
                    origin = self._cse_expression(origin)
            elif simplify_numbers:
                for i in range(4):
                    for j in range(4):
                        origin[i, j] = self._nsimplify(
                            origin[i, j], [pi], tolerance=tolerance,
                            max_denominator=max_denominator)
            joint_origins.append(origin)
            if joint.joint_type in [&#34;revolute&#34;, &#34;continuous&#34;, &#34;prismatic&#34;]:
                axis = Matrix(joint.axis)
                if simplify_numbers:
                    for i in range(3):
                        axis[i] = self._nsimplify(axis[i], [pi], tolerance=tolerance,
                                            max_denominator=max_denominator)
                if fixed_origin:
                    origin *= fixed_origin
                    fixed_origin = None
                self.B.append(Matrix(origin))

                if joint.joint_type in [&#34;revolute&#34;, &#34;continuous&#34;]:
                    self.X.append(Matrix(axis).col_join(Matrix([0, 0, 0])))
                else:
                    self.X.append(Matrix(Matrix([0, 0, 0])).col_join(axis))
                ji += 1
            elif joint.joint_type == &#34;fixed&#34;:
                if fixed_origin:
                    fixed_origin *= origin
                else:
                    fixed_origin = origin
                fixed_links.append((joint.parent, joint.child))
            jia += 1

        self.Mb = []
        i = 0
        first_non_fixed = 1
        for link in robot.links:
            name = link.name
            # ignore base link
            if i &lt; first_non_fixed:
                if name in [x[1] for x in fixed_links]:
                    first_non_fixed += 1
                i += 1
                continue
            inertia = Matrix(link.inertial.inertia.to_matrix())
            mass = link.inertial.mass
            inertiaorigin = xyz_rpy_to_matrix(link.inertial.origin.xyz+link.inertial.origin.rpy)
            if symbolic:
                I_syms = symbols(&#34;Ixx_%s Ixy_%s Ixz_%s Iyy_%s Iyz_%s Izz_%s&#34; % (
                    name, name, name, name, name, name))
                c_syms = symbols(&#34;cx_%s cy_%s cz_%s&#34; % (name, name, name))
                I = inertia_matrix(*I_syms)
                m = symbols(&#34;m_%s&#34; % name)
                cg = Matrix([*c_syms])
            else:
                if simplify_numbers:
                    for i in range(4):
                        for j in range(4):
                            inertiaorigin[i, j] = self._nsimplify(
                                inertiaorigin[i, j], [pi], tolerance=tolerance,
                                max_denominator=max_denominator)
                    for i in range(3):
                        for j in range(3):
                            inertia[i, j] = self._nsimplify(
                                inertia[i, j], [pi], tolerance=tolerance,
                                max_denominator=max_denominator)
                I = Matrix(inertia)
                m = mass
                cg = Matrix(inertiaorigin[0:3, 3])
            M = mass_matrix_mixed_data(m, I, cg)
            if name in [x[1] for x in fixed_links]:
                j = i
                # transform Mass matrix
                while robot.links[j].name in [x[1] for x in fixed_links]:
                    M = SE3AdjInvMatrix(
                        joint_origins[j-1]).T * M * SE3AdjInvMatrix(joint_origins[j-1])
                    j -= 1
                self.Mb[-1] += M
                i += 1
                continue
            self.Mb.append(M)
            i += 1
        return

    def dh_to_screw_coord(self, DH_param_table: MutableDenseMatrix) -&gt; None:
        &#34;&#34;&#34;Build screw coordinate paramters (joint axis frames and 
        body reference frames) from a given modified Denavit-Hartenberg 
        (DH) parameter table.
        Joint screw coordinates and reference configurations of bodies 
        are directly applied to class.

        Args:
            DH_param_table (array_like): 
                Table with modified DH parameters (n,5) 
                -&gt; (gamma,alpha,d,theta,r)
        &#34;&#34;&#34;
        number_of_frames = DH_param_table.shape[0]
        self.B = []
        self.X = []
        for i in range(number_of_frames):
            # Reference configurations of bodies (i.e. of body-fixed 
            # reference frames) w.r.t their previous bodies
            # gamma, alpha, d, theta,r
            frame = DH_param_table[i, :]
            gamma = frame[0]
            alpha = frame[1]
            d = frame[2]
            theta = frame[3]
            r = frame[4]
            self.B.append(SO3Exp(Matrix([1, 0, 0]), alpha)
                          .row_join(Matrix([d, 0, 0]))
                          .col_join(Matrix([0, 0, 0, 1]).T)
                          * SO3Exp(Matrix([0, 0, 1]), theta)
                          .row_join(Matrix([0, 0, r]))
                          .col_join(Matrix([0, 0, 0, 1]).T)
                          )

            #  Joint screw coordinates in body-fixed representation
            if gamma == 0:
                self.X.append(Matrix([0, 0, 1, 0, 0, 0]))
            else:
                self.X.append(Matrix([0, 0, 0, 0, 0, 1]))

    def _set_value_as_process(self, name: str, target: Callable) -&gt; None:
        &#34;&#34;&#34;Set return value of target as value to queue in 
        self.queue_dict with identifier name.

        Args:
            name (str): Identifier.
            target (function): function, which returns value. 
        &#34;&#34;&#34;
        if name not in self.queue_dict:
            self.queue_dict[name] = Queue()
        if name in self.process_dict:
            print(&#34;already there&#34;)
        self.process_dict[name] = Process(
            target=lambda: self._set_value(name, target()), args=(), name=name)
        self.process_dict[name].start()

    def _set_value(self, name: str, var: Any) -&gt; None:
        &#34;&#34;&#34;Set value to queue in self.queue_dict.

        Args:
            name (str): Identifier.
            var (any): Value to save.
        &#34;&#34;&#34;
        if name not in self.queue_dict:
            self.queue_dict[name] = Queue()
        self.queue_dict[name].put(var)

    def _start_simplification_process(
        self, name: str, cse: bool=False) -&gt; None:
        &#34;&#34;&#34;Start Process, which simplifies and overwrites value in 
        queue from self.queue_dict.

        Args:
            name (str): Identifier
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.
        &#34;&#34;&#34;
        if name not in self.queue_dict:
            self.queue_dict[name] = Queue()
        self.process_dict[name+&#34;_simplify&#34;] = Process(
            target=self._simplify_parallel, 
            args=(name, cse,), 
            name=name+&#34;_simplify&#34;)
        self.process_dict[name+&#34;_simplify&#34;].start()

    def _start_cse_process(self, name: str) -&gt; None:
        &#34;&#34;&#34;Start Process, which generates cse expression and overwrites value in 
        queue from self.queue_dict.

        Args:
            name (str): Identifier
        &#34;&#34;&#34;
        if name not in self.queue_dict:
            self.queue_dict[name] = Queue()
        self.process_dict[name+&#34;_cse&#34;] = Process(
            target=self._cse_parallel, 
            args=(name,), 
            name=name+&#34;_cse&#34;)
        self.process_dict[name+&#34;_cse&#34;].start()

    def _get_value(self, name: str) -&gt; Any:
        &#34;&#34;&#34;Get value from queue in self.queue_dict and put it in again.

        Args:
            name (str): Identifier.

        Returns:
            any: Value
        &#34;&#34;&#34;
        value = self.queue_dict[name].get()
        self.queue_dict[name].put(value)
        return value

    def _simplify_parallel(self, name: str, cse: bool=False) -&gt; None:
        &#34;&#34;&#34;Take value from self.queue_dict, simplify it and put it in 
        again.

        Args:
            name (str): Identifier
            cse (bool, optional): 
                Use common subexpression elimination. Defaults to False.
        &#34;&#34;&#34;
        value = self.simplify(self.queue_dict[name].get(), cse)
        self.queue_dict[name].put(value)
        
    def _cse_parallel(self, name: str) -&gt; None:
        &#34;&#34;&#34;Take value from self.queue_dict, generate cse_expressions and 
        put it in again.

        Args:
            name (str): Identifier
        &#34;&#34;&#34;
        value = self._cse_expression(self.queue_dict[name].get())
        self.queue_dict[name].put(value)

    def _flush_queue(self, q: Queue) -&gt; None:
        &#34;&#34;&#34;Flush all items in queue

        Args:
            q (Queue): Queue to flush
        &#34;&#34;&#34;
        try:
            while True:
                q.get(block=False)
        except queue.Empty:
            pass

    def _individual_numbered_symbols(
        self, exclude: list=[], i: List[int]=[0]) -&gt; Generator[sympy.Symbol, None, None]:
        &#34;&#34;&#34;create individual symbol names for subexpressions using 
        multiprocessing.

        Args:
            exclude (list, optional): 
                List of names, which should not be used. Defaults to [].
            i (list, optional): 
                List with starting value -1 as first value. Is used as 
                counter and should not be set. Defaults to [0].

        Returns:
            sympy.numbered_symbols:  Symbols
        &#34;&#34;&#34;
        i[0] += 1
        prefix=&#34;sub%s_%s_&#34; % (
            &#34;_&#34;.join([str(j) for j in multiprocessing.current_process()._identity]), 
            i[0]
            )
        prefix = prefix.replace(&#34;sub_&#34;,&#34;sub0_&#34;)
        return numbered_symbols(
            prefix=prefix, 
            exclude=exclude)

    def _sort_variables(self, vars:List[sympy.Symbol]) -&gt; List[sympy.Symbol]:
        &#34;&#34;&#34;Sort variables for code generation starting with q, qd, qdd, 
        continuing with variable symbols and ending with constant 
        symbols.

        Args:
            vars (list of sympy.symbols): Variables to sort.

        Returns:
            list: Sorted list of variables.
        &#34;&#34;&#34;
        # vars as set
        vars = set(vars)
        # divide into variable and constant symbols
        var_syms = self.var_syms.intersection(vars)
        optional_var_syms = self.optional_var_syms.intersection(vars)
        rest = list(vars.difference(var_syms).difference(optional_var_syms))
        # divide variable symbols into q, dq, ddq and other variable symbols
        q = []
        dq = []
        ddq = []
        var_rest = []
        opt_var = []
        for i in var_syms:
            if str(i).startswith(&#34;ddq&#34;):
                ddq.append(i)
            elif str(i).startswith(&#34;dq&#34;):
                dq.append(i)
            elif str(i).startswith(&#34;q&#34;):
                q.append(i)
            else:
                var_rest.append(i)
                
        for i in optional_var_syms:  
            opt_var.append(i)
            
        def symsort(data: List[sympy.Symbol]) -&gt; List[sympy.Symbol]:
            &#34;&#34;&#34;Sort symbols

            Args:
                data (list): symbols

            Returns:
                list: sorted symbols
            &#34;&#34;&#34;
            return [x for _, x in sorted(zip(list(map(str, data)), data))]
        
        # return sorted list
        return (symsort(q) 
                + symsort(dq) 
                + symsort(ddq) 
                + symsort(var_rest) 
                + symsort(opt_var) 
                + symsort(rest))

    def _cse_expression(self, exp: sympy.Expr) -&gt; sympy.Expr:
        &#34;&#34;&#34;Use common subexpression elimination to shorten expression.
        The used subexpressions are saved to the class internal 
        subex_dict.

        Args:
            exp (Sympy expression): Expression to shorten using cse.

        Returns:
            Sympy expression: Shortened expression.
        &#34;&#34;&#34;
        # cse expression
        r, e = sympy.cse([exp, exp], self._individual_numbered_symbols(
            exclude=self.all_symbols), order=&#34;canonical&#34;, ignore=self.var_syms)
        # add subexpressions to dict
        for (sym, val) in r:
            self.subex_dict[sym] = val
            # for multiprocessing save in queue
            try:
                self.queue_dict[&#34;subex_dict&#34;].put(self.subex_dict)
            except:
                pass
            # update used symbols
            self.all_symbols.update({sym})
        return e[0]

    def _get_expressions(self) -&gt; List[sympy.Expr]:
        &#34;&#34;&#34;Get list of all generated expressions.

        Returns:
            list: generated expressions.
        &#34;&#34;&#34;
        expression_dict = self.get_expressions_dict()
        expressions = [expression_dict[i] for i in expression_dict]
        return expressions

    def _calc_A_matrix(
        self, q: MutableDenseMatrix
        ) -&gt; Tuple[List[MutableDenseMatrix], MutableDenseMatrix]:
        &#34;&#34;&#34;Calculate forward kinematics and the block diagonal matrix 
        A (6n x 6n) of the Adjoint of body frame for serial robots.

        Args:
            q (sympy.MutableDenseMatrix): 
                Generalized position vector.

        Raises:
            ValueError: 
                Joint screw coordinates or body reference configuration 
                not found.

        Returns:
            Tuple[List[MutableDenseMatrix], MutableDenseMatrix]: (FK, A)
        &#34;&#34;&#34;
        # calc Forward kinematics
        if self._FK_C is not None:
            FK_C = self._FK_C
        elif self.A:
            # print(&#34;Using absolute configuration (A) of the body frames&#34;)
            FK_f = [SE3Exp(self.Y[0], q[0])]
            FK_C = [FK_f[0]*self.A[0]]
            for i in range(1, self.n):
                FK_f.append(FK_f[i-1]*SE3Exp(self.Y[i], q[i]))
                FK_C.append(FK_f[i]*self.A[i])
            self._FK_C = FK_C
            if not self.X:
                # Joint screw coordinates in body-fixed representation 
                # computed from screw coordinates in IFR
                self.X = [SE3AdjInvMatrix(
                    self.A[i])*self.Y[i] for i in range(self.n)]

        elif self.B:
            # print(&#39;Using relative configuration (B) of the body frames&#39;)
            FK_C = [self.B[0]*SE3Exp(self.X[0], q[0])]
            for i in range(1, self.n):
                FK_C.append(FK_C[i-1]*self.B[i]*SE3Exp(self.X[i], q[i]))
            self._FK_C = FK_C
        else:
            # &#39;Absolute (A) or Relative (B) configuration of the bodies should be provided in class!&#39;
            raise ValueError(&#34;Joint screw coordinates and/or reference configuration of bodies not set.&#34;)

        # Block diagonal matrix A (6n x 6n) of the Adjoint of body frame
        if self._A is not None:
            A = self._A
        else:
            A = Matrix(Identity(6*self.n))
            for i in range(self.n):
                for j in range(i):
                    Crel = SE3Inv(FK_C[i])*FK_C[j]
                    AdCrel = SE3AdjMatrix(Crel)
                    r = 6*(i)
                    c = 6*(j)
                    A[r:r+6, c:c+6] = AdCrel
            self._A = A
        return FK_C, A

    def _calc_A_matrix_tree(self, q: MutableDenseMatrix):
        &#34;&#34;&#34;Calculate forward kinematics and the block diagonal matrix 
        A (6n x 6n) of the Adjoint of body frame for tree like robot 
        structures.

        Args:
            q (sympy.MutableDenseMatrix): 
                Generalized position vector.

        Raises:
            ValueError: 
                Joint screw coordinates or body reference configuration 
                not found.

        Returns:
            Tuple[List[MutableDenseMatrix], MutableDenseMatrix]: (FK, A)
        &#34;&#34;&#34;
        if self._FK_C is not None:
            FK_C = self._FK_C
        elif self.A:
            # print(&#34;Using absolute configuration (A) of the body frames&#34;)
            FK_f = []
            FK_C = []
            for i in range(self.n):
                if self.parent[i] == 0: # bodies with no predecessor
                    # Initialization for the first body
                    FK_f.append(SE3Exp(self.Y[i], q[i]))
                    FK_C.append(FK_f[i]*self.A[i])
                else:
                    FK_f.append(FK_f[self.parent[i]-1]*SE3Exp(self.Y[i], q[i]))
                    FK_C.append(FK_f[i]*self.A[i])      
            self._FK_C = FK_C
            if not self.X:
                # Joint screw coordinates in body-fixed representation 
                # computed from screw coordinates in IFR
                self.X = [SE3AdjInvMatrix(
                    self.A[i])*self.Y[i] for i in range(self.n)]

        elif self.B:
            # print(&#39;Using relative configuration (B) of the body frames&#39;)
            FK_C = []
            for i in range(self.n):
                if self.parent[i] == 0: # bodies with no predecessor
                    # Initialization for the first body
                    FK_C.append(self.B[i]*SE3Exp(self.X[i], q[i]))
                else:
                    FK_C.append(FK_C[self.parent[i]-1]*self.B[i]*SE3Exp(self.X[i], q[i]))
        else:
            # &#39;Absolute (A) or Relative (B) configuration of the bodies should be provided in class!&#39;
            raise ValueError(&#34;Joint screw coordinates and/or reference configuration of bodies not set.&#34;)

        # Block diagonal matrix A (6n x 6n) of the Adjoint of body frame
        if self._A is not None:
            A = self._A
        else:
            A = Matrix(Identity(6*self.n))
            for i in range(self.n):        
                if True:
                # if self.parent[i] != 0:
                    for k in self.support[i]:
                        j = k-1
                        Crel = SE3Inv(FK_C[i])*FK_C[j]
                        AdCrel = SE3AdjMatrix(Crel)
                        r = 6*(i)
                        c = 6*(j)
                        A[r:r+6, c:c+6] = AdCrel
            self._A = A
        return FK_C, A
    
    def _find_start_index(self) -&gt; int:
        &#34;&#34;&#34;Guess if 0 or 1 is the first index in the robot by analysing 
        used variable names.

        Returns:
            int: index.
        &#34;&#34;&#34;
        # search all symbols
        syms = set()
        for i in self.Mb:
            syms.update(i.free_symbols)
        for i in self.body_ref_config:
            syms.update(i.free_symbols)
        for i in self.joint_screw_coord:
            syms.update(i.free_symbols)
        # search all indices in symbols
        indices = []
        for i in syms:
            indices.extend(regex.findall(&#34;\d+&#34;,str(i)))
        #find smalles used index
        if indices:
            if min([int(i) for i in indices]) == 0:
                return 0
            if max([int(i) for i in indices]) == self.n -1:
                return 0
        return 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>skidy.kinematics_generator._AbstractCodeGeneration</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="skidy.kinematics_generator.SymbolicKinDyn.BODY_FIXED"><code class="name">var <span class="ident">BODY_FIXED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="skidy.kinematics_generator.SymbolicKinDyn.SPATIAL"><code class="name">var <span class="ident">SPATIAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="skidy.kinematics_generator.SymbolicKinDyn.body_ref_config"><code class="name">var <span class="ident">body_ref_config</span> : list</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def body_ref_config(self) -&gt; list:
    if self.config_representation == self.BODY_FIXED:
        return self.B
    elif self.config_representation == self.SPATIAL:
        return self.A</code></pre>
</details>
</dd>
<dt id="skidy.kinematics_generator.SymbolicKinDyn.config_representation"><code class="name">var <span class="ident">config_representation</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def config_representation(self) -&gt; str:
    return self._config_representation</code></pre>
</details>
</dd>
<dt id="skidy.kinematics_generator.SymbolicKinDyn.joint_screw_coord"><code class="name">var <span class="ident">joint_screw_coord</span> : list</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def joint_screw_coord(self) -&gt; list:
    if self.config_representation == self.BODY_FIXED:
        return self.X
    elif self.config_representation == self.SPATIAL:
        return self.Y</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="skidy.kinematics_generator.SymbolicKinDyn.closed_form_inv_dyn_body_fixed"><code class="name flex">
<span>def <span class="ident">closed_form_inv_dyn_body_fixed</span></span>(<span>self, q: sympy.matrices.dense.MutableDenseMatrix = None, qd: sympy.matrices.dense.MutableDenseMatrix = None, q2d: sympy.matrices.dense.MutableDenseMatrix = None, WEE: sympy.matrices.dense.MutableDenseMatrix = Ellipsis, simplify: bool = True, cse: bool = False, parallel: bool = True) ‑> sympy.matrices.dense.MutableDenseMatrix</span>
</code></dt>
<dd>
<div class="desc"><p>Inverse dynamics using body fixed representation of the
twists in closed form. </p>
<p>The following expressions are saved in the class and can be
code generated afterwards:
coriolis_centrifugal_matrix
generalized_mass_inertia_matrix
gravity_vector
inverse_dynamics</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>q</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(n,1) Generalized position vector. Defaults to None.</dd>
<dt><strong><code>qd</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(n,1) Generalized velocity vector. Defaults to None.</dd>
<dt><strong><code>q2d</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(n,1) Generalized acceleration vector. Defaults to None.</dd>
<dt><strong><code>WEE</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time varying
wrench on the EE link.
Defaults to zeros(6, 1).</dd>
<dt><strong><code>simplify</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Use simplify command on saved expressions.
Defaults to True.</dd>
<dt><strong><code>cse</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Use common subexpression elimination. Defaults to False.</dd>
<dt><strong><code>parallel</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Use parallel computation via multiprocessing.
Defaults to True.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ValueError:
Joint screw coordinates and/or reference configuration
of bodies not set.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy.Matrix</code></dt>
<dd>Generalized forces</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closed_form_inv_dyn_body_fixed(
    self, q:sympy.MutableDenseMatrix=None, qd: MutableDenseMatrix=None, 
    q2d: MutableDenseMatrix=None, WEE: MutableDenseMatrix=..., 
    simplify: bool=True, cse: bool=False, 
    parallel: bool=True) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Inverse dynamics using body fixed representation of the 
    twists in closed form. 

    The following expressions are saved in the class and can be 
    code generated afterwards:
        coriolis_centrifugal_matrix
        generalized_mass_inertia_matrix
        gravity_vector
        inverse_dynamics

    Args:
        q (sympy.Matrix, optional): 
            (n,1) Generalized position vector. Defaults to None.
        qd (sympy.Matrix, optional): 
            (n,1) Generalized velocity vector. Defaults to None.
        q2d (sympy.Matrix, optional): 
            (n,1) Generalized acceleration vector. Defaults to None.
        WEE (sympy.Matrix, optional): 
            (6,1) WEE (t) = [Mx,My,Mz,Fx,Fy,Fz] is the time varying 
            wrench on the EE link. 
            Defaults to zeros(6, 1).
        simplify (bool, optional): 
            Use simplify command on saved expressions. 
            Defaults to True.
        cse (bool, optional): 
            Use common subexpression elimination. Defaults to False.
        parallel (bool, optional): 
            Use parallel computation via multiprocessing. 
            Defaults to True.

    Raises:
        ValueError:
            Joint screw coordinates and/or reference configuration 
            of bodies not set.
    
    Returns:
        sympy.Matrix: Generalized forces
    &#34;&#34;&#34;
    if not q or not qd or not q2d:
        if not self.n:
            self.n = len(self.body_ref_config)
        if not self.q or not self.qd or not self.q2d:
            q, qd, q2d = generalized_vectors(self.n,self._find_start_index())
        else:
            q, qd, q2d = self.q, self.qd, self.q2d
    
    if WEE is Ellipsis:
        WEE = self.WEE
        
    if parallel:
        self._closed_form_inv_dyn_body_fixed_parallel(
            q, qd, q2d, WEE, simplify, cse)
    else:
        self._closed_form_inv_dyn_body_fixed(
            q, qd, q2d, WEE, simplify, cse)
    return self.Q</code></pre>
</details>
</dd>
<dt id="skidy.kinematics_generator.SymbolicKinDyn.closed_form_kinematics_body_fixed"><code class="name flex">
<span>def <span class="ident">closed_form_kinematics_body_fixed</span></span>(<span>self, q: sympy.matrices.dense.MutableDenseMatrix = None, qd: sympy.matrices.dense.MutableDenseMatrix = None, q2d: sympy.matrices.dense.MutableDenseMatrix = None, simplify: bool = True, cse: bool = False, parallel: bool = True) ‑> sympy.matrices.dense.MutableDenseMatrix</span>
</code></dt>
<dd>
<div class="desc"><p>Position, Velocity and Acceleration Kinematics using Body
fixed representation of the twists in closed form.</p>
<p>The following expressions are saved in the class and can be
code generated afterwards:</p>
<pre><code>body_acceleration
body_acceleration_ee
body_jacobian_matrix
body_jacobian_matrix_dot 
body_jacobian_matrix_ee
body_jacobian_matrix_ee_dot
body_twist_ee
forward_kinematics
hybrid_acceleration
hybrid_acceleration_ee
hybrid_jacobian_matrix
hybrid_jacobian_matrix_dot
hybrid_jacobian_matrix_ee
hybrid_jacobian_matrix_ee_dot
hybrid_twist_ee
</code></pre>
<p>Needs class parameters body_ref_config, joint_screw_coord and ee
to be defined.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>q</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(n,1) Generalized position vector. Defaults to None.</dd>
<dt><strong><code>qd</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(n,1) Generalized velocity vector. Defaults to None.</dd>
<dt><strong><code>q2d</code></strong> :&ensp;<code>sympy.Matrix</code>, optional</dt>
<dd>(n,1) Generalized acceleration vector. Defaults to None.</dd>
<dt><strong><code>simplify</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Use simplify command on saved expressions.
Defaults to True.</dd>
<dt><strong><code>cse</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Use common subexpression elimination. Defaults to False.</dd>
<dt><strong><code>parallel</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Use parallel computation via multiprocessing.
Defaults to True.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ValueError:
Joint screw coordinates and/or reference configuration
of bodies not set.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy.Matrix</code></dt>
<dd>Forward kinematics.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closed_form_kinematics_body_fixed(
    self, q:sympy.MutableDenseMatrix=None, qd: MutableDenseMatrix=None, 
    q2d: MutableDenseMatrix=None, simplify: bool=True, 
    cse: bool=False, parallel: bool=True) -&gt; MutableDenseMatrix:
    &#34;&#34;&#34;Position, Velocity and Acceleration Kinematics using Body 
    fixed representation of the twists in closed form.

    The following expressions are saved in the class and can be 
    code generated afterwards:
    
        body_acceleration
        body_acceleration_ee
        body_jacobian_matrix
        body_jacobian_matrix_dot 
        body_jacobian_matrix_ee
        body_jacobian_matrix_ee_dot
        body_twist_ee
        forward_kinematics
        hybrid_acceleration
        hybrid_acceleration_ee
        hybrid_jacobian_matrix
        hybrid_jacobian_matrix_dot
        hybrid_jacobian_matrix_ee
        hybrid_jacobian_matrix_ee_dot
        hybrid_twist_ee

    Needs class parameters body_ref_config, joint_screw_coord and ee 
    to be defined.

    Args:
        q (sympy.Matrix, optional): 
            (n,1) Generalized position vector. Defaults to None.
        qd (sympy.Matrix, optional): 
            (n,1) Generalized velocity vector. Defaults to None.
        q2d (sympy.Matrix, optional): 
            (n,1) Generalized acceleration vector. Defaults to None.
        simplify (bool, optional): 
            Use simplify command on saved expressions. 
            Defaults to True.
        cse (bool, optional): 
            Use common subexpression elimination. Defaults to False.
        parallel (bool, optional): 
            Use parallel computation via multiprocessing. 
            Defaults to True.
    Raises:
        ValueError:
            Joint screw coordinates and/or reference configuration 
            of bodies not set.
            
    Returns:
        sympy.Matrix: Forward kinematics.
    &#34;&#34;&#34;
    if not q or not qd or not q2d:
        if not self.n:
            self.n = len(self.body_ref_config)
        if not self.q or not self.qd or not self.q2d:
            q, qd, q2d = generalized_vectors(self.n,self._find_start_index())
        else:
            q, qd, q2d = self.q, self.qd, self.q2d
        
    if parallel:
        self._closed_form_kinematics_body_fixed_parallel(
            q, qd, q2d, simplify, cse)
    else:
        self._closed_form_kinematics_body_fixed(
            q, qd, q2d, simplify, cse)
    return self.fkin</code></pre>
</details>
</dd>
<dt id="skidy.kinematics_generator.SymbolicKinDyn.dh_to_screw_coord"><code class="name flex">
<span>def <span class="ident">dh_to_screw_coord</span></span>(<span>self, DH_param_table: sympy.matrices.dense.MutableDenseMatrix) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Build screw coordinate paramters (joint axis frames and
body reference frames) from a given modified Denavit-Hartenberg
(DH) parameter table.
Joint screw coordinates and reference configurations of bodies
are directly applied to class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>DH_param_table</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Table with modified DH parameters (n,5)
-&gt; (gamma,alpha,d,theta,r)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dh_to_screw_coord(self, DH_param_table: MutableDenseMatrix) -&gt; None:
    &#34;&#34;&#34;Build screw coordinate paramters (joint axis frames and 
    body reference frames) from a given modified Denavit-Hartenberg 
    (DH) parameter table.
    Joint screw coordinates and reference configurations of bodies 
    are directly applied to class.

    Args:
        DH_param_table (array_like): 
            Table with modified DH parameters (n,5) 
            -&gt; (gamma,alpha,d,theta,r)
    &#34;&#34;&#34;
    number_of_frames = DH_param_table.shape[0]
    self.B = []
    self.X = []
    for i in range(number_of_frames):
        # Reference configurations of bodies (i.e. of body-fixed 
        # reference frames) w.r.t their previous bodies
        # gamma, alpha, d, theta,r
        frame = DH_param_table[i, :]
        gamma = frame[0]
        alpha = frame[1]
        d = frame[2]
        theta = frame[3]
        r = frame[4]
        self.B.append(SO3Exp(Matrix([1, 0, 0]), alpha)
                      .row_join(Matrix([d, 0, 0]))
                      .col_join(Matrix([0, 0, 0, 1]).T)
                      * SO3Exp(Matrix([0, 0, 1]), theta)
                      .row_join(Matrix([0, 0, r]))
                      .col_join(Matrix([0, 0, 0, 1]).T)
                      )

        #  Joint screw coordinates in body-fixed representation
        if gamma == 0:
            self.X.append(Matrix([0, 0, 1, 0, 0, 0]))
        else:
            self.X.append(Matrix([0, 0, 0, 0, 0, 1]))</code></pre>
</details>
</dd>
<dt id="skidy.kinematics_generator.SymbolicKinDyn.load_from_urdf"><code class="name flex">
<span>def <span class="ident">load_from_urdf</span></span>(<span>self, path: str, symbolic: bool = True, cse: bool = False, simplify_numbers: bool = True, tolerance: float = 0.0001, max_denominator: int = 9) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Load robot from urdf.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>path to URDF.</dd>
<dt><strong><code>symbolic</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>generate symbols for numeric values.
Defaults to True.</dd>
<dt><strong><code>cse</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>use common subexpression elimination. Defaults to False.</dd>
<dt><strong><code>simplify_numbers</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Use eg. pi/2 instead of 1.5708. Defaults to True.</dd>
<dt><strong><code>tolerance</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>tolerance for simplify_numbers. Defaults to 0.0001.</dd>
<dt><strong><code>max_denominator</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum denominator to use for simplify numbers to avoid
values like 13/153. Use 0 to deactivate. Defaults to 9.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>supports only the joint types
"revolute", "continuous" and "prismatic".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_from_urdf(self, path: str, symbolic: bool=True, 
                   cse: bool=False, simplify_numbers: bool=True,  
                   tolerance: float=0.0001, max_denominator: int=9) -&gt; None:
    &#34;&#34;&#34;Load robot from urdf.

    Args:
        path (str): path to URDF.
        symbolic (bool, optional): 
            generate symbols for numeric values. 
            Defaults to True.
        cse (bool, optional): 
            use common subexpression elimination. Defaults to False.
        simplify_numbers (bool, optional): 
            Use eg. pi/2 instead of 1.5708. Defaults to True.
        tolerance (float, optional): 
            tolerance for simplify_numbers. Defaults to 0.0001.
        max_denominator (int, optional): 
            Maximum denominator to use for simplify numbers to avoid
            values like 13/153. Use 0 to deactivate. Defaults to 9.

    Raises:
        NotImplementedError: supports only the joint types 
            &#34;revolute&#34;, &#34;continuous&#34; and &#34;prismatic&#34;.
    &#34;&#34;&#34;        
    with open(path, &#34;r&#34;) as f:
        robot = URDF.from_xml_string(f.read())
    self.B = []
    self.X = []
    self._create_topology_lists(robot) # TODO: check!
    fixed_origin = None
    fixed_links = []
    DOF = 0
    xyz_rpy_syms = []
    for joint in robot.joints:
        if joint.joint_type in [&#34;revolute&#34;, &#34;continuous&#34;, &#34;prismatic&#34;]:
            DOF += 1
        elif joint.joint_type in [&#34;fixed&#34;]:
            pass
        else:
            raise NotImplementedError(
                &#34;Joint type &#39;&#34; + joint.joint_type+&#34;&#39; not implemented yet!&#34;)

    ji = 0  # joint index of used joints
    jia = 0  # joint index of all joints (fixed included)
    joint_origins = []
    for joint in robot.joints:
        name = joint.name
        origin = xyz_rpy_to_matrix(joint.origin.xyz+joint.origin.rpy)
        if symbolic:
            xyz_rpy = Matrix(joint.origin.xyz+joint.origin.rpy)
            xyz_rpy_syms.append(symbols(
                &#34; &#34;.join([name+&#34;_%s&#34; % s for s in [&#34;x&#34;, &#34;y&#34;, &#34;z&#34;, &#34;roll&#34;, &#34;pitch&#34;, &#34;yar&#34;]])))
            xyzrpylist = []
            if simplify_numbers:
                for i in range(6):
                    if (self._nsimplify(xyz_rpy[i], 
                                       tolerance=tolerance, 
                                       max_denominator=max_denominator) 
                        in [0, -1, 1, pi, -pi, pi/2, -pi/2, 3*pi/2, -3*pi/2]
                        ):
                        xyzrpylist.append(
                            self._nsimplify(xyz_rpy[i], tolerance=tolerance,
                                            max_denominator=max_denominator))
                    else:
                        xyzrpylist.append(xyz_rpy_syms[jia][i])
                        self.assignment_dict[xyz_rpy_syms[jia]
                                             [i]] = xyz_rpy[i]
            else:
                for i in range(6):
                    if xyz_rpy[i] == 0:
                        xyzrpylist.append(0)
                    elif xyz_rpy[i] == 1:
                        xyzrpylist.append(1)
                    elif xyz_rpy[i] == -1:
                        xyzrpylist.append(-1)
                    else:
                        xyzrpylist.append(xyz_rpy_syms[jia][i])
                        self.assignment_dict[xyz_rpy_syms[jia]
                                             [i]] = xyz_rpy[i]
            origin = xyz_rpy_to_matrix(xyzrpylist)
            if cse:
                origin = self._cse_expression(origin)
        elif simplify_numbers:
            for i in range(4):
                for j in range(4):
                    origin[i, j] = self._nsimplify(
                        origin[i, j], [pi], tolerance=tolerance,
                        max_denominator=max_denominator)
        joint_origins.append(origin)
        if joint.joint_type in [&#34;revolute&#34;, &#34;continuous&#34;, &#34;prismatic&#34;]:
            axis = Matrix(joint.axis)
            if simplify_numbers:
                for i in range(3):
                    axis[i] = self._nsimplify(axis[i], [pi], tolerance=tolerance,
                                        max_denominator=max_denominator)
            if fixed_origin:
                origin *= fixed_origin
                fixed_origin = None
            self.B.append(Matrix(origin))

            if joint.joint_type in [&#34;revolute&#34;, &#34;continuous&#34;]:
                self.X.append(Matrix(axis).col_join(Matrix([0, 0, 0])))
            else:
                self.X.append(Matrix(Matrix([0, 0, 0])).col_join(axis))
            ji += 1
        elif joint.joint_type == &#34;fixed&#34;:
            if fixed_origin:
                fixed_origin *= origin
            else:
                fixed_origin = origin
            fixed_links.append((joint.parent, joint.child))
        jia += 1

    self.Mb = []
    i = 0
    first_non_fixed = 1
    for link in robot.links:
        name = link.name
        # ignore base link
        if i &lt; first_non_fixed:
            if name in [x[1] for x in fixed_links]:
                first_non_fixed += 1
            i += 1
            continue
        inertia = Matrix(link.inertial.inertia.to_matrix())
        mass = link.inertial.mass
        inertiaorigin = xyz_rpy_to_matrix(link.inertial.origin.xyz+link.inertial.origin.rpy)
        if symbolic:
            I_syms = symbols(&#34;Ixx_%s Ixy_%s Ixz_%s Iyy_%s Iyz_%s Izz_%s&#34; % (
                name, name, name, name, name, name))
            c_syms = symbols(&#34;cx_%s cy_%s cz_%s&#34; % (name, name, name))
            I = inertia_matrix(*I_syms)
            m = symbols(&#34;m_%s&#34; % name)
            cg = Matrix([*c_syms])
        else:
            if simplify_numbers:
                for i in range(4):
                    for j in range(4):
                        inertiaorigin[i, j] = self._nsimplify(
                            inertiaorigin[i, j], [pi], tolerance=tolerance,
                            max_denominator=max_denominator)
                for i in range(3):
                    for j in range(3):
                        inertia[i, j] = self._nsimplify(
                            inertia[i, j], [pi], tolerance=tolerance,
                            max_denominator=max_denominator)
            I = Matrix(inertia)
            m = mass
            cg = Matrix(inertiaorigin[0:3, 3])
        M = mass_matrix_mixed_data(m, I, cg)
        if name in [x[1] for x in fixed_links]:
            j = i
            # transform Mass matrix
            while robot.links[j].name in [x[1] for x in fixed_links]:
                M = SE3AdjInvMatrix(
                    joint_origins[j-1]).T * M * SE3AdjInvMatrix(joint_origins[j-1])
                j -= 1
            self.Mb[-1] += M
            i += 1
            continue
        self.Mb.append(M)
        i += 1
    return</code></pre>
</details>
</dd>
<dt id="skidy.kinematics_generator.SymbolicKinDyn.partial_factor"><code class="name flex">
<span>def <span class="ident">partial_factor</span></span>(<span>self, exp: sympy.core.expr.Expr) ‑> sympy.core.expr.Expr</span>
</code></dt>
<dd>
<div class="desc"><p>Partial factor simplification for sympy expression.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>exp</code></strong> :&ensp;<code>sympy.Expr</code></dt>
<dd>sympy expression.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy.Expr</code></dt>
<dd>modified sympy expression.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partial_factor(self, exp: sympy.Expr) -&gt; sympy.Expr:
    &#34;&#34;&#34;Partial factor simplification for sympy expression.

    Args:
        exp (sympy.Expr): sympy expression.

    Returns:
        sympy.Expr: modified sympy expression.
    &#34;&#34;&#34;
    # split up matrices
    if (type(exp) == sympy.matrices.immutable.ImmutableDenseMatrix
        or type(exp) == sympy.matrices.dense.MutableDenseMatrix):
        new_expr = zeros(*exp.shape)
        for i in range(exp.shape[0]):
            for j in range(exp.shape[1]):
                new_expr[i,j] = self.partial_factor(exp[i,j])
        return new_expr
        
    # seach for factors
    factor_map = defaultdict(set)
    const, additive_terms = exp.as_coeff_add()
    for term1, term2 in combinations(additive_terms, 2):
        common_terms = (
            set(term1.as_coeff_mul()[-1])
            &amp; set(term2.as_coeff_mul()[-1])
        )
        if common_terms:
            common_factor = sympy.Mul(*common_terms)
            factor_map[common_factor] |= {term1, term2}
    
    # sort by number of operations represented by the terms
    factor_list = sorted(
        factor_map.items(),
        key = lambda i: (i[0].count_ops() + 1) * len(i[1])
    )[::-1]

    # rebuild expression
    used = set()
    new_expr = nsimplify(0)
    for item in factor_list:
        factor = item[0]
        appearances = item[-1]
        terms = 0
        for instance in appearances:
            if instance not in used:
                terms += instance.as_coefficient(factor)
                used.add(instance)
        new_expr += factor * terms
    for term in set(additive_terms) - used:
        new_expr += term
    return new_expr + const</code></pre>
</details>
</dd>
<dt id="skidy.kinematics_generator.SymbolicKinDyn.simplify"><code class="name flex">
<span>def <span class="ident">simplify</span></span>(<span>self, exp: sympy.core.expr.Expr, cse: bool = False) ‑> sympy.core.expr.Expr</span>
</code></dt>
<dd>
<div class="desc"><p>Faster simplify implementation for sympy expressions.
Expressions can be different simplified as with sympy.simplify.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>exp</code></strong> :&ensp;<code>sympy expression</code></dt>
<dd>Expression to simplify.</dd>
<dt><strong><code>cse</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Use common subexpression elimination. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy expression</code></dt>
<dd>Simplified expression.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplify(self, exp: sympy.Expr, cse: bool=False) -&gt; sympy.Expr:
    &#34;&#34;&#34;Faster simplify implementation for sympy expressions.
    Expressions can be different simplified as with sympy.simplify.

    Args:
        exp (sympy expression): 
            Expression to simplify.
        cse (bool, optional): 
            Use common subexpression elimination. Defaults to False.

    Returns:
        sympy expression: Simplified expression.
    &#34;&#34;&#34;
    if cse:
        exp = self._cse_expression(exp)
    if (type(exp) == sympy.matrices.immutable.ImmutableDenseMatrix
            or type(exp) == sympy.matrices.dense.MutableDenseMatrix):
        # fasten simplification of symmetric matrices
        if exp.is_square:
            # test if matrix is symmetric
            # numeric test is faster than is_symmetric method  for 
            # long expressions
            
            # create matrix with randon values
            num = lambdify(list(exp.free_symbols), exp, &#34;numpy&#34;)(
                *(random.random() for i in exp.free_symbols))
            # if (random) matrix is symmetric, we have to simplify 
            # less values
            if numpy.allclose(num, num.T):
                shape = exp.shape
                m_exp = exp.as_mutable()
                # simplify values only once in symmetric matrices
                for i in range(shape[0]):
                    for j in range(i):
                        m_exp[i, j] = self.simplify(exp[i, j])
                        if i != j:
                            m_exp[j, i] = exp[j, i]
                return Matrix(m_exp)
    if type(exp) == sympy.matrices.dense.MutableDenseMatrix:
        exp = exp.as_immutable()
    exp = fu(exp)  # fast function to simplify sin and cos expressions
    exp = cancel(exp)
    exp = factor(exp)
    exp = powsimp(exp)
    exp = self.partial_factor(exp)
    exp = exp.doit()
    return exp</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="skidy" href="index.html">skidy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="skidy.kinematics_generator.SymbolicKinDyn" href="#skidy.kinematics_generator.SymbolicKinDyn">SymbolicKinDyn</a></code></h4>
<ul class="">
<li><code><a title="skidy.kinematics_generator.SymbolicKinDyn.BODY_FIXED" href="#skidy.kinematics_generator.SymbolicKinDyn.BODY_FIXED">BODY_FIXED</a></code></li>
<li><code><a title="skidy.kinematics_generator.SymbolicKinDyn.SPATIAL" href="#skidy.kinematics_generator.SymbolicKinDyn.SPATIAL">SPATIAL</a></code></li>
<li><code><a title="skidy.kinematics_generator.SymbolicKinDyn.body_ref_config" href="#skidy.kinematics_generator.SymbolicKinDyn.body_ref_config">body_ref_config</a></code></li>
<li><code><a title="skidy.kinematics_generator.SymbolicKinDyn.closed_form_inv_dyn_body_fixed" href="#skidy.kinematics_generator.SymbolicKinDyn.closed_form_inv_dyn_body_fixed">closed_form_inv_dyn_body_fixed</a></code></li>
<li><code><a title="skidy.kinematics_generator.SymbolicKinDyn.closed_form_kinematics_body_fixed" href="#skidy.kinematics_generator.SymbolicKinDyn.closed_form_kinematics_body_fixed">closed_form_kinematics_body_fixed</a></code></li>
<li><code><a title="skidy.kinematics_generator.SymbolicKinDyn.config_representation" href="#skidy.kinematics_generator.SymbolicKinDyn.config_representation">config_representation</a></code></li>
<li><code><a title="skidy.kinematics_generator.SymbolicKinDyn.dh_to_screw_coord" href="#skidy.kinematics_generator.SymbolicKinDyn.dh_to_screw_coord">dh_to_screw_coord</a></code></li>
<li><code><a title="skidy.kinematics_generator.SymbolicKinDyn.joint_screw_coord" href="#skidy.kinematics_generator.SymbolicKinDyn.joint_screw_coord">joint_screw_coord</a></code></li>
<li><code><a title="skidy.kinematics_generator.SymbolicKinDyn.load_from_urdf" href="#skidy.kinematics_generator.SymbolicKinDyn.load_from_urdf">load_from_urdf</a></code></li>
<li><code><a title="skidy.kinematics_generator.SymbolicKinDyn.partial_factor" href="#skidy.kinematics_generator.SymbolicKinDyn.partial_factor">partial_factor</a></code></li>
<li><code><a title="skidy.kinematics_generator.SymbolicKinDyn.simplify" href="#skidy.kinematics_generator.SymbolicKinDyn.simplify">simplify</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>